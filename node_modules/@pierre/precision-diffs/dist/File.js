import { getSharedHighlighter } from "./SharedHighlighter.js";
import { DEFAULT_THEMES, HEADER_METADATA_SLOT_ID } from "./constants.js";
import { getLineAnnotationName } from "./utils/getLineAnnotationName.js";
import { getThemes } from "./utils/getThemes.js";
import { FileHeaderRenderer } from "./FileHeaderRenderer.js";
import { FileRenderer } from "./FileRenderer.js";
import { MouseEventManager, getMouseEventOptions } from "./MouseEventManager.js";
import { ResizeManager } from "./ResizeManager.js";
import { PJSContainerLoaded } from "./custom-components/Container.js";
import { SVGSpriteSheet } from "./sprite.js";
import { createCodeNode, setWrapperProps } from "./utils/html_render_utils.js";
import deepEquals from "fast-deep-equal";

//#region src/File.ts
let instanceId = -1;
var File = class {
	static LoadedCustomComponent = PJSContainerLoaded;
	__id = ++instanceId;
	fileContainer;
	spriteSVG;
	pre;
	code;
	unsafeCSSStyle;
	headerElement;
	headerMetadata;
	fileRenderer;
	headerRenderer;
	resizeManager;
	mouseEventManager;
	annotationElements = [];
	lineAnnotations = [];
	file;
	constructor(options = { theme: DEFAULT_THEMES }, isContainerManaged = false) {
		this.options = options;
		this.isContainerManaged = isContainerManaged;
		this.fileRenderer = new FileRenderer(options);
		this.headerRenderer = new FileHeaderRenderer(options);
		this.resizeManager = new ResizeManager();
		this.mouseEventManager = new MouseEventManager("file", getMouseEventOptions(options));
	}
	setOptions(options) {
		if (options == null) return;
		this.options = options;
		this.mouseEventManager.setOptions(getMouseEventOptions(options));
	}
	mergeOptions(options) {
		this.options = {
			...this.options,
			...options
		};
	}
	setThemeType(themeType) {
		if ((this.options.themeType ?? "system") === themeType) return;
		this.mergeOptions({ themeType });
		this.headerRenderer.setThemeType(themeType);
		this.fileRenderer.setThemeType(themeType);
		if (this.headerElement != null) if (themeType === "system") delete this.headerElement.dataset.themeType;
		else this.headerElement.dataset.themeType = themeType;
		if (this.pre != null) switch (themeType) {
			case "system":
				delete this.pre.dataset.themeType;
				break;
			case "light":
			case "dark":
				this.pre.dataset.themeType = themeType;
				break;
		}
	}
	setLineAnnotations(lineAnnotations) {
		this.lineAnnotations = lineAnnotations;
	}
	cleanUp() {
		this.fileRenderer.cleanUp();
		this.headerRenderer.cleanUp();
		this.resizeManager.cleanUp();
		this.mouseEventManager.cleanUp();
		this.file = void 0;
		if (!this.isContainerManaged) this.fileContainer?.parentNode?.removeChild(this.fileContainer);
		this.fileContainer = void 0;
		this.pre = void 0;
		this.headerElement = void 0;
	}
	async hydrate(props) {
		if (props.fileContainer == null) throw new Error("FileDiff: you must provide a fileContainer on hydration");
		for (const element of Array.from(props.fileContainer.shadowRoot?.children ?? [])) {
			if (element instanceof SVGElement) {
				this.spriteSVG = element;
				continue;
			}
			if (!(element instanceof HTMLElement)) continue;
			if (element instanceof HTMLPreElement) {
				this.pre = element;
				continue;
			}
			if (element instanceof HTMLStyleElement) {
				this.unsafeCSSStyle = element;
				continue;
			}
			if ("pjsHeader" in element.dataset) {
				this.headerElement = element;
				continue;
			}
		}
		if (this.pre == null) await this.render(props);
		else {
			this.fileContainer = props.fileContainer;
			delete this.pre.dataset.dehydrated;
			this.lineAnnotations = props.lineAnnotations ?? this.lineAnnotations;
			this.file = props.file;
			this.fileRenderer.initializeHighlighter();
			this.renderAnnotations();
			this.injectUnsafeCSS();
			this.mouseEventManager.setup(this.pre);
			if ((this.options.overflow ?? "scroll") === "scroll") this.resizeManager.setup(this.pre);
		}
	}
	async render({ file, fileContainer, containerWrapper, forceRender = false, lineAnnotations }) {
		if (!forceRender && deepEquals(this.file, file)) return;
		this.file = file;
		this.fileRenderer.setOptions(this.options);
		if (lineAnnotations != null) {
			this.fileRenderer.setLineAnnotations(lineAnnotations);
			this.setLineAnnotations(lineAnnotations);
		}
		const { disableFileHeader = false } = this.options;
		if (disableFileHeader) {
			this.headerRenderer.cleanUp();
			if (this.headerElement != null) {
				this.headerElement.parentNode?.removeChild(this.headerElement);
				this.headerElement = void 0;
			}
		} else this.headerRenderer.setOptions(this.options);
		const [highlighter, headerResult, fileResult] = await Promise.all([
			getSharedHighlighter({
				themes: getThemes(this.options.theme),
				langs: []
			}),
			!disableFileHeader ? this.headerRenderer.render(file) : void 0,
			this.fileRenderer.render(file)
		]);
		if (headerResult == null && fileResult == null) return;
		fileContainer = this.getOrCreateFileContainer(fileContainer);
		if (headerResult != null) this.applyHeaderToDOM(headerResult, fileContainer);
		if (fileResult != null) {
			if (containerWrapper != null) containerWrapper.appendChild(fileContainer);
			const pre = this.getOrCreatePre(fileContainer);
			this.applyHunksToDOM(fileResult, pre, highlighter);
			this.renderAnnotations();
		}
	}
	renderAnnotations() {
		if (this.isContainerManaged || this.fileContainer == null) return;
		for (const element of this.annotationElements) element.parentNode?.removeChild(element);
		this.annotationElements.length = 0;
		const { renderAnnotation } = this.options;
		if (renderAnnotation != null && this.lineAnnotations.length > 0) for (const annotation of this.lineAnnotations) {
			const content = renderAnnotation(annotation);
			if (content == null) continue;
			const el = document.createElement("div");
			el.dataset.annotationSlot = "";
			el.slot = getLineAnnotationName(annotation);
			el.appendChild(content);
			this.annotationElements.push(el);
			this.fileContainer.appendChild(el);
		}
	}
	injectUnsafeCSS() {
		if (this.fileContainer?.shadowRoot == null) return;
		const { unsafeCSS } = this.options;
		if (unsafeCSS == null || unsafeCSS === "") return;
		if (this.unsafeCSSStyle == null) {
			this.unsafeCSSStyle = document.createElement("style");
			this.fileContainer.shadowRoot.appendChild(this.unsafeCSSStyle);
		}
		this.unsafeCSSStyle.insertAdjacentText("beforeend", `@layer unsafe {\n${unsafeCSS}\n}`);
	}
	applyHunksToDOM(result, pre, highlighter) {
		this.setPreAttributes(pre, highlighter, result.totalLines);
		pre.innerHTML = "";
		this.code = createCodeNode();
		this.code.innerHTML = this.fileRenderer.renderPartialHTML(result.codeAST);
		pre.appendChild(this.code);
		this.injectUnsafeCSS();
		this.mouseEventManager.setup(pre);
		if ((this.options.overflow ?? "scroll") === "scroll") this.resizeManager.setup(pre);
		else this.resizeManager.cleanUp();
	}
	applyHeaderToDOM(headerAST, container) {
		const { file } = this;
		if (file == null) return;
		const tempDiv = document.createElement("div");
		tempDiv.innerHTML = this.headerRenderer.renderResultToHTML(headerAST);
		const newHeader = tempDiv.firstElementChild;
		if (!(newHeader instanceof HTMLElement)) return;
		if (this.headerElement != null) container.shadowRoot?.replaceChild(newHeader, this.headerElement);
		else container.shadowRoot?.prepend(newHeader);
		this.headerElement = newHeader;
		if (this.isContainerManaged) return;
		const { renderCustomMetadata } = this.options;
		if (this.headerMetadata != null) this.headerMetadata.parentNode?.removeChild(this.headerMetadata);
		const content = renderCustomMetadata?.(file) ?? void 0;
		if (content != null) {
			this.headerMetadata = document.createElement("div");
			this.headerMetadata.slot = HEADER_METADATA_SLOT_ID;
			if (content instanceof Element) this.headerMetadata.appendChild(content);
			else this.headerMetadata.innerText = `${content}`;
			container.appendChild(this.headerMetadata);
		}
	}
	getOrCreateFileContainer(fileContainer) {
		this.fileContainer = fileContainer ?? this.fileContainer ?? document.createElement("file-diff");
		if (this.spriteSVG == null) {
			const fragment = document.createElement("div");
			fragment.innerHTML = SVGSpriteSheet;
			const firstChild = fragment.firstChild;
			if (firstChild instanceof SVGElement) {
				this.spriteSVG = firstChild;
				this.fileContainer.shadowRoot?.appendChild(this.spriteSVG);
			}
		}
		return this.fileContainer;
	}
	getOrCreatePre(container) {
		if (this.pre == null) {
			this.pre = document.createElement("pre");
			container.shadowRoot?.appendChild(this.pre);
		} else if (this.pre.parentNode !== container) container.shadowRoot?.appendChild(this.pre);
		return this.pre;
	}
	setPreAttributes(pre, highlighter, totalLines) {
		const { overflow = "scroll", theme, themeType = "system" } = this.options;
		setWrapperProps({
			pre,
			theme,
			highlighter,
			split: false,
			wrap: overflow === "wrap",
			themeType,
			diffIndicators: "none",
			disableBackground: true,
			totalLines
		});
	}
};

//#endregion
export { File };
//# sourceMappingURL=File.js.map