import { getSharedHighlighter, hasLoadedLanguage, hasLoadedThemes } from "./SharedHighlighter.js";
import { DEFAULT_THEMES } from "./constants.js";
import { createMirroredAnnotationSpan } from "./utils/createMirroredAnnotationSpan.js";
import { createSingleAnnotationSpan } from "./utils/createSingleAnnotationSpan.js";
import { formatCSSVariablePrefix } from "./utils/formatCSSVariablePrefix.js";
import { createHastElement, createPreWrapperProperties, createSeparator } from "./utils/hast_utils.js";
import { createTransformerWithState } from "./utils/createTransformerWithState.js";
import { getFiletypeFromFileName } from "./utils/getFiletypeFromFileName.js";
import { getThemes } from "./utils/getThemes.js";
import { getHighlighterOptions } from "./utils/getHighlighterOptions.js";
import { getHunkSeparatorSlotName } from "./utils/getHunkSeparatorSlotName.js";
import { getTotalLineCountFromHunks } from "./utils/getTotalLineCountFromHunks.js";
import { parseDecorations } from "./utils/parseDiffDecorations.js";
import { parseLineType } from "./utils/parseLineType.js";
import { pushOrMergeSpan } from "./utils/pushOrMergeSpan.js";
import { toHtml } from "hast-util-to-html";

//#region src/DiffHunksRenderer.ts
var DiffHunksRenderer = class {
	highlighter;
	options;
	diff;
	expandedHunks = /* @__PURE__ */ new Set();
	deletionAnnotations = {};
	additionAnnotations = {};
	queuedDiff;
	queuedRender;
	computedLang = "text";
	constructor(options = { theme: DEFAULT_THEMES }) {
		this.options = options;
	}
	cleanUp() {
		this.highlighter = void 0;
		this.diff = void 0;
		this.queuedDiff = void 0;
		this.queuedRender = void 0;
	}
	setOptions(options) {
		this.options = options;
	}
	expandHunk(index) {
		this.expandedHunks.add(index);
	}
	isHunkExpanded(index) {
		return this.getOptionsWithDefaults().expandUnchanged || this.expandedHunks.has(index);
	}
	mergeOptions(options) {
		this.options = {
			...this.options,
			...options
		};
	}
	setThemeType(themeType) {
		if (this.getOptionsWithDefaults().themeType === themeType) return;
		this.mergeOptions({ themeType });
	}
	setLineAnnotations(lineAnnotations) {
		this.additionAnnotations = {};
		this.deletionAnnotations = {};
		for (const annotation of lineAnnotations) {
			const map = (() => {
				switch (annotation.side) {
					case "deletions": return this.deletionAnnotations;
					case "additions": return this.additionAnnotations;
				}
			})();
			const arr = map[annotation.lineNumber] ?? [];
			map[annotation.lineNumber] = arr;
			arr.push(annotation);
		}
	}
	getOptionsWithDefaults() {
		const { diffIndicators = "bars", diffStyle = "split", disableBackground = false, disableLineNumbers = false, expandUnchanged = false, hunkSeparators = "line-info", lineDiffType = "word-alt", maxLineDiffLength = 1e3, maxLineLengthForHighlighting = 1e3, overflow = "scroll", theme = DEFAULT_THEMES, themeType = "system", useCSSClasses = false } = this.options;
		return {
			diffIndicators,
			diffStyle,
			disableBackground,
			disableLineNumbers,
			expandUnchanged,
			hunkSeparators,
			lineDiffType,
			maxLineDiffLength,
			maxLineLengthForHighlighting,
			overflow,
			theme,
			themeType,
			useCSSClasses
		};
	}
	async initializeHighlighter() {
		this.highlighter = await getSharedHighlighter(getHighlighterOptions(this.computedLang, this.options));
		return this.highlighter;
	}
	async render(diff) {
		this.queuedDiff = diff;
		if (this.queuedRender != null) return this.queuedRender;
		this.queuedRender = (async () => {
			this.computedLang = this.options.lang ?? getFiletypeFromFileName(diff.name);
			if (!hasLoadedLanguage(this.computedLang) || !hasLoadedThemes(getThemes(this.options.theme))) this.highlighter = void 0;
			this.highlighter ??= await this.initializeHighlighter();
			if (this.queuedDiff == null) return;
			return this.renderDiff(this.queuedDiff, this.highlighter);
		})();
		const result = await this.queuedRender;
		this.queuedDiff = void 0;
		this.queuedRender = void 0;
		return result;
	}
	renderDiff(fileDiff, highlighter) {
		const { disableLineNumbers, diffStyle, overflow, themeType, disableBackground, diffIndicators, expandUnchanged, useCSSClasses, theme } = this.getOptionsWithDefaults();
		this.diff = fileDiff;
		const additionsAST = [];
		const deletionsAST = [];
		const unifiedAST = [];
		const { state, transformers, toClass } = createTransformerWithState({
			disableLineNumbers,
			useCSSClasses
		});
		let hunkIndex = 0;
		const hunkData = [];
		let prevHunk;
		const hunks = (() => {
			if (fileDiff.hunks.length > 0) return fileDiff.hunks;
			if (expandUnchanged && this.diff?.newLines != null && this.diff.newLines.length > 0) {
				const lineCount = this.diff.newLines.length + 1;
				return [{
					additionCount: 0,
					additionStart: lineCount,
					deletedCount: 0,
					deletedStart: lineCount,
					hunkContent: [],
					hunkContext: void 0,
					hunkSpecs: void 0
				}];
			}
			return [];
		})();
		for (const hunk of hunks) {
			this.renderHunks({
				hunk,
				prevHunk,
				hunkIndex,
				highlighter,
				state,
				transformers,
				isFirstHunk: hunkIndex === 0,
				isLastHunk: hunkIndex === fileDiff.hunks.length - 1,
				additionsAST,
				deletionsAST,
				unifiedAST,
				hunkData
			});
			hunkIndex++;
			prevHunk = hunk;
		}
		const totalLines = Math.max(getTotalLineCountFromHunks(fileDiff.hunks), fileDiff.newLines?.length ?? 0, fileDiff.oldLines?.length ?? 0);
		return {
			additionsAST: additionsAST.length > 0 ? additionsAST : void 0,
			deletionsAST: deletionsAST.length > 0 ? deletionsAST : void 0,
			unifiedAST: unifiedAST.length > 0 ? unifiedAST : void 0,
			hunkData,
			css: toClass.getCSS(),
			preNode: createHastElement({
				tagName: "pre",
				properties: createPreWrapperProperties({
					diffIndicators,
					disableBackground,
					highlighter,
					overflow,
					split: diffStyle === "unified" ? false : additionsAST.length > 0 && additionsAST.length > 0,
					theme,
					themeType,
					totalLines
				})
			}),
			totalLines
		};
	}
	renderFullAST(result, children = []) {
		if (result.unifiedAST != null) children.push(createHastElement({
			tagName: "code",
			children: result.unifiedAST,
			properties: {
				"data-code": "",
				"data-unified": ""
			}
		}));
		if (result.deletionsAST != null) children.push(createHastElement({
			tagName: "code",
			children: result.deletionsAST,
			properties: {
				"data-code": "",
				"data-deletions": ""
			}
		}));
		if (result.additionsAST != null) children.push(createHastElement({
			tagName: "code",
			children: result.additionsAST,
			properties: {
				"data-code": "",
				"data-additions": ""
			}
		}));
		return {
			...result.preNode,
			children
		};
	}
	renderFullHTML(result, tempChildren = []) {
		return toHtml(this.renderFullAST(result, tempChildren));
	}
	renderPartialHTML(children, columnType) {
		if (columnType == null) return toHtml(children);
		return toHtml(createHastElement({
			tagName: "code",
			children,
			properties: {
				"data-code": "",
				[`data-${columnType}`]: ""
			}
		}));
	}
	createHastOptions(transformers, decorations, forceTextLang = false) {
		const { theme } = this.getOptionsWithDefaults();
		if (typeof theme === "string") return {
			theme,
			cssVariablePrefix: formatCSSVariablePrefix(),
			lang: forceTextLang ? "text" : this.computedLang,
			defaultColor: false,
			transformers,
			decorations
		};
		return {
			themes: theme,
			cssVariablePrefix: formatCSSVariablePrefix(),
			lang: forceTextLang ? "text" : this.computedLang,
			defaultColor: false,
			transformers,
			decorations
		};
	}
	renderHunks({ hunk, hunkIndex, highlighter, state, transformers, prevHunk, isFirstHunk, isLastHunk, additionsAST, deletionsAST, unifiedAST, hunkData }) {
		if (hunk.hunkContent == null) return;
		const { hunkSeparators } = this.getOptionsWithDefaults();
		const { additions, deletions, unified, hasLongLines } = this.processLines(hunk, hunkIndex, prevHunk, isLastHunk);
		const expandable = this.diff?.newLines != null;
		const generateLinesAST = (type, computed, linesAST) => {
			const content = computed.content.join("").replace(/\n$/, "");
			state.lineInfo = computed.lineInfo;
			const nodes = highlighter.codeToHast(content, this.createHastOptions(transformers, computed.decorations, hasLongLines));
			if (!this.isHunkExpanded(hunkIndex)) {
				if (hunkSeparators === "line-info" || hunkSeparators === "custom") {
					const lines = (() => {
						const hunkStart = hunk.additionStart;
						if (prevHunk == null) return hunkStart - 1;
						return hunkStart - (prevHunk.additionStart + prevHunk.additionCount);
					})();
					if (lines > 0) {
						const slotName = getHunkSeparatorSlotName(type, hunkIndex);
						linesAST.push(createSeparator({
							type: hunkSeparators,
							content: getModifiedLinesString(lines),
							expandIndex: expandable ? hunkIndex : void 0,
							slotName,
							isFirstHunk,
							isLastHunk: false
						}));
						hunkData.push({
							slotName,
							lines,
							type,
							expandable
						});
					}
				} else if (hunkSeparators === "metadata" && hunk.hunkSpecs != null) linesAST.push(createSeparator({
					type: "metadata",
					content: hunk.hunkSpecs,
					isFirstHunk,
					isLastHunk: false
				}));
				else if (hunkSeparators === "simple" && hunkIndex > 0) linesAST.push(createSeparator({
					type: "simple",
					isFirstHunk,
					isLastHunk: false
				}));
			}
			for (const line of getLineNodes(nodes)) linesAST.push(line);
			if (isLastHunk && !this.isHunkExpanded(hunkIndex + 1) && this.diff?.newLines != null && (hunkSeparators === "line-info" || hunkSeparators === "custom")) {
				const lines = this.diff.newLines.length - (hunk.additionStart + hunk.additionCount - 1);
				if (lines > 0) {
					const slotName = getHunkSeparatorSlotName(type, hunkIndex + 1);
					linesAST.push(createSeparator({
						type: hunkSeparators,
						content: getModifiedLinesString(lines),
						expandIndex: expandable ? hunkIndex + 1 : void 0,
						slotName,
						isFirstHunk: false,
						isLastHunk
					}));
					hunkData.push({
						slotName,
						lines,
						type,
						expandable
					});
				}
			}
		};
		if (unified.content.length > 0) generateLinesAST("unified", unified, unifiedAST);
		if (deletions.content.length > 0) generateLinesAST("deletions", deletions, deletionsAST);
		if (additions.content.length > 0) generateLinesAST("additions", additions, additionsAST);
	}
	processLines(hunk, hunkIndex, prevHunk, isLastHunk) {
		const { maxLineLengthForHighlighting, diffStyle, expandUnchanged, lineDiffType, maxLineDiffLength } = this.getOptionsWithDefaults();
		const { deletionAnnotations, additionAnnotations } = this;
		const unified = diffStyle === "unified";
		let hasLongLines = false;
		const additionContent = [];
		const additionLineInfo = {};
		let additionLineNumber = hunk.additionStart - 1;
		const deletionContent = [];
		const deletionLineInfo = {};
		let deletionLineNumber = hunk.deletedStart - 1;
		const unifiedContent = [];
		const unifiedLineInfo = {};
		const diffGroups = [];
		const unresolvedSpans = [];
		let currentChangeGroup;
		function resolveUnresolvedSpans() {
			if (currentChangeGroup == null) {
				if (unresolvedSpans.length > 0) console.error("DiffHunksRenderer.processLines: resolveUnresolvedSpans: In a weird state...", unresolvedSpans);
				return;
			}
			for (const unresolvedSpan of unresolvedSpans) {
				const deletionIndex = currentChangeGroup.deletionStartIndex + unresolvedSpan.hunkIndex;
				const additionIndex = currentChangeGroup.additionStartIndex + unresolvedSpan.hunkIndex;
				const resolvedSpan = {
					type: "annotation",
					hunkIndex,
					lineIndex: unresolvedSpan.span.lineIndex,
					annotations: []
				};
				if (unresolvedSpan.type === "addition") pushOrMergeSpan(resolvedSpan, Math.min(deletionIndex, currentChangeGroup.deletionStartIndex + currentChangeGroup.deletionLines.length), deletionLineInfo);
				else pushOrMergeSpan(resolvedSpan, Math.min(additionIndex, currentChangeGroup.additionStartIndex + currentChangeGroup.additionLines.length), additionLineInfo);
			}
			unresolvedSpans.length = 0;
		}
		function addToChangeGroup(type, line, span) {
			if (currentChangeGroup == null) {
				currentChangeGroup = {
					deletionStartIndex: unified ? -1 : deletionContent.length,
					additionStartIndex: unified ? -1 : additionContent.length,
					deletionLines: [],
					additionLines: [],
					diffGroupStartIndex: lineIndex
				};
				diffGroups.push(currentChangeGroup);
			}
			if (unified) {
				if (type === "deletion" && currentChangeGroup.deletionStartIndex === -1) currentChangeGroup.deletionStartIndex = unifiedContent.length;
				if (type === "addition" && currentChangeGroup.additionStartIndex === -1) currentChangeGroup.additionStartIndex = unifiedContent.length;
			}
			if (type === "addition") currentChangeGroup.additionLines.push(line);
			else currentChangeGroup.deletionLines.push(line);
			if (span != null && !unified) unresolvedSpans.push({
				type,
				hunkIndex: type === "deletion" ? currentChangeGroup.deletionLines.length : currentChangeGroup.additionLines.length,
				span
			});
			return currentChangeGroup;
		}
		function createGapSpanIfNecessary() {
			if (!unified && lastType !== "context" && lastType != null && currentChangeGroup != null) {
				const additionGroupSize = currentChangeGroup.additionLines.length;
				const deletionGroupSize = currentChangeGroup.deletionLines.length;
				if (additionGroupSize > deletionGroupSize) pushOrMergeSpan({
					type: "gap",
					rows: additionGroupSize - deletionGroupSize
				}, deletionContent.length, deletionLineInfo);
				else if (deletionGroupSize > additionGroupSize) pushOrMergeSpan({
					type: "gap",
					rows: deletionGroupSize - additionGroupSize
				}, additionContent.length, additionLineInfo);
			}
			resolveUnresolvedSpans();
		}
		const processRawLine = (line, type, isExpandedContext = false) => {
			lineIndex++;
			if (type === "context") createGapSpanIfNecessary();
			if (type === "context") {
				if (currentChangeGroup != null) lineIndex = currentChangeGroup.diffGroupStartIndex + Math.max(currentChangeGroup.additionLines.length, currentChangeGroup.deletionLines.length);
				currentChangeGroup = void 0;
				if (unified) {
					unifiedContent.push(line);
					unifiedLineInfo[unifiedContent.length] = {
						type: isExpandedContext ? "context-expanded" : "context",
						lineNumber: additionLineNumber + 1,
						lineIndex
					};
					pushOrMergeSpan(createMirroredAnnotationSpan({
						deletionLineNumber: deletionLineNumber + 1,
						additionLineNumber: additionLineNumber + 1,
						hunkIndex,
						lineIndex: unifiedContent.length,
						deletionAnnotations,
						additionAnnotations,
						unified: true
					}), unifiedContent.length, unifiedLineInfo);
				} else {
					deletionContent.push(line);
					additionContent.push(line);
					deletionLineInfo[deletionContent.length] = {
						type: isExpandedContext ? "context-expanded" : "context",
						lineNumber: deletionLineNumber + 1,
						lineIndex
					};
					additionLineInfo[additionContent.length] = {
						type: isExpandedContext ? "context-expanded" : "context",
						lineNumber: additionLineNumber + 1,
						lineIndex
					};
					const [deletionSpan, additionSpan] = createMirroredAnnotationSpan({
						deletionLineNumber: deletionLineNumber + 1,
						additionLineNumber: additionLineNumber + 1,
						hunkIndex,
						lineIndex,
						deletionAnnotations,
						additionAnnotations,
						unified: false
					});
					pushOrMergeSpan(deletionSpan, deletionContent.length, deletionLineInfo);
					pushOrMergeSpan(additionSpan, additionContent.length, additionLineInfo);
				}
				additionLineNumber++;
				deletionLineNumber++;
			} else if (type === "metadata") {
				const lineInfo = {
					type: lastType === "addition" ? "change-addition" : lastType === "deletion" ? "change-deletion" : "context",
					lineNumber: -1,
					lineIndex: -1,
					metadataContent: line.trim()
				};
				if (unified) {
					unifiedContent.push("\n");
					unifiedLineInfo[unifiedContent.length] = lineInfo;
				} else {
					if (lastType === "context" || lastType === "deletion") {
						deletionContent.push("\n");
						deletionLineInfo[deletionContent.length] = lineInfo;
						addToChangeGroup("deletion", "\n");
					}
					if (lastType === "context" || lastType === "addition") {
						additionContent.push("\n");
						additionLineInfo[additionContent.length] = lineInfo;
						addToChangeGroup("addition", "\n");
					}
				}
			} else if (type === "deletion") {
				const { content, lineInfo } = (() => unified ? {
					content: unifiedContent,
					lineInfo: unifiedLineInfo
				} : {
					content: deletionContent,
					lineInfo: deletionLineInfo
				})();
				const span = createSingleAnnotationSpan({
					rowNumber: deletionLineNumber + 1,
					hunkIndex,
					lineIndex,
					annotationMap: this.deletionAnnotations
				});
				addToChangeGroup("deletion", line, span);
				content.push(line);
				lineInfo[content.length] = {
					type: "change-deletion",
					lineNumber: deletionLineNumber + 1,
					lineIndex
				};
				pushOrMergeSpan(span, content.length, lineInfo);
				deletionLineNumber++;
			} else if (type === "addition") {
				if (lastType === "deletion" && !unified) lineIndex = currentChangeGroup?.diffGroupStartIndex ?? lineIndex;
				const { content, lineInfo } = (() => unified ? {
					content: unifiedContent,
					lineInfo: unifiedLineInfo
				} : {
					content: additionContent,
					lineInfo: additionLineInfo
				})();
				const span = createSingleAnnotationSpan({
					rowNumber: additionLineNumber + 1,
					hunkIndex,
					lineIndex,
					annotationMap: this.additionAnnotations
				});
				addToChangeGroup("addition", line, span);
				content.push(line);
				lineInfo[content.length] = {
					type: "change-addition",
					lineNumber: additionLineNumber + 1,
					lineIndex
				};
				pushOrMergeSpan(span, content.length, lineInfo);
				additionLineNumber++;
			}
			lastType = type;
		};
		let lineIndex = -1;
		let lastType;
		if (this.isHunkExpanded(hunkIndex) && this.diff?.newLines != null) {
			const { expandAddedStart, expandDeletedStart } = (() => {
				if (prevHunk != null) return {
					expandAddedStart: prevHunk.additionStart + prevHunk.additionCount - 1,
					expandDeletedStart: prevHunk.deletedStart + prevHunk.deletedCount - 1
				};
				return {
					expandAddedStart: 0,
					expandDeletedStart: 0
				};
			})();
			if (additionLineNumber - expandAddedStart > 0) {
				additionLineNumber = expandAddedStart;
				deletionLineNumber = expandDeletedStart;
				for (let i = additionLineNumber; i < hunk.additionStart - 1; i++) {
					const line = this.diff.newLines[i];
					hasLongLines = hasLongLines || line.length > maxLineLengthForHighlighting;
					processRawLine(line, "context", expandUnchanged ? false : true);
				}
			}
		}
		for (const rawLine of hunk.hunkContent ?? []) {
			const { line, type, longLine } = parseLineType(rawLine, maxLineLengthForHighlighting);
			hasLongLines = hasLongLines || longLine;
			processRawLine(line, type);
		}
		createGapSpanIfNecessary();
		if (isLastHunk && this.isHunkExpanded(hunkIndex + 1) && this.diff?.newLines != null) for (let i = additionLineNumber; i < this.diff.newLines.length; i++) {
			const line = this.diff.newLines[i];
			hasLongLines = hasLongLines || line.length > maxLineLengthForHighlighting;
			processRawLine(line, "context", expandUnchanged ? false : true);
		}
		resolveUnresolvedSpans();
		const { unifiedDecorations, deletionDecorations, additionDecorations } = parseDecorations({
			diffGroups,
			lineDiffType,
			diffStyle,
			maxLineDiffLength
		});
		return {
			hasLongLines,
			additions: {
				content: additionContent,
				lineInfo: additionLineInfo,
				decorations: additionDecorations
			},
			deletions: {
				content: deletionContent,
				lineInfo: deletionLineInfo,
				decorations: deletionDecorations
			},
			unified: {
				content: unifiedContent,
				lineInfo: unifiedLineInfo,
				decorations: unifiedDecorations
			}
		};
	}
};
function getLineNodes(nodes) {
	let firstChild = nodes.children[0];
	while (firstChild != null) {
		if (firstChild.type === "element" && firstChild.tagName === "code") return firstChild.children;
		if ("children" in firstChild) firstChild = firstChild.children[0];
		else firstChild = null;
	}
	console.error(nodes);
	throw new Error("DiffHunksRenderer.getNodesToRender: Unable to find children");
}
function getModifiedLinesString(lines) {
	return `${lines} unmodified line${lines > 1 ? "s" : ""}`;
}

//#endregion
export { DiffHunksRenderer };
//# sourceMappingURL=DiffHunksRenderer.js.map