import { getSharedHighlighter } from "./SharedHighlighter.js";
import { DEFAULT_THEMES, HEADER_METADATA_SLOT_ID } from "./constants.js";
import { getLineAnnotationName } from "./utils/getLineAnnotationName.js";
import { getThemes } from "./utils/getThemes.js";
import { DiffHunksRenderer } from "./DiffHunksRenderer.js";
import { FileHeaderRenderer } from "./FileHeaderRenderer.js";
import { MouseEventManager, getMouseEventOptions } from "./MouseEventManager.js";
import { ResizeManager } from "./ResizeManager.js";
import { PJSContainerLoaded } from "./custom-components/Container.js";
import { SVGSpriteSheet } from "./sprite.js";
import { createCodeNode, setWrapperProps } from "./utils/html_render_utils.js";
import { ScrollSyncManager } from "./ScrollSyncManager.js";
import { parseDiffFromFile } from "./utils/parseDiffFromFile.js";
import deepEquals from "fast-deep-equal";

//#region src/FileDiff.ts
let instanceId = -1;
var FileDiff = class {
	static LoadedCustomComponent = PJSContainerLoaded;
	__id = ++instanceId;
	fileContainer;
	spriteSVG;
	pre;
	unsafeCSSStyle;
	headerElement;
	headerMetadata;
	customHunkElements = [];
	hunksRenderer;
	headerRenderer;
	resizeManager;
	scrollSyncManager;
	mouseEventManager;
	annotationElements = [];
	lineAnnotations = [];
	oldFile;
	newFile;
	fileDiff;
	constructor(options = { theme: DEFAULT_THEMES }, isContainerManaged = false) {
		this.options = options;
		this.isContainerManaged = isContainerManaged;
		this.hunksRenderer = new DiffHunksRenderer({
			...options,
			hunkSeparators: typeof options.hunkSeparators === "function" ? "custom" : options.hunkSeparators
		});
		this.headerRenderer = new FileHeaderRenderer(options);
		this.resizeManager = new ResizeManager();
		this.scrollSyncManager = new ScrollSyncManager();
		this.mouseEventManager = new MouseEventManager("diff", getMouseEventOptions(options, typeof options.hunkSeparators === "function" || (options.hunkSeparators ?? "line-info") === "line-info" ? this.handleExpandHunk : void 0));
	}
	setOptions(options) {
		if (options == null) return;
		this.options = options;
		this.hunksRenderer.setOptions({
			...this.options,
			hunkSeparators: typeof options.hunkSeparators === "function" ? "custom" : options.hunkSeparators
		});
		this.mouseEventManager.setOptions(getMouseEventOptions(options, typeof options.hunkSeparators === "function" || (options.hunkSeparators ?? "line-info") === "line-info" ? this.handleExpandHunk : void 0));
	}
	mergeOptions(options) {
		this.options = {
			...this.options,
			...options
		};
	}
	setThemeType(themeType) {
		if ((this.options.themeType ?? "system") === themeType) return;
		this.mergeOptions({ themeType });
		this.hunksRenderer.setThemeType(themeType);
		this.headerRenderer.setThemeType(themeType);
		if (this.headerElement != null) if (themeType === "system") delete this.headerElement.dataset.themeType;
		else this.headerElement.dataset.themeType = themeType;
		if (this.pre != null) switch (themeType) {
			case "system":
				delete this.pre.dataset.themeType;
				break;
			case "light":
			case "dark":
				this.pre.dataset.themeType = themeType;
				break;
		}
	}
	setLineAnnotations(lineAnnotations) {
		this.lineAnnotations = lineAnnotations;
	}
	cleanUp() {
		this.hunksRenderer.cleanUp();
		this.headerRenderer.cleanUp();
		this.resizeManager.cleanUp();
		this.mouseEventManager.cleanUp();
		this.scrollSyncManager.cleanUp();
		this.fileDiff = void 0;
		this.oldFile = void 0;
		this.newFile = void 0;
		if (!this.isContainerManaged) this.fileContainer?.parentNode?.removeChild(this.fileContainer);
		this.fileContainer = void 0;
		this.pre = void 0;
		this.headerElement = void 0;
	}
	async hydrate(props) {
		if (props.fileContainer == null) throw new Error("FileDiff: you must provide a fileContainer on hydration");
		for (const element of Array.from(props.fileContainer.shadowRoot?.children ?? [])) {
			if (element instanceof SVGElement) {
				this.spriteSVG = element;
				continue;
			}
			if (!(element instanceof HTMLElement)) continue;
			if (element instanceof HTMLPreElement) {
				this.pre = element;
				continue;
			}
			if ("pjsHeader" in element.dataset) {
				this.headerElement = element;
				continue;
			}
			if (element instanceof HTMLStyleElement) {
				this.unsafeCSSStyle = element;
				continue;
			}
		}
		if (this.pre == null) await this.render(props);
		else {
			this.fileContainer = props.fileContainer;
			delete this.pre.dataset.dehydrated;
			this.lineAnnotations = props.lineAnnotations ?? this.lineAnnotations;
			this.newFile = props.newFile;
			this.oldFile = props.oldFile;
			this.fileDiff = props.fileDiff;
			this.hunksRenderer.initializeHighlighter();
			this.renderAnnotations();
			this.injectUnsafeCSS();
			this.mouseEventManager.setup(this.pre);
			if ((this.options.overflow ?? "scroll") === "scroll") {
				this.resizeManager.setup(this.pre);
				this.scrollSyncManager.setup(this.pre);
			}
		}
	}
	async rerender() {
		await this.render({
			oldFile: this.oldFile,
			newFile: this.newFile,
			fileDiff: this.fileDiff,
			forceRender: true
		});
	}
	handleExpandHunk = (hunkIndex) => {
		this.hunksRenderer.expandHunk(hunkIndex);
		this.rerender();
	};
	async render({ oldFile, newFile, fileDiff, fileContainer, forceRender = false, lineAnnotations, containerWrapper }) {
		const annotationsChanged = lineAnnotations != null && !deepEquals(lineAnnotations, this.lineAnnotations);
		if (!forceRender && oldFile != null && newFile != null && !annotationsChanged && deepEquals(oldFile, this.oldFile) && deepEquals(newFile, this.newFile)) return;
		if (!forceRender && fileDiff != null && fileDiff === this.fileDiff && !annotationsChanged) return;
		this.oldFile = oldFile;
		this.newFile = newFile;
		if (fileDiff != null) this.fileDiff = fileDiff;
		else if (oldFile != null && newFile != null) this.fileDiff = parseDiffFromFile(oldFile, newFile);
		if (lineAnnotations != null) this.setLineAnnotations(lineAnnotations);
		if (this.fileDiff == null) return;
		this.hunksRenderer.setOptions({
			...this.options,
			hunkSeparators: typeof this.options.hunkSeparators === "function" ? "custom" : this.options.hunkSeparators
		});
		this.hunksRenderer.setLineAnnotations(this.lineAnnotations);
		const { disableFileHeader = false } = this.options;
		if (disableFileHeader) {
			this.headerRenderer.cleanUp();
			if (this.headerElement != null) {
				this.headerElement.parentNode?.removeChild(this.headerElement);
				this.headerElement = void 0;
			}
		} else {
			const { theme, themeType } = this.options;
			this.headerRenderer.setOptions({
				theme,
				themeType
			});
		}
		const [highlighter, headerResult, hunksResult] = await Promise.all([
			getSharedHighlighter({
				themes: getThemes(this.options.theme),
				langs: []
			}),
			!disableFileHeader ? this.headerRenderer.render(this.fileDiff) : void 0,
			this.hunksRenderer.render(this.fileDiff)
		]);
		if (headerResult == null && hunksResult == null) return;
		fileContainer = this.getOrCreateFileContainer(fileContainer);
		if (headerResult != null) this.applyHeaderToDOM(headerResult, fileContainer);
		if (hunksResult != null) {
			if (containerWrapper != null) containerWrapper.appendChild(fileContainer);
			const pre = this.getOrCreatePre(fileContainer);
			this.applyHunksToDOM(hunksResult, pre, highlighter);
			this.renderSeparators(hunksResult.hunkData);
			this.renderAnnotations();
		}
	}
	renderSeparators(hunkData) {
		const { hunkSeparators } = this.options;
		if (this.isContainerManaged || this.fileContainer == null || typeof hunkSeparators !== "function") return;
		for (const element of this.customHunkElements) element.parentNode?.removeChild(element);
		this.customHunkElements.length = 0;
		for (const hunk of hunkData) {
			const element = document.createElement("div");
			element.style.display = "contents";
			element.slot = hunk.slotName;
			element.appendChild(hunkSeparators(hunk));
			this.fileContainer.appendChild(element);
			this.customHunkElements.push(element);
		}
	}
	renderAnnotations() {
		if (this.isContainerManaged || this.fileContainer == null) return;
		for (const element of this.annotationElements) element.parentNode?.removeChild(element);
		this.annotationElements.length = 0;
		const { renderAnnotation } = this.options;
		if (renderAnnotation != null && this.lineAnnotations.length > 0) for (const annotation of this.lineAnnotations) {
			const content = renderAnnotation(annotation);
			if (content == null) continue;
			const el = document.createElement("div");
			el.dataset.annotationSlot = "";
			el.slot = getLineAnnotationName(annotation);
			el.appendChild(content);
			this.annotationElements.push(el);
			this.fileContainer.appendChild(el);
		}
	}
	getOrCreateFileContainer(fileContainer) {
		this.fileContainer = fileContainer ?? this.fileContainer ?? document.createElement("file-diff");
		if (this.spriteSVG == null) {
			const fragment = document.createElement("div");
			fragment.innerHTML = SVGSpriteSheet;
			const firstChild = fragment.firstChild;
			if (firstChild instanceof SVGElement) {
				this.spriteSVG = firstChild;
				this.fileContainer.shadowRoot?.appendChild(this.spriteSVG);
			}
		}
		return this.fileContainer;
	}
	getFileContainer() {
		return this.fileContainer;
	}
	getOrCreatePre(container) {
		if (this.pre == null) {
			this.pre = document.createElement("pre");
			container.shadowRoot?.appendChild(this.pre);
		} else if (this.pre.parentNode !== container) container.shadowRoot?.appendChild(this.pre);
		return this.pre;
	}
	applyHeaderToDOM(headerAST, container) {
		const tempDiv = document.createElement("div");
		tempDiv.innerHTML = this.headerRenderer.renderResultToHTML(headerAST);
		const newHeader = tempDiv.firstElementChild;
		if (!(newHeader instanceof HTMLElement)) return;
		if (this.headerElement != null) container.shadowRoot?.replaceChild(newHeader, this.headerElement);
		else container.shadowRoot?.prepend(newHeader);
		this.headerElement = newHeader;
		if (this.isContainerManaged) return;
		const { renderHeaderMetadata } = this.options;
		if (this.headerMetadata != null) this.headerMetadata.parentNode?.removeChild(this.headerMetadata);
		const content = renderHeaderMetadata?.({
			oldFile: this.oldFile,
			newFile: this.newFile,
			fileDiff: this.fileDiff
		}) ?? void 0;
		if (content != null) {
			this.headerMetadata = document.createElement("div");
			this.headerMetadata.slot = HEADER_METADATA_SLOT_ID;
			if (content instanceof Element) this.headerMetadata.appendChild(content);
			else this.headerMetadata.innerText = `${content}`;
			container.appendChild(this.headerMetadata);
		}
	}
	setPreAttributes(pre, highlighter, result) {
		const { diffStyle = "split", overflow = "scroll", theme, themeType = "system", diffIndicators = "bars", disableBackground = false } = this.options;
		setWrapperProps({
			pre,
			theme,
			highlighter,
			split: diffStyle === "unified" ? false : result.additionsAST != null && result.deletionsAST != null,
			wrap: overflow === "wrap",
			themeType,
			diffIndicators,
			disableBackground,
			totalLines: result.totalLines
		});
	}
	injectUnsafeCSS() {
		if (this.fileContainer?.shadowRoot == null) return;
		const { unsafeCSS } = this.options;
		if (unsafeCSS == null || unsafeCSS === "") return;
		if (this.unsafeCSSStyle == null) {
			this.unsafeCSSStyle = document.createElement("style");
			this.fileContainer.shadowRoot.appendChild(this.unsafeCSSStyle);
		}
		this.unsafeCSSStyle.insertAdjacentText("beforeend", `@layer unsafe {\n${unsafeCSS}\n}`);
	}
	applyHunksToDOM(result, pre, highlighter) {
		this.setPreAttributes(pre, highlighter, result);
		pre.innerHTML = "";
		let codeDeletions;
		let codeAdditions;
		if (result.unifiedAST != null) {
			const codeUnified = createCodeNode({ columnType: "unified" });
			codeUnified.innerHTML = this.hunksRenderer.renderPartialHTML(result.unifiedAST);
			pre.appendChild(codeUnified);
		} else {
			if (result.deletionsAST != null) {
				codeDeletions = createCodeNode({ columnType: "deletions" });
				codeDeletions.innerHTML = this.hunksRenderer.renderPartialHTML(result.deletionsAST);
				pre.appendChild(codeDeletions);
			}
			if (result.additionsAST != null) {
				codeAdditions = createCodeNode({ columnType: "additions" });
				codeAdditions.innerHTML = this.hunksRenderer.renderPartialHTML(result.additionsAST);
				pre.appendChild(codeAdditions);
			}
		}
		this.injectUnsafeCSS();
		this.mouseEventManager.setup(pre);
		if ((this.options.overflow ?? "scroll") === "scroll") {
			this.resizeManager.setup(pre);
			this.scrollSyncManager.setup(pre, codeDeletions, codeAdditions);
		} else {
			this.resizeManager.cleanUp();
			this.scrollSyncManager.cleanUp();
		}
	}
};

//#endregion
export { FileDiff };
//# sourceMappingURL=FileDiff.js.map