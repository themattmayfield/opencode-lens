{"version":3,"file":"DiffHunksRenderer.js","names":["additionsAST: ElementContent[]","deletionsAST: ElementContent[]","unifiedAST: ElementContent[]","hunkData: HunkData[]","prevHunk: Hunk | undefined","additionContent: string[]","additionLineInfo: Record<number, LineInfo | undefined>","deletionContent: string[]","deletionLineInfo: Record<number, LineInfo | undefined>","unifiedContent: string[]","unifiedLineInfo: Record<number, LineInfo | undefined>","diffGroups: ChangeHunk[]","unresolvedSpans: UnresolvedAnnotationSpan[]","currentChangeGroup: ChangeHunk | undefined","resolvedSpan: AnnotationSpan","lineInfo: LineInfo","lastType: HunkLineType | undefined","firstChild: RootContent | Element | Root | null"],"sources":["../src/DiffHunksRenderer.ts"],"sourcesContent":["import type { Element, ElementContent, Root, RootContent } from 'hast';\nimport { toHtml } from 'hast-util-to-html';\n\nimport {\n  getSharedHighlighter,\n  hasLoadedLanguage,\n  hasLoadedThemes,\n} from './SharedHighlighter';\nimport { DEFAULT_THEMES } from './constants';\nimport type {\n  AnnotationLineMap,\n  AnnotationSpan,\n  BaseDiffOptions,\n  ChangeHunk,\n  CodeToHastOptions,\n  DecorationItem,\n  DiffLineAnnotation,\n  FileDiffMetadata,\n  Hunk,\n  HunkData,\n  HunkLineType,\n  LineInfo,\n  PJSHighlighter,\n  PJSThemeNames,\n  SharedRenderState,\n  ShikiTransformer,\n  SupportedLanguages,\n  ThemeTypes,\n} from './types';\nimport { createMirroredAnnotationSpan } from './utils/createMirroredAnnotationSpan';\nimport { createSingleAnnotationSpan } from './utils/createSingleAnnotationSpan';\nimport { createTransformerWithState } from './utils/createTransformerWithState';\nimport { formatCSSVariablePrefix } from './utils/formatCSSVariablePrefix';\nimport { getFiletypeFromFileName } from './utils/getFiletypeFromFileName';\nimport { getHighlighterOptions } from './utils/getHighlighterOptions';\nimport { getHunkSeparatorSlotName } from './utils/getHunkSeparatorSlotName';\nimport { getThemes } from './utils/getThemes';\nimport { getTotalLineCountFromHunks } from './utils/getTotalLineCountFromHunks';\nimport {\n  createHastElement,\n  createPreWrapperProperties,\n  createSeparator,\n} from './utils/hast_utils';\nimport { parseDecorations } from './utils/parseDiffDecorations';\nimport { parseLineType } from './utils/parseLineType';\nimport { pushOrMergeSpan } from './utils/pushOrMergeSpan';\n\ninterface RenderHunkProps {\n  hunk: Hunk;\n  prevHunk: Hunk | undefined;\n  isLastHunk: boolean;\n  isFirstHunk: boolean;\n  hunkIndex: number;\n  highlighter: PJSHighlighter;\n  state: SharedRenderState;\n  transformers: ShikiTransformer[];\n  additionsAST: ElementContent[];\n  deletionsAST: ElementContent[];\n  unifiedAST: ElementContent[];\n  hunkData: HunkData[];\n}\n\ninterface UnresolvedAnnotationSpan {\n  type: 'addition' | 'deletion';\n  hunkIndex: number;\n  span: AnnotationSpan;\n}\n\ninterface ComputedContent {\n  content: string[];\n  lineInfo: Record<number, LineInfo | undefined>;\n  decorations: DecorationItem[];\n}\n\ninterface ProcessLinesReturn {\n  hasLongLines: boolean;\n  additions: ComputedContent;\n  deletions: ComputedContent;\n  unified: ComputedContent;\n}\n\ntype OptionsWithDefaults = Required<\n  Omit<BaseDiffOptions, 'lang' | 'preferWasmHighlighter' | 'unsafeCSS'>\n>;\n\nexport interface HunksRenderResult {\n  additionsAST: ElementContent[] | undefined;\n  deletionsAST: ElementContent[] | undefined;\n  unifiedAST: ElementContent[] | undefined;\n  hunkData: HunkData[];\n  css: string;\n  preNode: Element;\n  totalLines: number;\n}\n\nexport class DiffHunksRenderer<LAnnotation = undefined> {\n  private highlighter: PJSHighlighter | undefined;\n  private options: BaseDiffOptions;\n  private diff: FileDiffMetadata | undefined;\n\n  private expandedHunks = new Set<number>();\n\n  private deletionAnnotations: AnnotationLineMap<LAnnotation> = {};\n  private additionAnnotations: AnnotationLineMap<LAnnotation> = {};\n\n  private queuedDiff: FileDiffMetadata | undefined;\n  private queuedRender: Promise<HunksRenderResult | undefined> | undefined;\n  private computedLang: SupportedLanguages = 'text';\n\n  constructor(options: BaseDiffOptions = { theme: DEFAULT_THEMES }) {\n    this.options = options;\n  }\n\n  cleanUp(): void {\n    this.highlighter = undefined;\n    this.diff = undefined;\n    this.queuedDiff = undefined;\n    this.queuedRender = undefined;\n  }\n\n  setOptions(options: BaseDiffOptions): void {\n    this.options = options;\n  }\n\n  expandHunk(index: number): void {\n    this.expandedHunks.add(index);\n  }\n\n  private isHunkExpanded(index: number): boolean {\n    return (\n      this.getOptionsWithDefaults().expandUnchanged ||\n      this.expandedHunks.has(index)\n    );\n  }\n\n  private mergeOptions(options: Partial<BaseDiffOptions>) {\n    this.options = { ...this.options, ...options };\n  }\n\n  setThemeType(themeType: ThemeTypes): void {\n    if (this.getOptionsWithDefaults().themeType === themeType) {\n      return;\n    }\n    this.mergeOptions({ themeType });\n  }\n\n  setLineAnnotations(lineAnnotations: DiffLineAnnotation<LAnnotation>[]): void {\n    this.additionAnnotations = {};\n    this.deletionAnnotations = {};\n    for (const annotation of lineAnnotations) {\n      const map = ((): AnnotationLineMap<LAnnotation> => {\n        switch (annotation.side) {\n          case 'deletions':\n            return this.deletionAnnotations;\n          case 'additions':\n            return this.additionAnnotations;\n        }\n      })();\n      const arr = map[annotation.lineNumber] ?? [];\n      map[annotation.lineNumber] = arr;\n      arr.push(annotation);\n    }\n  }\n\n  getOptionsWithDefaults(): OptionsWithDefaults {\n    const {\n      diffIndicators = 'bars',\n      diffStyle = 'split',\n      disableBackground = false,\n      disableLineNumbers = false,\n      expandUnchanged = false,\n      hunkSeparators = 'line-info',\n      lineDiffType = 'word-alt',\n      maxLineDiffLength = 1000,\n      maxLineLengthForHighlighting = 1000,\n      overflow = 'scroll',\n      theme = DEFAULT_THEMES,\n      themeType = 'system',\n      useCSSClasses = false,\n    } = this.options;\n    return {\n      diffIndicators,\n      diffStyle,\n      disableBackground,\n      disableLineNumbers,\n      expandUnchanged,\n      hunkSeparators,\n      lineDiffType,\n      maxLineDiffLength,\n      maxLineLengthForHighlighting,\n      overflow,\n      theme,\n      themeType,\n      useCSSClasses,\n    };\n  }\n\n  async initializeHighlighter(): Promise<PJSHighlighter> {\n    this.highlighter = await getSharedHighlighter(\n      getHighlighterOptions(this.computedLang, this.options)\n    );\n    return this.highlighter;\n  }\n\n  async render(diff: FileDiffMetadata): Promise<HunksRenderResult | undefined> {\n    this.queuedDiff = diff;\n    if (this.queuedRender != null) {\n      return this.queuedRender;\n    }\n    this.queuedRender = (async () => {\n      this.computedLang =\n        this.options.lang ?? getFiletypeFromFileName(diff.name);\n      // If we have changed theme or language on our diff instance, we need to\n      // double check the highlighter has loaded the appropriate languages and\n      // themes\n      if (\n        !hasLoadedLanguage(this.computedLang) ||\n        !hasLoadedThemes(getThemes(this.options.theme))\n      ) {\n        this.highlighter = undefined;\n      }\n\n      this.highlighter ??= await this.initializeHighlighter();\n      if (this.queuedDiff == null) {\n        // If we get in here, it's likely we called cleanup and therefore we\n        // should just return early with empty result\n        return undefined;\n      }\n      return this.renderDiff(this.queuedDiff, this.highlighter);\n    })();\n    const result = await this.queuedRender;\n    this.queuedDiff = undefined;\n    this.queuedRender = undefined;\n    return result;\n  }\n\n  private renderDiff(\n    fileDiff: FileDiffMetadata,\n    highlighter: PJSHighlighter\n  ): HunksRenderResult {\n    const {\n      disableLineNumbers,\n      diffStyle,\n      overflow,\n      themeType,\n      disableBackground,\n      diffIndicators,\n      expandUnchanged,\n      useCSSClasses,\n      theme,\n    } = this.getOptionsWithDefaults();\n\n    this.diff = fileDiff;\n    const additionsAST: ElementContent[] = [];\n    const deletionsAST: ElementContent[] = [];\n    const unifiedAST: ElementContent[] = [];\n    const { state, transformers, toClass } = createTransformerWithState({\n      disableLineNumbers: disableLineNumbers,\n      useCSSClasses,\n    });\n    let hunkIndex = 0;\n    const hunkData: HunkData[] = [];\n\n    let prevHunk: Hunk | undefined;\n    const hunks = (() => {\n      if (fileDiff.hunks.length > 0) {\n        return fileDiff.hunks;\n      }\n      if (\n        expandUnchanged &&\n        this.diff?.newLines != null &&\n        this.diff.newLines.length > 0\n      ) {\n        const lineCount = this.diff.newLines.length + 1;\n        return [\n          {\n            additionCount: 0,\n            additionStart: lineCount,\n            deletedCount: 0,\n            deletedStart: lineCount,\n            hunkContent: [],\n            hunkContext: undefined,\n            hunkSpecs: undefined,\n          },\n        ];\n      }\n      return [];\n    })();\n    for (const hunk of hunks) {\n      this.renderHunks({\n        hunk,\n        prevHunk,\n        hunkIndex,\n        highlighter,\n        state,\n        transformers,\n        isFirstHunk: hunkIndex === 0,\n        isLastHunk: hunkIndex === fileDiff.hunks.length - 1,\n        additionsAST,\n        deletionsAST,\n        unifiedAST,\n        hunkData,\n      });\n      hunkIndex++;\n      prevHunk = hunk;\n    }\n\n    const totalLines = Math.max(\n      getTotalLineCountFromHunks(fileDiff.hunks),\n      fileDiff.newLines?.length ?? 0,\n      fileDiff.oldLines?.length ?? 0\n    );\n\n    return {\n      additionsAST: additionsAST.length > 0 ? additionsAST : undefined,\n      deletionsAST: deletionsAST.length > 0 ? deletionsAST : undefined,\n      unifiedAST: unifiedAST.length > 0 ? unifiedAST : undefined,\n      hunkData,\n      css: toClass.getCSS(),\n      preNode: createHastElement({\n        tagName: 'pre',\n        properties: createPreWrapperProperties({\n          diffIndicators,\n          disableBackground,\n          highlighter,\n          overflow,\n          split:\n            diffStyle === 'unified'\n              ? false\n              : additionsAST.length > 0 && additionsAST.length > 0,\n          theme,\n          themeType,\n          totalLines,\n        }),\n      }),\n      totalLines,\n    };\n  }\n\n  renderFullAST(\n    result: HunksRenderResult,\n    children: ElementContent[] = []\n  ): Element {\n    if (result.unifiedAST != null) {\n      children.push(\n        createHastElement({\n          tagName: 'code',\n          children: result.unifiedAST,\n          properties: {\n            'data-code': '',\n            'data-unified': '',\n          },\n        })\n      );\n    }\n    if (result.deletionsAST != null) {\n      children.push(\n        createHastElement({\n          tagName: 'code',\n          children: result.deletionsAST,\n          properties: {\n            'data-code': '',\n            'data-deletions': '',\n          },\n        })\n      );\n    }\n    if (result.additionsAST != null) {\n      children.push(\n        createHastElement({\n          tagName: 'code',\n          children: result.additionsAST,\n          properties: {\n            'data-code': '',\n            'data-additions': '',\n          },\n        })\n      );\n    }\n    return { ...result.preNode, children };\n  }\n\n  renderFullHTML(\n    result: HunksRenderResult,\n    tempChildren: ElementContent[] = []\n  ): string {\n    return toHtml(this.renderFullAST(result, tempChildren));\n  }\n\n  renderPartialHTML(\n    children: ElementContent[],\n    columnType?: 'unified' | 'deletions' | 'additions'\n  ): string {\n    if (columnType == null) {\n      return toHtml(children);\n    }\n    return toHtml(\n      createHastElement({\n        tagName: 'code',\n        children,\n        properties: {\n          'data-code': '',\n          [`data-${columnType}`]: '',\n        },\n      })\n    );\n  }\n\n  private createHastOptions(\n    transformers: ShikiTransformer[],\n    decorations?: DecorationItem[],\n    forceTextLang: boolean = false\n  ): CodeToHastOptions<PJSThemeNames> {\n    const { theme } = this.getOptionsWithDefaults();\n    if (typeof theme === 'string') {\n      return {\n        theme,\n        cssVariablePrefix: formatCSSVariablePrefix(),\n        lang: forceTextLang ? 'text' : this.computedLang,\n        defaultColor: false,\n        transformers,\n        decorations,\n      };\n    }\n    return {\n      themes: theme,\n      cssVariablePrefix: formatCSSVariablePrefix(),\n      lang: forceTextLang ? 'text' : this.computedLang,\n      defaultColor: false,\n      transformers,\n      decorations,\n    };\n  }\n\n  private renderHunks({\n    hunk,\n    hunkIndex,\n    highlighter,\n    state,\n    transformers,\n    prevHunk,\n    isFirstHunk,\n    isLastHunk,\n    additionsAST,\n    deletionsAST,\n    unifiedAST,\n    hunkData,\n  }: RenderHunkProps) {\n    if (hunk.hunkContent == null) {\n      return;\n    }\n\n    const { hunkSeparators } = this.getOptionsWithDefaults();\n    const { additions, deletions, unified, hasLongLines } = this.processLines(\n      hunk,\n      hunkIndex,\n      prevHunk,\n      isLastHunk\n    );\n    const expandable = this.diff?.newLines != null;\n\n    const generateLinesAST = (\n      type: 'additions' | 'deletions' | 'unified',\n      computed: ComputedContent,\n      linesAST: ElementContent[]\n    ) => {\n      // Remove trailing blank line\n      const content = computed.content.join('').replace(/\\n$/, '');\n      state.lineInfo = computed.lineInfo;\n      const nodes = highlighter.codeToHast(\n        content,\n        this.createHastOptions(transformers, computed.decorations, hasLongLines)\n      );\n      if (!this.isHunkExpanded(hunkIndex)) {\n        if (hunkSeparators === 'line-info' || hunkSeparators === 'custom') {\n          const lines = (() => {\n            const hunkStart = hunk.additionStart;\n            if (prevHunk == null) {\n              return hunkStart - 1;\n            }\n            return (\n              hunkStart - (prevHunk.additionStart + prevHunk.additionCount)\n            );\n          })();\n          if (lines > 0) {\n            const slotName = getHunkSeparatorSlotName(type, hunkIndex);\n            linesAST.push(\n              createSeparator({\n                type: hunkSeparators,\n                content: getModifiedLinesString(lines),\n                expandIndex: expandable ? hunkIndex : undefined,\n                slotName,\n                isFirstHunk,\n                isLastHunk: false,\n              })\n            );\n            hunkData.push({ slotName, lines, type, expandable });\n          }\n        } else if (hunkSeparators === 'metadata' && hunk.hunkSpecs != null) {\n          linesAST.push(\n            createSeparator({\n              type: 'metadata',\n              content: hunk.hunkSpecs,\n              isFirstHunk,\n              isLastHunk: false,\n            })\n          );\n        } else if (hunkSeparators === 'simple' && hunkIndex > 0) {\n          linesAST.push(\n            createSeparator({ type: 'simple', isFirstHunk, isLastHunk: false })\n          );\n        }\n      }\n      for (const line of getLineNodes(nodes)) {\n        linesAST.push(line);\n      }\n      if (\n        isLastHunk &&\n        !this.isHunkExpanded(hunkIndex + 1) &&\n        this.diff?.newLines != null &&\n        (hunkSeparators === 'line-info' || hunkSeparators === 'custom')\n      ) {\n        const lines =\n          this.diff.newLines.length -\n          (hunk.additionStart + hunk.additionCount - 1);\n        if (lines > 0) {\n          const slotName = getHunkSeparatorSlotName(type, hunkIndex + 1);\n          linesAST.push(\n            createSeparator({\n              type: hunkSeparators,\n              content: getModifiedLinesString(lines),\n              expandIndex: expandable ? hunkIndex + 1 : undefined,\n              slotName,\n              isFirstHunk: false,\n              isLastHunk,\n            })\n          );\n          hunkData.push({ slotName, lines, type, expandable });\n        }\n      }\n    };\n\n    if (unified.content.length > 0) {\n      generateLinesAST('unified', unified, unifiedAST);\n    }\n\n    if (deletions.content.length > 0) {\n      generateLinesAST('deletions', deletions, deletionsAST);\n    }\n\n    if (additions.content.length > 0) {\n      generateLinesAST('additions', additions, additionsAST);\n    }\n  }\n\n  private processLines(\n    hunk: Hunk,\n    hunkIndex: number,\n    prevHunk: Hunk | undefined,\n    isLastHunk: boolean\n  ): ProcessLinesReturn {\n    const {\n      maxLineLengthForHighlighting,\n      diffStyle,\n      expandUnchanged,\n      lineDiffType,\n      maxLineDiffLength,\n    } = this.getOptionsWithDefaults();\n    const { deletionAnnotations, additionAnnotations } = this;\n    // NOTE(amadeus): We will probably need to rectify this\n    // for full additions/deletions\n    const unified = diffStyle === 'unified';\n    let hasLongLines = false;\n\n    const additionContent: string[] = [];\n    const additionLineInfo: Record<number, LineInfo | undefined> = {};\n    let additionLineNumber = hunk.additionStart - 1;\n\n    const deletionContent: string[] = [];\n    const deletionLineInfo: Record<number, LineInfo | undefined> = {};\n    let deletionLineNumber = hunk.deletedStart - 1;\n\n    const unifiedContent: string[] = [];\n    const unifiedLineInfo: Record<number, LineInfo | undefined> = {};\n\n    const diffGroups: ChangeHunk[] = [];\n    const unresolvedSpans: UnresolvedAnnotationSpan[] = [];\n    let currentChangeGroup: ChangeHunk | undefined;\n\n    function resolveUnresolvedSpans() {\n      if (currentChangeGroup == null) {\n        if (unresolvedSpans.length > 0) {\n          console.error(\n            'DiffHunksRenderer.processLines: resolveUnresolvedSpans: In a weird state...',\n            unresolvedSpans\n          );\n        }\n        return;\n      }\n      for (const unresolvedSpan of unresolvedSpans) {\n        const deletionIndex =\n          currentChangeGroup.deletionStartIndex + unresolvedSpan.hunkIndex;\n        const additionIndex =\n          currentChangeGroup.additionStartIndex + unresolvedSpan.hunkIndex;\n        const resolvedSpan: AnnotationSpan = {\n          type: 'annotation',\n          hunkIndex,\n          lineIndex: unresolvedSpan.span.lineIndex,\n          annotations: [],\n        };\n        if (unresolvedSpan.type === 'addition') {\n          pushOrMergeSpan(\n            resolvedSpan,\n            Math.min(\n              deletionIndex,\n              currentChangeGroup.deletionStartIndex +\n                currentChangeGroup.deletionLines.length\n            ),\n            deletionLineInfo\n          );\n        } else {\n          pushOrMergeSpan(\n            resolvedSpan,\n            Math.min(\n              additionIndex,\n              currentChangeGroup.additionStartIndex +\n                currentChangeGroup.additionLines.length\n            ),\n            additionLineInfo\n          );\n        }\n      }\n      unresolvedSpans.length = 0;\n    }\n\n    function addToChangeGroup(\n      type: 'addition' | 'deletion',\n      line: string,\n      span?: AnnotationSpan\n    ): ChangeHunk {\n      if (currentChangeGroup == null) {\n        currentChangeGroup = {\n          // In unified layout, deletionLineIndex and additionLineIndex won't\n          // be usable, and we will have to compute start indexes as we are\n          // iterating\n          deletionStartIndex: unified ? -1 : deletionContent.length,\n          additionStartIndex: unified ? -1 : additionContent.length,\n          deletionLines: [],\n          additionLines: [],\n          diffGroupStartIndex: lineIndex,\n        };\n        diffGroups.push(currentChangeGroup);\n      }\n\n      if (unified) {\n        if (\n          type === 'deletion' &&\n          currentChangeGroup.deletionStartIndex === -1\n        ) {\n          currentChangeGroup.deletionStartIndex = unifiedContent.length;\n        }\n        if (\n          type === 'addition' &&\n          currentChangeGroup.additionStartIndex === -1\n        ) {\n          currentChangeGroup.additionStartIndex = unifiedContent.length;\n        }\n      }\n      if (type === 'addition') {\n        currentChangeGroup.additionLines.push(line);\n      } else {\n        currentChangeGroup.deletionLines.push(line);\n      }\n\n      if (span != null && !unified) {\n        unresolvedSpans.push({\n          type,\n          hunkIndex:\n            type === 'deletion'\n              ? currentChangeGroup.deletionLines.length\n              : currentChangeGroup.additionLines.length,\n          span,\n        });\n      }\n      return currentChangeGroup;\n    }\n\n    function createGapSpanIfNecessary() {\n      if (\n        !unified &&\n        lastType !== 'context' &&\n        lastType != null &&\n        currentChangeGroup != null\n      ) {\n        const additionGroupSize = currentChangeGroup.additionLines.length;\n        const deletionGroupSize = currentChangeGroup.deletionLines.length;\n        if (additionGroupSize > deletionGroupSize) {\n          pushOrMergeSpan(\n            { type: 'gap', rows: additionGroupSize - deletionGroupSize },\n            deletionContent.length,\n            deletionLineInfo\n          );\n        } else if (deletionGroupSize > additionGroupSize) {\n          pushOrMergeSpan(\n            { type: 'gap', rows: deletionGroupSize - additionGroupSize },\n            additionContent.length,\n            additionLineInfo\n          );\n        }\n      }\n      resolveUnresolvedSpans();\n    }\n\n    const processRawLine = (\n      line: string,\n      type: HunkLineType,\n      isExpandedContext: boolean = false\n    ) => {\n      lineIndex++;\n      if (type === 'context') {\n        createGapSpanIfNecessary();\n      }\n      if (type === 'context') {\n        if (currentChangeGroup != null) {\n          lineIndex =\n            currentChangeGroup.diffGroupStartIndex +\n            Math.max(\n              currentChangeGroup.additionLines.length,\n              currentChangeGroup.deletionLines.length\n            );\n        }\n        currentChangeGroup = undefined;\n        if (unified) {\n          unifiedContent.push(line);\n          unifiedLineInfo[unifiedContent.length] = {\n            type: isExpandedContext ? 'context-expanded' : 'context',\n            lineNumber: additionLineNumber + 1,\n            lineIndex,\n          };\n          const span = createMirroredAnnotationSpan({\n            deletionLineNumber: deletionLineNumber + 1,\n            additionLineNumber: additionLineNumber + 1,\n            hunkIndex,\n            lineIndex: unifiedContent.length,\n            deletionAnnotations,\n            additionAnnotations,\n            unified: true,\n          });\n          pushOrMergeSpan(span, unifiedContent.length, unifiedLineInfo);\n        } else {\n          deletionContent.push(line);\n          additionContent.push(line);\n          deletionLineInfo[deletionContent.length] = {\n            type: isExpandedContext ? 'context-expanded' : 'context',\n            lineNumber: deletionLineNumber + 1,\n            lineIndex,\n          };\n          additionLineInfo[additionContent.length] = {\n            type: isExpandedContext ? 'context-expanded' : 'context',\n            lineNumber: additionLineNumber + 1,\n            lineIndex,\n          };\n          const [deletionSpan, additionSpan] = createMirroredAnnotationSpan({\n            deletionLineNumber: deletionLineNumber + 1,\n            additionLineNumber: additionLineNumber + 1,\n            hunkIndex,\n            lineIndex,\n            deletionAnnotations,\n            additionAnnotations,\n            unified: false,\n          });\n          pushOrMergeSpan(\n            deletionSpan,\n            deletionContent.length,\n            deletionLineInfo\n          );\n          pushOrMergeSpan(\n            additionSpan,\n            additionContent.length,\n            additionLineInfo\n          );\n        }\n        additionLineNumber++;\n        deletionLineNumber++;\n      }\n      // TODO(amadeus): Metadata shouldn't render it's own line, as that could\n      // theoretically mess with code output... we should stuff it into the\n      // appropriate line info\n      else if (type === 'metadata') {\n        const lineInfo: LineInfo = {\n          type:\n            lastType === 'addition'\n              ? 'change-addition'\n              : lastType === 'deletion'\n                ? 'change-deletion'\n                : 'context',\n          // NOTE(amadeus): Metadata lines do not have line numbers associated\n          // with them\n          lineNumber: -1,\n          lineIndex: -1,\n          metadataContent: line.trim(),\n        };\n        // Push a filler blank line so we have something to render\n        if (unified) {\n          unifiedContent.push('\\n');\n          unifiedLineInfo[unifiedContent.length] = lineInfo;\n        } else {\n          if (lastType === 'context' || lastType === 'deletion') {\n            deletionContent.push('\\n');\n            deletionLineInfo[deletionContent.length] = lineInfo;\n            addToChangeGroup('deletion', '\\n');\n          }\n          if (lastType === 'context' || lastType === 'addition') {\n            additionContent.push('\\n');\n            additionLineInfo[additionContent.length] = lineInfo;\n            addToChangeGroup('addition', '\\n');\n          }\n        }\n      } else if (type === 'deletion') {\n        const { content, lineInfo } = (() =>\n          unified\n            ? { content: unifiedContent, lineInfo: unifiedLineInfo }\n            : { content: deletionContent, lineInfo: deletionLineInfo })();\n        const span = createSingleAnnotationSpan({\n          rowNumber: deletionLineNumber + 1,\n          hunkIndex,\n          lineIndex,\n          annotationMap: this.deletionAnnotations,\n        });\n        addToChangeGroup('deletion', line, span);\n        content.push(line);\n        lineInfo[content.length] = {\n          type: 'change-deletion',\n          lineNumber: deletionLineNumber + 1,\n          lineIndex,\n        };\n        pushOrMergeSpan(span, content.length, lineInfo);\n        deletionLineNumber++;\n      } else if (type === 'addition') {\n        // Reset diffLineIndex back to start if we are jumping columns\n        if (lastType === 'deletion' && !unified) {\n          lineIndex = currentChangeGroup?.diffGroupStartIndex ?? lineIndex;\n        }\n        const { content, lineInfo } = (() =>\n          unified\n            ? { content: unifiedContent, lineInfo: unifiedLineInfo }\n            : { content: additionContent, lineInfo: additionLineInfo })();\n        const span = createSingleAnnotationSpan({\n          rowNumber: additionLineNumber + 1,\n          hunkIndex,\n          lineIndex,\n          annotationMap: this.additionAnnotations,\n        });\n        addToChangeGroup('addition', line, span);\n        content.push(line);\n        lineInfo[content.length] = {\n          type: 'change-addition',\n          lineNumber: additionLineNumber + 1,\n          lineIndex,\n        };\n        pushOrMergeSpan(span, content.length, lineInfo);\n        additionLineNumber++;\n      }\n\n      lastType = type;\n    };\n\n    let lineIndex = -1;\n    let lastType: HunkLineType | undefined;\n\n    // Proses hunk expanded content if expanded\n    if (this.isHunkExpanded(hunkIndex) && this.diff?.newLines != null) {\n      const { expandAddedStart, expandDeletedStart } = (() => {\n        if (prevHunk != null) {\n          return {\n            expandAddedStart:\n              prevHunk.additionStart + prevHunk.additionCount - 1,\n            expandDeletedStart:\n              prevHunk.deletedStart + prevHunk.deletedCount - 1,\n          };\n        }\n        return { expandAddedStart: 0, expandDeletedStart: 0 };\n      })();\n      if (additionLineNumber - expandAddedStart > 0) {\n        additionLineNumber = expandAddedStart;\n        deletionLineNumber = expandDeletedStart;\n        for (let i = additionLineNumber; i < hunk.additionStart - 1; i++) {\n          const line = this.diff.newLines[i];\n          hasLongLines =\n            hasLongLines || line.length > maxLineLengthForHighlighting;\n          processRawLine(line, 'context', expandUnchanged ? false : true);\n        }\n      }\n    }\n\n    // Process diff content\n    for (const rawLine of hunk.hunkContent ?? []) {\n      const { line, type, longLine } = parseLineType(\n        rawLine,\n        maxLineLengthForHighlighting\n      );\n      hasLongLines = hasLongLines || longLine;\n      processRawLine(line, type);\n    }\n    createGapSpanIfNecessary();\n\n    // Process final expansion hunk if necessary\n    if (\n      isLastHunk &&\n      this.isHunkExpanded(hunkIndex + 1) &&\n      this.diff?.newLines != null\n    ) {\n      for (let i = additionLineNumber; i < this.diff.newLines.length; i++) {\n        const line = this.diff.newLines[i];\n        hasLongLines =\n          hasLongLines || line.length > maxLineLengthForHighlighting;\n        processRawLine(line, 'context', expandUnchanged ? false : true);\n      }\n    }\n    resolveUnresolvedSpans();\n\n    const { unifiedDecorations, deletionDecorations, additionDecorations } =\n      parseDecorations({\n        diffGroups,\n        lineDiffType,\n        diffStyle,\n        maxLineDiffLength,\n      });\n    return {\n      hasLongLines,\n      additions: {\n        content: additionContent,\n        lineInfo: additionLineInfo,\n        decorations: additionDecorations,\n      },\n      deletions: {\n        content: deletionContent,\n        lineInfo: deletionLineInfo,\n        decorations: deletionDecorations,\n      },\n      unified: {\n        content: unifiedContent,\n        lineInfo: unifiedLineInfo,\n        decorations: unifiedDecorations,\n      },\n    };\n  }\n}\n\nfunction getLineNodes(nodes: Root): ElementContent[] {\n  let firstChild: RootContent | Element | Root | null = nodes.children[0];\n  while (firstChild != null) {\n    if (firstChild.type === 'element' && firstChild.tagName === 'code') {\n      return firstChild.children;\n    }\n    if ('children' in firstChild) {\n      firstChild = firstChild.children[0];\n    } else {\n      firstChild = null;\n    }\n  }\n  console.error(nodes);\n  throw new Error(\n    'DiffHunksRenderer.getNodesToRender: Unable to find children'\n  );\n}\n\nfunction getModifiedLinesString(lines: number) {\n  return `${lines} unmodified line${lines > 1 ? 's' : ''}`;\n}\n"],"mappings":"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"}