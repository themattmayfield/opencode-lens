import { getSharedHighlighter, hasLoadedLanguage, hasLoadedThemes } from "./SharedHighlighter.js";
import { DEFAULT_THEMES, SPLIT_WITH_NEWLINES } from "./constants.js";
import { getLineAnnotationName } from "./utils/getLineAnnotationName.js";
import { formatCSSVariablePrefix } from "./utils/formatCSSVariablePrefix.js";
import { createHastElement, createPreWrapperProperties } from "./utils/hast_utils.js";
import { createTransformerWithState } from "./utils/createTransformerWithState.js";
import { getFiletypeFromFileName } from "./utils/getFiletypeFromFileName.js";
import { getThemes } from "./utils/getThemes.js";
import { getHighlighterOptions } from "./utils/getHighlighterOptions.js";
import { toHtml } from "hast-util-to-html";

//#region src/FileRenderer.ts
var FileRenderer = class {
	highlighter;
	fileContent;
	constructor(options = { theme: DEFAULT_THEMES }) {
		this.options = options;
	}
	setOptions(options) {
		this.options = options;
	}
	mergeOptions(options) {
		this.options = {
			...this.options,
			...options
		};
	}
	setThemeType(themeType) {
		if ((this.options.themeType ?? "system") === themeType) return;
		this.mergeOptions({ themeType });
	}
	lineAnnotations = {};
	setLineAnnotations(lineAnnotations) {
		this.lineAnnotations = {};
		for (const annotation of lineAnnotations) {
			const arr = this.lineAnnotations[annotation.lineNumber] ?? [];
			this.lineAnnotations[annotation.lineNumber] = arr;
			arr.push(annotation);
		}
	}
	cleanUp() {
		this.highlighter = void 0;
		this.fileContent = void 0;
		this.queuedFile = void 0;
	}
	computedLang = "text";
	queuedFile;
	queuedRender;
	async render(file, useCSSClasses = false) {
		this.queuedFile = file;
		if (this.queuedRender != null) return this.queuedRender;
		this.queuedRender = (async () => {
			this.computedLang = this.options.lang ?? getFiletypeFromFileName(file.name);
			if (!hasLoadedLanguage(this.computedLang) || !hasLoadedThemes(getThemes(this.options.theme))) this.highlighter = void 0;
			this.highlighter ??= await this.initializeHighlighter();
			if (this.queuedFile == null) return;
			return this.renderFile(this.queuedFile, this.highlighter, useCSSClasses);
		})();
		const result = await this.queuedRender;
		this.queuedFile = void 0;
		this.queuedRender = void 0;
		return result;
	}
	renderFile(file, highlighter, useCSSClasses) {
		const { theme, themeType, disableLineNumbers = false } = this.options;
		const { state, transformers, toClass } = createTransformerWithState({
			disableLineNumbers,
			useCSSClasses
		});
		const { lineInfoMap, hasLongLines } = this.computeLineInfo(file.contents);
		state.lineInfo = lineInfoMap;
		const codeAST = this.getLineNodes(highlighter.codeToHast(file.contents.replace(/\n$/, ""), this.createHastOptions(transformers, void 0, hasLongLines)));
		return {
			codeAST,
			preNode: createHastElement({
				tagName: "pre",
				properties: createPreWrapperProperties({
					diffIndicators: "none",
					disableBackground: true,
					highlighter,
					overflow: this.options.overflow,
					split: false,
					theme,
					themeType,
					totalLines: codeAST.length
				})
			}),
			totalLines: codeAST.length,
			css: toClass.getCSS()
		};
	}
	renderFullHTML(result) {
		return toHtml(this.renderFullAST(result));
	}
	renderFullAST(result, children = []) {
		children.push(createHastElement({
			tagName: "code",
			children: result.codeAST,
			properties: { "data-code": "" }
		}));
		return {
			...result.preNode,
			children
		};
	}
	renderPartialHTML(children, includeCodeNode = false) {
		if (!includeCodeNode) return toHtml(children);
		return toHtml(createHastElement({
			tagName: "code",
			children,
			properties: { "data-code": "" }
		}));
	}
	getLineNodes(nodes) {
		let firstChild = nodes.children[0];
		while (firstChild != null) {
			if (firstChild.type === "element" && firstChild.tagName === "code") return firstChild.children;
			if ("children" in firstChild) firstChild = firstChild.children[0];
			else firstChild = null;
		}
		console.error(nodes);
		throw new Error("DiffHunksRenderer.getNodesToRender: Unable to find children");
	}
	computeLineInfo(contents) {
		const { startingLineNumber = 1, maxLineLengthForHighlighting = 1e3 } = this.options;
		const lineInfoMap = {};
		let hasLongLines = false;
		let lineIndex = 0;
		for (const line of contents.split(SPLIT_WITH_NEWLINES)) {
			hasLongLines = hasLongLines || line.length > maxLineLengthForHighlighting;
			const lineInfo = {
				type: "context",
				lineIndex,
				lineNumber: startingLineNumber + lineIndex
			};
			const annotations = this.lineAnnotations[startingLineNumber + lineIndex];
			if (annotations != null) lineInfo.spans = [{
				type: "annotation",
				hunkIndex: 0,
				lineIndex,
				annotations: annotations.map((annotation) => getLineAnnotationName(annotation))
			}];
			lineInfoMap[lineIndex + 1] = lineInfo;
			lineIndex++;
		}
		return {
			lineInfoMap,
			hasLongLines
		};
	}
	createHastOptions(transformers, decorations, forceTextLang = false) {
		const { theme = DEFAULT_THEMES } = this.options;
		if (typeof theme === "string") return {
			theme,
			cssVariablePrefix: formatCSSVariablePrefix(),
			lang: forceTextLang ? "text" : this.computedLang,
			defaultColor: false,
			transformers,
			decorations
		};
		return {
			themes: theme,
			cssVariablePrefix: formatCSSVariablePrefix(),
			lang: forceTextLang ? "text" : this.computedLang,
			defaultColor: false,
			transformers,
			decorations
		};
	}
	async initializeHighlighter() {
		this.highlighter = await getSharedHighlighter(getHighlighterOptions(this.computedLang, this.options));
		return this.highlighter;
	}
};

//#endregion
export { FileRenderer };
//# sourceMappingURL=FileRenderer.js.map