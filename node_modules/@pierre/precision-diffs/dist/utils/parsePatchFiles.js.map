{"version":3,"file":"parsePatchFiles.js","names":["patchMetadata: string | undefined","files: FileDiffMetadata[]","currentFile: FileDiffMetadata | undefined","hunkData: Hunk","patches: ParsedPatch[]"],"sources":["../../src/utils/parsePatchFiles.ts"],"sourcesContent":["import {\n  ALTERNATE_FILE_NAMES_GIT,\n  COMMIT_METADATA_SPLIT,\n  FILENAME_HEADER_REGEX,\n  FILENAME_HEADER_REGEX_GIT,\n  FILE_CONTEXT_BLOB,\n  FILE_MODE_FROM_INDEX,\n  GIT_DIFF_FILE_BREAK_REGEX,\n  HUNK_HEADER,\n  SPLIT_WITH_NEWLINES,\n  UNIFIED_DIFF_FILE_BREAK_REGEX,\n} from '../constants';\nimport type { FileDiffMetadata, Hunk, ParsedPatch } from '../types';\n\nfunction processPatch(data: string): ParsedPatch {\n  const isGitDiff = GIT_DIFF_FILE_BREAK_REGEX.test(data);\n  const rawFiles = data.split(\n    isGitDiff ? GIT_DIFF_FILE_BREAK_REGEX : UNIFIED_DIFF_FILE_BREAK_REGEX\n  );\n  let patchMetadata: string | undefined;\n  const files: FileDiffMetadata[] = [];\n  let currentFile: FileDiffMetadata | undefined;\n  for (const file of rawFiles) {\n    if (isGitDiff && !GIT_DIFF_FILE_BREAK_REGEX.test(file)) {\n      if (patchMetadata == null) {\n        patchMetadata = file;\n      } else {\n        console.error('parsePatchContent: unknown file blob:', file);\n      }\n      // If we get in here, it's most likely the introductory metadata from the\n      // patch, or something is fucked with the diff format\n      continue;\n    } else if (!isGitDiff && !UNIFIED_DIFF_FILE_BREAK_REGEX.test(file)) {\n      if (patchMetadata == null) {\n        patchMetadata = file;\n      } else {\n        console.error('parsePatchContent: unknown file blob:', file);\n      }\n      continue;\n    }\n    const hunks = file.split(FILE_CONTEXT_BLOB);\n    currentFile = undefined;\n    for (const hunk of hunks) {\n      const lines = hunk.split(SPLIT_WITH_NEWLINES);\n      const firstLine = lines.shift();\n      if (firstLine == null) {\n        console.error('parsePatchContent: invalid hunk', hunk);\n        continue;\n      }\n      const match = firstLine.match(HUNK_HEADER);\n      if (match == null || currentFile == null) {\n        if (currentFile != null) {\n          console.error('parsePatchContent: Invalid hunk', hunk);\n          continue;\n        }\n        currentFile = {\n          name: '',\n          prevName: undefined,\n          type: 'change',\n          hunks: [],\n          lines: 0,\n        };\n        // Push that first line back into the group of lines so we can properly\n        // parse it out\n        lines.unshift(firstLine);\n        for (const line of lines) {\n          const filenameMatch = line.match(\n            isGitDiff ? FILENAME_HEADER_REGEX_GIT : FILENAME_HEADER_REGEX\n          );\n          if (line.startsWith('diff --git')) {\n            const [, , prevName, , name] =\n              line.trim().match(ALTERNATE_FILE_NAMES_GIT) ?? [];\n            currentFile.name = name;\n            if (prevName !== name) {\n              currentFile.prevName = prevName;\n            }\n          } else if (filenameMatch != null) {\n            const [, type, fileName] = filenameMatch;\n            if (type === '---' && fileName !== '/dev/null') {\n              currentFile.prevName = fileName;\n              currentFile.name = fileName;\n            } else if (type === '+++' && fileName !== '/dev/null') {\n              currentFile.name = fileName;\n            }\n          }\n          // Git diffs have a bunch of additional metadata we can pull from\n          else if (isGitDiff) {\n            if (line.startsWith('new mode ')) {\n              currentFile.mode = line.replace('new mode', '').trim();\n            }\n            if (line.startsWith('old mode ')) {\n              currentFile.oldMode = line.replace('old mode', '').trim();\n            }\n            if (line.startsWith('new file mode')) {\n              currentFile.type = 'new';\n              currentFile.mode = line.replace('new file mode', '').trim();\n            }\n            if (line.startsWith('deleted file mode')) {\n              currentFile.type = 'deleted';\n              currentFile.mode = line.replace('deleted file mode', '').trim();\n            }\n            if (line.startsWith('similarity index')) {\n              if (line.startsWith('similarity index 100%')) {\n                currentFile.type = 'rename-pure';\n              } else {\n                currentFile.type = 'rename-changed';\n              }\n            }\n            if (line.startsWith('index ')) {\n              const [, mode] = line.trim().match(FILE_MODE_FROM_INDEX) ?? [];\n              if (mode != null) {\n                currentFile.mode = mode;\n              }\n            }\n            // We have to handle these for pure renames because there won't be\n            // --- and +++ lines\n            if (line.startsWith('rename from ')) {\n              currentFile.prevName = line.replace('rename from ', '');\n            }\n            if (line.startsWith('rename to ')) {\n              currentFile.name = line.replace('rename to ', '');\n            }\n          }\n        }\n        continue;\n      }\n      const hunkData: Hunk = {\n        additionCount: parseInt(match[4] ?? '1'),\n        additionStart: parseInt(match[3]),\n        deletedCount: parseInt(match[2] ?? '1'),\n        deletedStart: parseInt(match[1]),\n        hunkContent: lines.length > 0 ? lines : undefined,\n        hunkContext: match[5],\n        hunkSpecs: firstLine,\n      };\n      if (\n        isNaN(hunkData.additionCount) ||\n        isNaN(hunkData.deletedCount) ||\n        isNaN(hunkData.additionStart) ||\n        isNaN(hunkData.deletedStart)\n      ) {\n        console.error('parsePatchContent: invalid hunk metadata', hunkData);\n        continue;\n      }\n      // If the final line is an empty newline, lets yeet it, that's usually a\n      // separator between multiple patches in a single file.  Unclear if\n      // safe... but probably\n      if (lines[lines.length - 1] === '\\n') {\n        lines.pop();\n      }\n      currentFile.hunks.push(hunkData);\n      currentFile.lines += hunkData.hunkContent?.length ?? 0;\n    }\n    if (currentFile != null) {\n      if (\n        !isGitDiff &&\n        currentFile.prevName != null &&\n        currentFile.name !== currentFile.prevName\n      ) {\n        if (currentFile.hunks.length > 0) {\n          currentFile.type = 'rename-changed';\n        } else {\n          currentFile.type = 'rename-pure';\n        }\n      }\n      if (\n        currentFile.type !== 'rename-pure' &&\n        currentFile.type !== 'rename-changed'\n      ) {\n        currentFile.prevName = undefined;\n      }\n      files.push(currentFile);\n    }\n  }\n  return { patchMetadata, files };\n}\n\nexport function parsePatchFiles(data: string): ParsedPatch[] {\n  // NOTE(amadeus): This function is pretty forgiving in that it can accept a\n  // patch file that includes commit metdata, multiple commits, or not\n  const patches: ParsedPatch[] = [];\n  for (const patch of data.split(COMMIT_METADATA_SPLIT)) {\n    try {\n      patches.push(processPatch(patch));\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  return patches;\n}\n"],"mappings":"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"}