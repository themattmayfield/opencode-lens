{"version":3,"file":"createTransformerWithState.js","names":["state: SharedRenderState","transformers: ShikiTransformer[]","children: ElementContent[]","tokenStyleNormalizer: ShikiTransformer","style: Record<string, string>"],"sources":["../../src/utils/createTransformerWithState.ts"],"sourcesContent":["import {\n  type ShikiTransformerStyleToClass,\n  transformerStyleToClass,\n} from '@shikijs/transformers';\nimport type { ElementContent } from 'hast';\n\nimport type { SharedRenderState, ShikiTransformer } from '../types';\nimport {\n  convertLine,\n  createAnnotationElement,\n  createEmptyRowBuffer,\n  findCodeElement,\n} from './hast_utils';\n\ninterface CreateTransformerWithStateOptions {\n  disableLineNumbers: boolean;\n  useCSSClasses: boolean;\n}\n\ninterface CreateTransformerWithStateReturn {\n  state: SharedRenderState;\n  transformers: ShikiTransformer[];\n  toClass: ShikiTransformerStyleToClass;\n}\n\nexport function createTransformerWithState({\n  disableLineNumbers,\n  useCSSClasses,\n}: CreateTransformerWithStateOptions): CreateTransformerWithStateReturn {\n  const state: SharedRenderState = {\n    lineInfo: {},\n    decorations: [],\n    disableLineNumbers,\n  };\n  const transformers: ShikiTransformer[] = [\n    {\n      line(node) {\n        // Remove the default class\n        delete node.properties.class;\n        return node;\n      },\n      pre(pre) {\n        // NOTE(amadeus): This kinda sucks -- basically we can't apply our\n        // line node changes until AFTER decorations have been applied\n        const code = findCodeElement(pre);\n        const children: ElementContent[] = [];\n        if (code != null) {\n          let index = 1;\n          for (const node of code.children) {\n            if (node.type !== 'element') {\n              continue;\n            }\n            // Do we need to inject an empty span above the first line line?\n            if (index === 1 && state.lineInfo[0]?.spans != null) {\n              for (const span of state.lineInfo[0]?.spans ?? []) {\n                if (span.type === 'gap') {\n                  children.push(createEmptyRowBuffer(span.rows));\n                } else {\n                  children.push(createAnnotationElement(span));\n                }\n              }\n            }\n            children.push(convertLine(node, index, state));\n            const lineInfo = state.lineInfo[index];\n            if (lineInfo?.spans != null) {\n              for (const span of lineInfo.spans) {\n                if (span.type === 'gap') {\n                  children.push(createEmptyRowBuffer(span.rows));\n                } else {\n                  children.push(createAnnotationElement(span));\n                }\n              }\n            }\n            index++;\n          }\n          code.children = children;\n        }\n        return pre;\n      },\n    },\n  ];\n  if (useCSSClasses) {\n    transformers.push(tokenStyleNormalizer, toClass);\n  }\n  return { state, transformers, toClass };\n}\n\nconst toClass = transformerStyleToClass({ classPrefix: 'hl-' });\n\n// Create a transformer that converts token color/fontStyle to htmlStyle\n// This needs to run BEFORE transformerStyleToClass\nconst tokenStyleNormalizer: ShikiTransformer = {\n  name: 'token-style-normalizer',\n  tokens(lines) {\n    for (const line of lines) {\n      for (const token of line) {\n        // Skip if htmlStyle is already set\n        if (token.htmlStyle != null) continue;\n\n        const style: Record<string, string> = {};\n\n        if (token.color != null) {\n          style.color = token.color;\n        }\n        if (token.bgColor != null) {\n          style['background-color'] = token.bgColor;\n        }\n        if (token.fontStyle != null && token.fontStyle !== 0) {\n          // FontStyle is a bitmask: 1 = italic, 2 = bold, 4 = underline\n          if ((token.fontStyle & 1) !== 0) {\n            style['font-style'] = 'italic';\n          }\n          if ((token.fontStyle & 2) !== 0) {\n            style['font-weight'] = 'bold';\n          }\n          if ((token.fontStyle & 4) !== 0) {\n            style['text-decoration'] = 'underline';\n          }\n        }\n\n        // Only set htmlStyle if we have any styles\n        if (Object.keys(style).length > 0) {\n          token.htmlStyle = style;\n        }\n      }\n    }\n  },\n};\n"],"mappings":";;;;AAyBA,SAAgB,2BAA2B,EACzC,oBACA,iBACsE;CACtE,MAAMA,QAA2B;EAC/B,UAAU,EAAE;EACZ,aAAa,EAAE;EACf;EACD;CACD,MAAMC,eAAmC,CACvC;EACE,KAAK,MAAM;AAET,UAAO,KAAK,WAAW;AACvB,UAAO;;EAET,IAAI,KAAK;GAGP,MAAM,OAAO,gBAAgB,IAAI;GACjC,MAAMC,WAA6B,EAAE;AACrC,OAAI,QAAQ,MAAM;IAChB,IAAI,QAAQ;AACZ,SAAK,MAAM,QAAQ,KAAK,UAAU;AAChC,SAAI,KAAK,SAAS,UAChB;AAGF,SAAI,UAAU,KAAK,MAAM,SAAS,IAAI,SAAS,KAC7C,MAAK,MAAM,QAAQ,MAAM,SAAS,IAAI,SAAS,EAAE,CAC/C,KAAI,KAAK,SAAS,MAChB,UAAS,KAAK,qBAAqB,KAAK,KAAK,CAAC;SAE9C,UAAS,KAAK,wBAAwB,KAAK,CAAC;AAIlD,cAAS,KAAK,YAAY,MAAM,OAAO,MAAM,CAAC;KAC9C,MAAM,WAAW,MAAM,SAAS;AAChC,SAAI,UAAU,SAAS,KACrB,MAAK,MAAM,QAAQ,SAAS,MAC1B,KAAI,KAAK,SAAS,MAChB,UAAS,KAAK,qBAAqB,KAAK,KAAK,CAAC;SAE9C,UAAS,KAAK,wBAAwB,KAAK,CAAC;AAIlD;;AAEF,SAAK,WAAW;;AAElB,UAAO;;EAEV,CACF;AACD,KAAI,cACF,cAAa,KAAK,sBAAsB,QAAQ;AAElD,QAAO;EAAE;EAAO;EAAc;EAAS;;AAGzC,MAAM,UAAU,wBAAwB,EAAE,aAAa,OAAO,CAAC;AAI/D,MAAMC,uBAAyC;CAC7C,MAAM;CACN,OAAO,OAAO;AACZ,OAAK,MAAM,QAAQ,MACjB,MAAK,MAAM,SAAS,MAAM;AAExB,OAAI,MAAM,aAAa,KAAM;GAE7B,MAAMC,QAAgC,EAAE;AAExC,OAAI,MAAM,SAAS,KACjB,OAAM,QAAQ,MAAM;AAEtB,OAAI,MAAM,WAAW,KACnB,OAAM,sBAAsB,MAAM;AAEpC,OAAI,MAAM,aAAa,QAAQ,MAAM,cAAc,GAAG;AAEpD,SAAK,MAAM,YAAY,OAAO,EAC5B,OAAM,gBAAgB;AAExB,SAAK,MAAM,YAAY,OAAO,EAC5B,OAAM,iBAAiB;AAEzB,SAAK,MAAM,YAAY,OAAO,EAC5B,OAAM,qBAAqB;;AAK/B,OAAI,OAAO,KAAK,MAAM,CAAC,SAAS,EAC9B,OAAM,YAAY;;;CAK3B"}