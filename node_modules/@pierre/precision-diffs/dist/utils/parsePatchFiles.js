import { ALTERNATE_FILE_NAMES_GIT, COMMIT_METADATA_SPLIT, FILENAME_HEADER_REGEX, FILENAME_HEADER_REGEX_GIT, FILE_CONTEXT_BLOB, FILE_MODE_FROM_INDEX, GIT_DIFF_FILE_BREAK_REGEX, HUNK_HEADER, SPLIT_WITH_NEWLINES, UNIFIED_DIFF_FILE_BREAK_REGEX } from "../constants.js";

//#region src/utils/parsePatchFiles.ts
function processPatch(data) {
	const isGitDiff = GIT_DIFF_FILE_BREAK_REGEX.test(data);
	const rawFiles = data.split(isGitDiff ? GIT_DIFF_FILE_BREAK_REGEX : UNIFIED_DIFF_FILE_BREAK_REGEX);
	let patchMetadata;
	const files = [];
	let currentFile;
	for (const file of rawFiles) {
		if (isGitDiff && !GIT_DIFF_FILE_BREAK_REGEX.test(file)) {
			if (patchMetadata == null) patchMetadata = file;
			else console.error("parsePatchContent: unknown file blob:", file);
			continue;
		} else if (!isGitDiff && !UNIFIED_DIFF_FILE_BREAK_REGEX.test(file)) {
			if (patchMetadata == null) patchMetadata = file;
			else console.error("parsePatchContent: unknown file blob:", file);
			continue;
		}
		const hunks = file.split(FILE_CONTEXT_BLOB);
		currentFile = void 0;
		for (const hunk of hunks) {
			const lines = hunk.split(SPLIT_WITH_NEWLINES);
			const firstLine = lines.shift();
			if (firstLine == null) {
				console.error("parsePatchContent: invalid hunk", hunk);
				continue;
			}
			const match = firstLine.match(HUNK_HEADER);
			if (match == null || currentFile == null) {
				if (currentFile != null) {
					console.error("parsePatchContent: Invalid hunk", hunk);
					continue;
				}
				currentFile = {
					name: "",
					prevName: void 0,
					type: "change",
					hunks: [],
					lines: 0
				};
				lines.unshift(firstLine);
				for (const line of lines) {
					const filenameMatch = line.match(isGitDiff ? FILENAME_HEADER_REGEX_GIT : FILENAME_HEADER_REGEX);
					if (line.startsWith("diff --git")) {
						const [, , prevName, , name] = line.trim().match(ALTERNATE_FILE_NAMES_GIT) ?? [];
						currentFile.name = name;
						if (prevName !== name) currentFile.prevName = prevName;
					} else if (filenameMatch != null) {
						const [, type, fileName] = filenameMatch;
						if (type === "---" && fileName !== "/dev/null") {
							currentFile.prevName = fileName;
							currentFile.name = fileName;
						} else if (type === "+++" && fileName !== "/dev/null") currentFile.name = fileName;
					} else if (isGitDiff) {
						if (line.startsWith("new mode ")) currentFile.mode = line.replace("new mode", "").trim();
						if (line.startsWith("old mode ")) currentFile.oldMode = line.replace("old mode", "").trim();
						if (line.startsWith("new file mode")) {
							currentFile.type = "new";
							currentFile.mode = line.replace("new file mode", "").trim();
						}
						if (line.startsWith("deleted file mode")) {
							currentFile.type = "deleted";
							currentFile.mode = line.replace("deleted file mode", "").trim();
						}
						if (line.startsWith("similarity index")) if (line.startsWith("similarity index 100%")) currentFile.type = "rename-pure";
						else currentFile.type = "rename-changed";
						if (line.startsWith("index ")) {
							const [, mode] = line.trim().match(FILE_MODE_FROM_INDEX) ?? [];
							if (mode != null) currentFile.mode = mode;
						}
						if (line.startsWith("rename from ")) currentFile.prevName = line.replace("rename from ", "");
						if (line.startsWith("rename to ")) currentFile.name = line.replace("rename to ", "");
					}
				}
				continue;
			}
			const hunkData = {
				additionCount: parseInt(match[4] ?? "1"),
				additionStart: parseInt(match[3]),
				deletedCount: parseInt(match[2] ?? "1"),
				deletedStart: parseInt(match[1]),
				hunkContent: lines.length > 0 ? lines : void 0,
				hunkContext: match[5],
				hunkSpecs: firstLine
			};
			if (isNaN(hunkData.additionCount) || isNaN(hunkData.deletedCount) || isNaN(hunkData.additionStart) || isNaN(hunkData.deletedStart)) {
				console.error("parsePatchContent: invalid hunk metadata", hunkData);
				continue;
			}
			if (lines[lines.length - 1] === "\n") lines.pop();
			currentFile.hunks.push(hunkData);
			currentFile.lines += hunkData.hunkContent?.length ?? 0;
		}
		if (currentFile != null) {
			if (!isGitDiff && currentFile.prevName != null && currentFile.name !== currentFile.prevName) if (currentFile.hunks.length > 0) currentFile.type = "rename-changed";
			else currentFile.type = "rename-pure";
			if (currentFile.type !== "rename-pure" && currentFile.type !== "rename-changed") currentFile.prevName = void 0;
			files.push(currentFile);
		}
	}
	return {
		patchMetadata,
		files
	};
}
function parsePatchFiles(data) {
	const patches = [];
	for (const patch of data.split(COMMIT_METADATA_SPLIT)) try {
		patches.push(processPatch(patch));
	} catch (error) {
		console.error(error);
	}
	return patches;
}

//#endregion
export { parsePatchFiles };
//# sourceMappingURL=parsePatchFiles.js.map