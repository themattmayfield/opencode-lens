// src/list.ts
import { access } from "@corvu/utils/reactivity";
import createControllableSignal from "@corvu/utils/create/controllableSignal";
import { mergeProps } from "solid-js";
var createList = (props) => {
  const defaultedProps = mergeProps(
    {
      initialActive: null,
      orientation: "vertical",
      loop: true,
      textDirection: "ltr",
      handleTab: true,
      vimMode: false,
      vimKeys: {
        up: "k",
        down: "j",
        right: "l",
        left: "h"
      }
    },
    props
  );
  const [active, setActive] = createControllableSignal({
    initialValue: defaultedProps.initialActive,
    onChange: defaultedProps.onActiveChange
  });
  const nextKeys = () => {
    const vimKeys = access(defaultedProps.vimKeys);
    let arrowKey;
    let vimKey;
    if (access(defaultedProps.orientation) === "vertical") {
      arrowKey = "arrowdown";
      vimKey = vimKeys.down;
    } else if (access(defaultedProps.textDirection) === "ltr") {
      arrowKey = "arrowright";
      vimKey = vimKeys.right;
    } else {
      arrowKey = "arrowleft";
      vimKey = vimKeys.left;
    }
    return access(defaultedProps.vimMode) ? [arrowKey, vimKey] : [arrowKey];
  };
  const previousKeys = () => {
    const vimKeys = access(defaultedProps.vimKeys);
    let arrowKey;
    let vimKey;
    if (access(defaultedProps.orientation) === "vertical") {
      arrowKey = "arrowup";
      vimKey = vimKeys.up;
    } else if (access(defaultedProps.textDirection) === "ltr") {
      arrowKey = "arrowleft";
      vimKey = vimKeys.left;
    } else {
      arrowKey = "arrowright";
      vimKey = vimKeys.right;
    }
    return access(defaultedProps.vimMode) ? [arrowKey, vimKey] : [arrowKey];
  };
  const onKeyDown = (event) => {
    const eventKey = event.key.toLowerCase();
    const _items = access(defaultedProps.items);
    if (_items.length === 0) return;
    const _itemCount = _items.length;
    const _active = active();
    const _activeIndex = _active !== null ? _items.indexOf(_active) : null;
    if (nextKeys().includes(eventKey)) {
      event.preventDefault();
      if (_activeIndex === _itemCount - 1) {
        if (access(defaultedProps.loop)) {
          setActive(() => _items[0]);
        }
      } else {
        setActive(() => _items[_activeIndex !== null ? _activeIndex + 1 : 0]);
      }
    } else if (previousKeys().includes(eventKey)) {
      event.preventDefault();
      if (_activeIndex === 0) {
        if (access(defaultedProps.loop)) {
          setActive(() => _items[_itemCount - 1]);
        }
      } else {
        setActive(
          () => _items[_activeIndex !== null ? _activeIndex - 1 : _itemCount - 1]
        );
      }
    } else if (eventKey === "home") {
      event.preventDefault();
      setActive(() => _items[0]);
    } else if (eventKey === "end") {
      event.preventDefault();
      setActive(() => _items[_itemCount - 1]);
    } else if (access(defaultedProps.handleTab) && _activeIndex !== null) {
      if (eventKey === "tab" && !event.shiftKey && _activeIndex < _itemCount - 1) {
        event.preventDefault();
        setActive(() => _items[_activeIndex + 1]);
      }
      if (eventKey === "tab" && event.shiftKey && _activeIndex > 0) {
        event.preventDefault();
        setActive(() => _items[_activeIndex - 1]);
      }
    }
  };
  return { active, setActive, onKeyDown };
};
var list_default = createList;

// src/multi-list.ts
import { access as access2 } from "@corvu/utils/reactivity";
import createControllableSignal2 from "@corvu/utils/create/controllableSignal";
import { mergeProps as mergeProps2 } from "solid-js";
var createMultiList = (props) => {
  const defaultedProps = mergeProps2(
    {
      initialCursor: null,
      initialActive: [],
      initialSelected: [],
      orientation: "vertical",
      loop: true,
      textDirection: "ltr",
      handleTab: true,
      vimMode: false,
      vimKeys: {
        up: "k",
        down: "j",
        right: "l",
        left: "h"
      }
    },
    props
  );
  const [cursor, setCursor] = createControllableSignal2({
    initialValue: defaultedProps.initialCursor,
    onChange: defaultedProps.onCursorChange
  });
  const [active, setActive] = createControllableSignal2({
    initialValue: defaultedProps.initialActive,
    onChange: defaultedProps.onActiveChange
  });
  const [selected, setSelected] = createControllableSignal2({
    initialValue: defaultedProps.initialSelected,
    onChange: defaultedProps.onSelectedChange
  });
  const nextKeys = () => {
    const vimKeys = access2(defaultedProps.vimKeys);
    let arrowKey;
    let vimKey;
    if (access2(defaultedProps.orientation) === "vertical") {
      arrowKey = "arrowdown";
      vimKey = vimKeys.down;
    } else if (access2(defaultedProps.textDirection) === "ltr") {
      arrowKey = "arrowright";
      vimKey = vimKeys.right;
    } else {
      arrowKey = "arrowleft";
      vimKey = vimKeys.left;
    }
    return access2(defaultedProps.vimMode) ? [arrowKey, vimKey] : [arrowKey];
  };
  const previousKeys = () => {
    const vimKeys = access2(defaultedProps.vimKeys);
    let arrowKey;
    let vimKey;
    if (access2(defaultedProps.orientation) === "vertical") {
      arrowKey = "arrowup";
      vimKey = vimKeys.up;
    } else if (access2(defaultedProps.textDirection) === "ltr") {
      arrowKey = "arrowleft";
      vimKey = vimKeys.left;
    } else {
      arrowKey = "arrowright";
      vimKey = vimKeys.right;
    }
    return access2(defaultedProps.vimMode) ? [arrowKey, vimKey] : [arrowKey];
  };
  let direction = null;
  const setCursorActive = (item) => {
    setCursor(() => item);
    setActive(item !== null ? [item] : []);
    direction = null;
  };
  const onKeyDown = (event) => {
    const eventKey = event.key.toLowerCase();
    const _items = access2(defaultedProps.items);
    if (_items.length === 0) return;
    const _itemCount = _items.length;
    const _cursor = cursor();
    const _cursorIndex = _cursor !== null ? _items.indexOf(_cursor) : null;
    const _active = active();
    if (nextKeys().includes(eventKey)) {
      event.preventDefault();
      if (event.shiftKey) {
        if (_cursorIndex === null) {
          setCursorActive(_items[0]);
          setSelected([_items[0]]);
        } else if (_cursorIndex !== _itemCount - 1 || _active.length === 1 && direction === "previous") {
          if (_active.length === 1 && direction !== "next") {
            toggleSelected(_cursor);
            direction = direction === "previous" ? null : "next";
          } else {
            const newCursor = _items[_cursorIndex + 1];
            setCursor(() => newCursor);
            if (_active.includes(newCursor)) {
              setActive(
                (active2) => active2.filter((active3) => active3 !== _cursor)
              );
              toggleSelected(_cursor);
            } else {
              setActive((active2) => [...active2, newCursor]);
              toggleSelected(newCursor);
            }
          }
        }
      } else {
        if (_cursorIndex === _itemCount - 1) {
          if (access2(defaultedProps.loop)) {
            setCursorActive(_items[0]);
          }
        } else {
          setCursorActive(_items[_cursorIndex !== null ? _cursorIndex + 1 : 0]);
        }
      }
    } else if (previousKeys().includes(eventKey)) {
      event.preventDefault();
      if (event.shiftKey) {
        if (_cursorIndex === null) {
          setCursorActive(_items[_itemCount - 1]);
          setSelected([_items[_itemCount - 1]]);
        } else if (_cursorIndex !== 0 || _active.length === 1 && direction === "next") {
          if (_active.length === 1 && direction !== "previous") {
            toggleSelected(_cursor);
            direction = direction === "next" ? null : "previous";
          } else {
            const newCursor = _items[_cursorIndex - 1];
            setCursor(() => newCursor);
            if (_active.includes(newCursor)) {
              setActive(
                (active2) => active2.filter((active3) => active3 !== _cursor)
              );
              toggleSelected(_cursor);
            } else {
              setActive((active2) => [...active2, newCursor]);
              toggleSelected(newCursor);
            }
          }
        }
      } else {
        if (_cursorIndex === 0) {
          if (access2(defaultedProps.loop)) {
            setCursorActive(_items[_itemCount - 1]);
          }
        } else {
          setCursorActive(
            _items[_cursorIndex !== null ? _cursorIndex - 1 : _itemCount - 1]
          );
        }
      }
    } else if (eventKey === "home") {
      event.preventDefault();
      setCursorActive(_items[0]);
    } else if (eventKey === "end") {
      event.preventDefault();
      setCursorActive(_items[_itemCount - 1]);
    } else if (access2(defaultedProps.handleTab) && _cursorIndex !== null) {
      if (eventKey === "tab" && !event.shiftKey && _cursorIndex < _itemCount - 1) {
        event.preventDefault();
        setCursorActive(_items[_cursorIndex + 1]);
      }
      if (eventKey === "tab" && event.shiftKey && _cursorIndex > 0) {
        event.preventDefault();
        setCursorActive(_items[_cursorIndex - 1]);
      }
    }
  };
  const toggleSelected = (item) => {
    setSelected(
      (selected2) => selected2.includes(item) ? selected2.filter((selected3) => selected3 !== item) : [...selected2, item]
    );
  };
  return {
    cursor,
    setCursor,
    active,
    setActive,
    setCursorActive,
    selected,
    setSelected,
    toggleSelected,
    onKeyDown
  };
};
var multi_list_default = createMultiList;
export {
  list_default as createList,
  multi_list_default as createMultiList
};
