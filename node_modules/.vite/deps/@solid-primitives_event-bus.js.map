{
  "version": 3,
  "sources": ["../../@solid-primitives/event-bus/dist/eventBus.js", "../../@solid-primitives/event-bus/dist/emitter.js", "../../@solid-primitives/event-bus/dist/eventHub.js", "../../@solid-primitives/utils/dist/immutable/copy.js", "../../@solid-primitives/utils/dist/immutable/array.js", "../../@solid-primitives/event-bus/dist/eventStack.js", "../../@solid-primitives/event-bus/dist/utils.js"],
  "sourcesContent": ["import { tryOnCleanup } from \"@solid-primitives/utils\";\nimport { onCleanup } from \"solid-js\";\nexport class EventBusCore extends Set {\n    emit(payload) {\n        for (const cb of this)\n            cb(payload);\n    }\n}\n/**\n * Provides a simple way to listen to and emit events. All listeners are automatically unsubscribed on cleanup.\n *\n * @returns the emitter: `{listen, emit, clear}`\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/event-bus#createEventBus\n *\n * @example\nconst bus = createEventBus<string>();\n// bus can be destructured:\nconst { listen, emit, clear } = bus;\n\nconst unsub = bus.listen((a) => console.log(a));\n\nbus.emit(\"foo\");\n\n// unsub gets called automatically on cleanup\nunsub();\n */\nexport function createEventBus() {\n    const bus = new EventBusCore();\n    return {\n        listen(listener) {\n            bus.add(listener);\n            return tryOnCleanup(bus.delete.bind(bus, listener));\n        },\n        emit: bus.emit.bind(bus),\n        clear: onCleanup(bus.clear.bind(bus)),\n    };\n}\n", "import { tryOnCleanup } from \"@solid-primitives/utils\";\nimport { onCleanup } from \"solid-js\";\nimport { createEventBus, EventBusCore } from \"./eventBus.js\";\nexport class EmitterCore extends Map {\n    on(event, listener) {\n        let bus = this.get(event);\n        bus || this.set(event, (bus = new EventBusCore()));\n        bus.add(listener);\n    }\n    off(event, listener) {\n        const bus = this.get(event);\n        bus?.delete(listener) && !bus.size && this.delete(event);\n    }\n    emit(event, value) {\n        this.get(event)?.emit(value);\n    }\n}\n/**\n * Creates an emitter with which you can listen to and emit various events.\n *\n * @returns emitter mathods: `{on, emit, clear}`\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/event-bus#createEmitter\n *\n * @example\n * const emitter = createEmitter<{\n *   foo: number;\n *   bar: string;\n * }>();\n * // can be destructured\n * const { on, emit, clear } = emitter;\n *\n * emitter.on(\"foo\", e => {});\n * emitter.on(\"bar\", e => {});\n *\n * emitter.emit(\"foo\", 0);\n * emitter.emit(\"bar\", \"hello\");\n */\nexport function createEmitter() {\n    const emitter = new EmitterCore();\n    return {\n        on(event, listener) {\n            emitter.on(event, listener);\n            return tryOnCleanup(emitter.off.bind(emitter, event, listener));\n        },\n        emit: emitter.emit.bind(emitter),\n        clear: onCleanup(emitter.clear.bind(emitter)),\n    };\n}\n/**\n * Creates an emitter with which you can listen to and emit various events. With this emitter you can also listen to all events.\n *\n * @returns emitter mathods: `{on, listen, emit, clear}`\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/event-bus#createGlobalEmitter\n *\n * @example\n * const emitter = createGlobalEmitter<{\n *   foo: number;\n *   bar: string;\n * }>();\n * // can be destructured\n * const { on, emit, clear, listen } = emitter;\n *\n * emitter.on(\"foo\", e => {});\n * emitter.on(\"bar\", e => {});\n *\n * emitter.emit(\"foo\", 0);\n * emitter.emit(\"bar\", \"hello\");\n *\n * emitter.listen(e => {\n *   switch (e.name) {\n *     case \"foo\": {\n *       e.details;\n *       break;\n *     }\n *     case \"bar\": {\n *       e.details;\n *       break;\n *     }\n *   }\n * })\n */\nexport function createGlobalEmitter() {\n    const emitter = createEmitter();\n    const global = createEventBus();\n    return {\n        on: emitter.on,\n        clear: emitter.clear,\n        listen: global.listen,\n        emit(name, details) {\n            global.emit({ name, details });\n            emitter.emit(name, details);\n        },\n    };\n}\n", "import {} from \"solid-js\";\nimport {} from \"./emitter.js\";\nimport { createEventBus } from \"./eventBus.js\";\n/**\n * Provides helpers for using a group of event buses.\n *\n * Can be used with `createEventBus`, `createEventStack` or any emitter that has the same api.\n *\n * @param defineChannels object with defined channels or a defineChannels function returning channels.\n *\n * @returns hub functions: `{on, emit, listen, value}` + channels available by their key\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/event-bus#createEventHub\n *\n * @example\n * const hub = createEventHub({\n *    busA: createEventBus<void>(),\n *    busB: createEventBus<string>(),\n *    busC: createEventStack<{ text: string }>()\n * });\n * // can be destructured\n * const { busA, busB, on, listen, emit } = hub;\n *\n * hub.on(\"busA\", e => {});\n * hub.on(\"busB\", e => {});\n *\n * hub.emit(\"busA\", 0);\n * hub.emit(\"busB\", \"foo\");\n */\nexport function createEventHub(defineChannels) {\n    const global = /*#__PURE__*/ createEventBus();\n    const buses = typeof defineChannels === \"function\" ? defineChannels(createEventBus) : defineChannels;\n    const value = {};\n    Object.entries(buses).forEach(([name, bus]) => {\n        bus.value && Object.defineProperty(value, name, { get: bus.value, enumerable: true });\n        bus.listen(payload => global.emit({ name, details: payload }));\n    });\n    return {\n        ...buses,\n        value,\n        on: (e, a) => buses[e].listen(a),\n        emit: (e, a) => buses[e].emit(a),\n        listen: global.listen,\n    };\n}\n", "/** make shallow copy of an array */\nexport const shallowArrayCopy = (array) => array.slice();\n/** make shallow copy of an object */\nexport const shallowObjectCopy = (object) => Object.assign({}, object);\n/** make shallow copy of an array/object */\nexport const shallowCopy = (source) => Array.isArray(source) ? shallowArrayCopy(source) : shallowObjectCopy(source);\n/**\n * apply mutations to the an array without changing the original\n * @param array original array\n * @param mutator function applying mutations to the copy of source\n * @returns changed array copy\n */\nexport const withArrayCopy = (array, mutator) => {\n    const copy = shallowArrayCopy(array);\n    mutator(copy);\n    return copy;\n};\n/**\n * apply mutations to the an object without changing the original\n * @param object original object\n * @param mutator function applying mutations to the copy of source\n * @returns changed object copy\n */\nexport const withObjectCopy = (object, mutator) => {\n    const copy = shallowObjectCopy(object);\n    mutator(copy);\n    return copy;\n};\n/**\n * apply mutations to the an object/array without changing the original\n * @param source original object\n * @param mutator function applying mutations to the copy of source\n * @returns changed object copy\n */\nexport const withCopy = (source, mutator) => Array.isArray(source)\n    ? withArrayCopy(source, mutator)\n    : withObjectCopy(source, mutator);\n", "import { compare, ofClass } from \"../index.js\";\nimport { withArrayCopy } from \"./copy.js\";\nimport { get } from \"./object.js\";\n/**\n * non-mutating `Array.prototype.push()`\n * @returns changed array copy\n */\nexport const push = (list, ...items) => withArrayCopy(list, list => list.push(...items));\n/**\n * non-mutating function that drops n items from the array start.\n * @returns changed array copy\n *\n * @example\n * ```ts\n * const newList = drop([1,2,3])\n * newList // => [2,3]\n *\n * const newList = drop([1,2,3], 2)\n * newList // => [3]\n * ```\n */\nexport const drop = (list, n = 1) => list.slice(n);\n/**\n * non-mutating function that drops n items from the array end.\n * @returns changed array copy\n *\n * @example\n * ```ts\n * const newList = dropRight([1,2,3])\n * newList // => [1,2]\n *\n * const newList = dropRight([1,2,3], 2)\n * newList // => [1]\n * ```\n */\nexport const dropRight = (list, n = 1) => list.slice(0, list.length - n);\n/**\n * standalone `Array.prototype.filter()` that filters out passed item\n * @returns changed array copy\n */\nexport const filterOut = (list, item) => filter(list, i => i !== item);\n/**\n * standalone `Array.prototype.filter()`\n * @returns changed array copy\n */\nexport function filter(list, predicate) {\n    const newList = list.filter(predicate);\n    newList.removed = list.length - newList.length;\n    return newList;\n}\n/**\n * non-mutating `Array.prototype.sort()` as a standalone function\n * @returns changed array copy\n */\nexport const sort = (list, compareFn) => list.slice().sort(compareFn);\n/**\n * standalone `Array.prototype.map()` function\n */\nexport const map = (list, mapFn) => list.map(mapFn);\n/**\n * standalone `Array.prototype.slice()` function\n */\nexport const slice = (list, start, end) => list.slice(start, end);\n/**\n * non-mutating `Array.prototype.splice()` as a standalone function\n * @returns changed array copy\n */\nexport const splice = (list, start, deleteCount = 0, ...items) => withArrayCopy(list, list => list.splice(start, deleteCount, ...items));\n/**\n * non-mutating `Array.prototype.fill()` as a standalone function\n * @returns changed array copy\n */\nexport const fill = (list, value, start, end) => list.slice().fill(value, start, end);\n/**\n * Creates a new array concatenating array with any additional arrays and/or values.\n * @param ...a values or arrays\n * @returns new concatenated array\n */\nexport function concat(...a) {\n    const result = [];\n    for (const i in a) {\n        Array.isArray(a[i]) ? result.push(...a[i]) : result.push(a[i]);\n    }\n    return result;\n}\n/**\n * Remove item from array\n * @returns changed array copy\n */\nexport const remove = (list, item, ...insertItems) => {\n    const index = list.indexOf(item);\n    return splice(list, index, 1, ...insertItems);\n};\n/**\n * Remove multiple items from an array\n * @returns changed array copy\n */\nexport const removeItems = (list, ...items) => {\n    const res = [];\n    for (let i = 0; i < list.length; i++) {\n        const item = list[i];\n        const ii = items.indexOf(item);\n        if (ii !== -1)\n            items.splice(ii, 1);\n        else\n            res.push(item);\n    }\n    return res;\n};\n/**\n * Flattens a nested array into a one-level array\n * @returns changed array copy\n */\nexport const flatten = (arr) => arr.reduce((flat, next) => flat.concat(Array.isArray(next) ? flatten(next) : next), []);\n/**\n * Sort an array by object key, or multiple keys\n * @returns changed array copy\n */\nexport const sortBy = (arr, ...paths) => flatten(paths).reduce((source, path) => sort(source, (a, b) => typeof path === \"function\"\n    ? compare(path(a), path(b))\n    : compare(get(a, path), get(b, path))), arr);\n/**\n * Returns a subset of items that are instances of provided Classes\n * @param list list of original items\n * @param ...classes list or classes\n * @returns changed array copy\n */\nexport const filterInstance = (list, ...classes) => (classes.length === 1\n    ? list.filter(item => ofClass(item, classes[0]))\n    : list.filter(item => item && classes.some(c => ofClass(item, c))));\n/**\n * Returns a subset of items that aren't instances of provided Classes\n * @param list list of original items\n * @param ...classes list or classes\n * @returns changed array copy\n */\nexport const filterOutInstance = (list, ...classes) => (classes.length === 1\n    ? list.filter(item => item && !ofClass(item, classes[0]))\n    : list.filter(item => item && !classes.some(c => ofClass(item, c))));\n", "import { drop, filterOut, push } from \"@solid-primitives/utils/immutable\";\nimport { createSignal } from \"solid-js\";\nimport { createEventBus } from \"./eventBus.js\";\nexport function createEventStack(config = {}) {\n    const { toValue = (e) => e, length = 0 } = config;\n    const [stack, setValue] = /*#__PURE__*/ createSignal([]);\n    const eventEventBus = createEventBus();\n    const valueEventBus = createEventBus();\n    eventEventBus.listen(event => {\n        const value = toValue(event, stack());\n        setValue(prev => {\n            const list = push(prev, value);\n            return length && list.length > length ? drop(list) : list;\n        });\n        valueEventBus.emit({\n            event: value,\n            stack: stack(),\n            remove: () => remove(value),\n        });\n    });\n    const remove = value => !!setValue(p => filterOut(p, value)).removed;\n    return {\n        clear: valueEventBus.clear,\n        listen: valueEventBus.listen,\n        emit: eventEventBus.emit,\n        value: stack,\n        setValue,\n        remove,\n    };\n}\n", "import { push } from \"@solid-primitives/utils/immutable\";\nimport {} from \"@solid-primitives/utils\";\nimport { batch, createEffect, createSignal, on } from \"solid-js\";\n/**\n * Turns a stream-like listen function, into a promise resolving when the first event is captured.\n * @param subscribe listen function from any EventBus/Emitter\n * @returns a promise resulting in the captured event value\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/event-bus#toPromise\n *\n * @example\n * const emitter = createEventBus<string>();\n * const event = await toPromise(emitter.listen);\n */\nexport function toPromise(subscribe) {\n    return new Promise(resolve => once(subscribe, resolve));\n}\n/**\n * Listen to any EventBus/Emitter, but the listener will automatically unsubscribe on the first captured event. So the callback will run only **once**.\n *\n * @param subscribe Emitter's `listen` function\n * @param listener callback called when an event is emitted\n *\n * @returns unsubscribe function\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/event-bus#once\n *\n * @example\n * const { listen, emit } = createEventBus<string>();\n * const unsub = once(listen, event => console.log(event));\n *\n * emit(\"foo\") // will log \"foo\" and unsub\n *\n * emit(\"bar\") // won't log\n */\nexport function once(subscribe, listener) {\n    const unsub = subscribe(payload => {\n        unsub();\n        listener(payload);\n    });\n    return unsub;\n}\n/**\n * Wraps `emit` calls inside a `createEffect`. It causes that listeners execute having an reactive owner available. It allows for usage of effects, memos and other primitives inside listeners, without having to create a synthetic root.\n *\n * @param emit the emit function of any emitter/event-bus\n * @returns modified emit function\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/event-bus#toEffect\n *\n * @example\n * const { listen, emit } = createEventBus();\n * const emitInEffect = toEffect(emit);\n * listen(() => console.log(getOwner()))\n *\n * // ...sometime later (after root initiation):\n * emit() // listener will log `null`\n * emitInEffect() // listener will log an owner object\n */\nexport function toEffect(emit) {\n    const [stack, setStack] = createSignal([]);\n    createEffect(on(stack, stack => {\n        if (!stack.length)\n            return;\n        setStack([]);\n        stack.forEach(emit);\n    }));\n    return (payload) => void setStack(p => push(p, payload));\n}\n/**\n * Wraps `emit` calls inside a `batch` call. It causes that listeners execute in a single batch, so they are not executed in sepatate queue ticks.\n *\n * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/event-bus#batchEmits\n */\nexport function batchEmits(bus) {\n    return {\n        ...bus,\n        emit: (...args) => batch(() => bus.emit(...args)),\n    };\n}\n"],
  "mappings": "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",
  "names": ["list", "stack"]
}
