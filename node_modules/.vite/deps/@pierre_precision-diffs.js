import {
  EncodedTokenMetadata,
  FontStyle,
  INITIAL,
  Registry,
  Theme,
  toHtml,
  toRegExp
} from "./chunk-EYXMZIQA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/@shikijs/core/node_modules/@shikijs/types/dist/index.mjs
var ShikiError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};

// node_modules/@shikijs/core/dist/index.mjs
function resolveColorReplacements(theme, options) {
  const replacements = typeof theme === "string" ? {} : { ...theme.colorReplacements };
  const themeName = typeof theme === "string" ? theme : theme.name;
  for (const [key, value] of Object.entries(options?.colorReplacements || {})) {
    if (typeof value === "string")
      replacements[key] = value;
    else if (key === themeName)
      Object.assign(replacements, value);
  }
  return replacements;
}
function applyColorReplacements(color, replacements) {
  if (!color)
    return color;
  return replacements?.[color?.toLowerCase()] || color;
}
function toArray(x) {
  return Array.isArray(x) ? x : [x];
}
async function normalizeGetter(p) {
  return Promise.resolve(typeof p === "function" ? p() : p).then((r) => r.default || r);
}
function isPlainLang(lang) {
  return !lang || ["plaintext", "txt", "text", "plain"].includes(lang);
}
function isSpecialLang(lang) {
  return lang === "ansi" || isPlainLang(lang);
}
function isNoneTheme(theme) {
  return theme === "none";
}
function isSpecialTheme(theme) {
  return isNoneTheme(theme);
}
function addClassToHast(node, className) {
  if (!className)
    return node;
  node.properties ||= {};
  node.properties.class ||= [];
  if (typeof node.properties.class === "string")
    node.properties.class = node.properties.class.split(/\s+/g);
  if (!Array.isArray(node.properties.class))
    node.properties.class = [];
  const targets = Array.isArray(className) ? className : className.split(/\s+/g);
  for (const c of targets) {
    if (c && !node.properties.class.includes(c))
      node.properties.class.push(c);
  }
  return node;
}
function splitLines(code, preserveEnding = false) {
  const parts = code.split(/(\r?\n)/g);
  let index = 0;
  const lines = [];
  for (let i = 0; i < parts.length; i += 2) {
    const line = preserveEnding ? parts[i] + (parts[i + 1] || "") : parts[i];
    lines.push([line, index]);
    index += parts[i].length;
    index += parts[i + 1]?.length || 0;
  }
  return lines;
}
function createPositionConverter(code) {
  const lines = splitLines(code, true).map(([line]) => line);
  function indexToPos(index) {
    if (index === code.length) {
      return {
        line: lines.length - 1,
        character: lines[lines.length - 1].length
      };
    }
    let character = index;
    let line = 0;
    for (const lineText of lines) {
      if (character < lineText.length)
        break;
      character -= lineText.length;
      line++;
    }
    return { line, character };
  }
  function posToIndex(line, character) {
    let index = 0;
    for (let i = 0; i < line; i++)
      index += lines[i].length;
    index += character;
    return index;
  }
  return {
    lines,
    indexToPos,
    posToIndex
  };
}
function guessEmbeddedLanguages(code, _lang, highlighter2) {
  const langs = /* @__PURE__ */ new Set();
  for (const match of code.matchAll(/lang=["']([\w-]+)["']/g)) {
    langs.add(match[1]);
  }
  for (const match of code.matchAll(/(?:```|~~~)([\w-]+)/g)) {
    langs.add(match[1]);
  }
  for (const match of code.matchAll(/\\begin\{([\w-]+)\}/g)) {
    langs.add(match[1]);
  }
  if (!highlighter2)
    return Array.from(langs);
  const bundle = highlighter2.getBundledLanguages();
  return Array.from(langs).filter((l) => l && bundle[l]);
}
var DEFAULT_COLOR_LIGHT_DARK = "light-dark()";
var COLOR_KEYS = ["color", "background-color"];
function splitToken(token, offsets) {
  let lastOffset = 0;
  const tokens = [];
  for (const offset of offsets) {
    if (offset > lastOffset) {
      tokens.push({
        ...token,
        content: token.content.slice(lastOffset, offset),
        offset: token.offset + lastOffset
      });
    }
    lastOffset = offset;
  }
  if (lastOffset < token.content.length) {
    tokens.push({
      ...token,
      content: token.content.slice(lastOffset),
      offset: token.offset + lastOffset
    });
  }
  return tokens;
}
function splitTokens(tokens, breakpoints) {
  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);
  if (!sorted.length)
    return tokens;
  return tokens.map((line) => {
    return line.flatMap((token) => {
      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);
      if (!breakpointsInToken.length)
        return token;
      return splitToken(token, breakpointsInToken);
    });
  });
}
function flatTokenVariants(merged, variantsOrder, cssVariablePrefix, defaultColor, colorsRendering = "css-vars") {
  const token = {
    content: merged.content,
    explanation: merged.explanation,
    offset: merged.offset
  };
  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));
  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));
  const mergedStyles = {};
  const varKey = (idx, key) => {
    const keyName = key === "color" ? "" : key === "background-color" ? "-bg" : `-${key}`;
    return cssVariablePrefix + variantsOrder[idx] + (key === "color" ? "" : keyName);
  };
  styles.forEach((cur, idx) => {
    for (const key of styleKeys) {
      const value = cur[key] || "inherit";
      if (idx === 0 && defaultColor && COLOR_KEYS.includes(key)) {
        if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && styles.length > 1) {
          const lightIndex = variantsOrder.findIndex((t) => t === "light");
          const darkIndex = variantsOrder.findIndex((t) => t === "dark");
          if (lightIndex === -1 || darkIndex === -1)
            throw new ShikiError('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
          const lightValue = styles[lightIndex][key] || "inherit";
          const darkValue = styles[darkIndex][key] || "inherit";
          mergedStyles[key] = `light-dark(${lightValue}, ${darkValue})`;
          if (colorsRendering === "css-vars")
            mergedStyles[varKey(idx, key)] = value;
        } else {
          mergedStyles[key] = value;
        }
      } else {
        if (colorsRendering === "css-vars")
          mergedStyles[varKey(idx, key)] = value;
      }
    }
  });
  token.htmlStyle = mergedStyles;
  return token;
}
function getTokenStyleObject(token) {
  const styles = {};
  if (token.color)
    styles.color = token.color;
  if (token.bgColor)
    styles["background-color"] = token.bgColor;
  if (token.fontStyle) {
    if (token.fontStyle & FontStyle.Italic)
      styles["font-style"] = "italic";
    if (token.fontStyle & FontStyle.Bold)
      styles["font-weight"] = "bold";
    const decorations2 = [];
    if (token.fontStyle & FontStyle.Underline)
      decorations2.push("underline");
    if (token.fontStyle & FontStyle.Strikethrough)
      decorations2.push("line-through");
    if (decorations2.length)
      styles["text-decoration"] = decorations2.join(" ");
  }
  return styles;
}
function stringifyTokenStyle(token) {
  if (typeof token === "string")
    return token;
  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(";");
}
var _grammarStateMap = /* @__PURE__ */ new WeakMap();
function setLastGrammarStateToMap(keys, state) {
  _grammarStateMap.set(keys, state);
}
function getLastGrammarStateFromMap(keys) {
  return _grammarStateMap.get(keys);
}
var GrammarState = class _GrammarState {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(lang, themes) {
    return new _GrammarState(
      Object.fromEntries(toArray(themes).map((theme) => [theme, INITIAL])),
      lang
    );
  }
  constructor(...args) {
    if (args.length === 2) {
      const [stacksMap, lang] = args;
      this.lang = lang;
      this._stacks = stacksMap;
    } else {
      const [stack, lang, theme] = args;
      this.lang = lang;
      this._stacks = { [theme]: stack };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(theme = this.theme) {
    return this._stacks[theme];
  }
  getScopes(theme = this.theme) {
    return getScopes(this._stacks[theme]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.getScopes()
    };
  }
};
function getScopes(stack) {
  const scopes = [];
  const visited = /* @__PURE__ */ new Set();
  function pushScope(stack2) {
    if (visited.has(stack2))
      return;
    visited.add(stack2);
    const name = stack2?.nameScopesList?.scopeName;
    if (name)
      scopes.push(name);
    if (stack2.parent)
      pushScope(stack2.parent);
  }
  pushScope(stack);
  return scopes;
}
function getGrammarStack(state, theme) {
  if (!(state instanceof GrammarState))
    throw new ShikiError("Invalid grammar state");
  return state.getInternalStack(theme);
}
function transformerDecorations() {
  const map = /* @__PURE__ */ new WeakMap();
  function getContext(shiki) {
    if (!map.has(shiki.meta)) {
      let normalizePosition = function(p) {
        if (typeof p === "number") {
          if (p < 0 || p > shiki.source.length)
            throw new ShikiError(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);
          return {
            ...converter.indexToPos(p),
            offset: p
          };
        } else {
          const line = converter.lines[p.line];
          if (line === void 0)
            throw new ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);
          let character = p.character;
          if (character < 0)
            character = line.length + character;
          if (character < 0 || character > line.length)
            throw new ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);
          return {
            ...p,
            character,
            offset: converter.posToIndex(p.line, character)
          };
        }
      };
      const converter = createPositionConverter(shiki.source);
      const decorations2 = (shiki.options.decorations || []).map((d) => ({
        ...d,
        start: normalizePosition(d.start),
        end: normalizePosition(d.end)
      }));
      verifyIntersections(decorations2);
      map.set(shiki.meta, {
        decorations: decorations2,
        converter,
        source: shiki.source
      });
    }
    return map.get(shiki.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(tokens) {
      if (!this.options.decorations?.length)
        return;
      const ctx = getContext(this);
      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);
      const splitted = splitTokens(tokens, breakpoints);
      return splitted;
    },
    code(codeEl) {
      if (!this.options.decorations?.length)
        return;
      const ctx = getContext(this);
      const lines = Array.from(codeEl.children).filter((i) => i.type === "element" && i.tagName === "span");
      if (lines.length !== ctx.converter.lines.length)
        throw new ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);
      function applyLineSection(line, start, end, decoration) {
        const lineEl = lines[line];
        let text = "";
        let startIndex = -1;
        let endIndex = -1;
        if (start === 0)
          startIndex = 0;
        if (end === 0)
          endIndex = 0;
        if (end === Number.POSITIVE_INFINITY)
          endIndex = lineEl.children.length;
        if (startIndex === -1 || endIndex === -1) {
          for (let i = 0; i < lineEl.children.length; i++) {
            text += stringify(lineEl.children[i]);
            if (startIndex === -1 && text.length === start)
              startIndex = i + 1;
            if (endIndex === -1 && text.length === end)
              endIndex = i + 1;
          }
        }
        if (startIndex === -1)
          throw new ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);
        if (endIndex === -1)
          throw new ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);
        const children = lineEl.children.slice(startIndex, endIndex);
        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {
          applyDecoration(lineEl, decoration, "line");
        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === "element") {
          applyDecoration(children[0], decoration, "token");
        } else {
          const wrapper = {
            type: "element",
            tagName: "span",
            properties: {},
            children
          };
          applyDecoration(wrapper, decoration, "wrapper");
          lineEl.children.splice(startIndex, children.length, wrapper);
        }
      }
      function applyLine(line, decoration) {
        lines[line] = applyDecoration(lines[line], decoration, "line");
      }
      function applyDecoration(el, decoration, type) {
        const properties = decoration.properties || {};
        const transform = decoration.transform || ((i) => i);
        el.tagName = decoration.tagName || "span";
        el.properties = {
          ...el.properties,
          ...properties,
          class: el.properties.class
        };
        if (decoration.properties?.class)
          addClassToHast(el, decoration.properties.class);
        el = transform(el, type) || el;
        return el;
      }
      const lineApplies = [];
      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset || a.end.offset - b.end.offset);
      for (const decoration of sorted) {
        const { start, end } = decoration;
        if (start.line === end.line) {
          applyLineSection(start.line, start.character, end.character, decoration);
        } else if (start.line < end.line) {
          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);
          for (let i = start.line + 1; i < end.line; i++)
            lineApplies.unshift(() => applyLine(i, decoration));
          applyLineSection(end.line, 0, end.character, decoration);
        }
      }
      lineApplies.forEach((i) => i());
    }
  };
}
function verifyIntersections(items) {
  for (let i = 0; i < items.length; i++) {
    const foo = items[i];
    if (foo.start.offset > foo.end.offset)
      throw new ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);
    for (let j = i + 1; j < items.length; j++) {
      const bar = items[j];
      const isFooHasBarStart = foo.start.offset <= bar.start.offset && bar.start.offset < foo.end.offset;
      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset <= foo.end.offset;
      const isBarHasFooStart = bar.start.offset <= foo.start.offset && foo.start.offset < bar.end.offset;
      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset <= bar.end.offset;
      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {
        if (isFooHasBarStart && isFooHasBarEnd)
          continue;
        if (isBarHasFooStart && isBarHasFooEnd)
          continue;
        if (isBarHasFooStart && foo.start.offset === foo.end.offset)
          continue;
        if (isFooHasBarEnd && bar.start.offset === bar.end.offset)
          continue;
        throw new ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);
      }
    }
  }
}
function stringify(el) {
  if (el.type === "text")
    return el.value;
  if (el.type === "element")
    return el.children.map(stringify).join("");
  return "";
}
var builtInTransformers = [
  transformerDecorations()
];
function getTransformers(options) {
  const transformers = sortTransformersByEnforcement(options.transformers || []);
  return [
    ...transformers.pre,
    ...transformers.normal,
    ...transformers.post,
    ...builtInTransformers
  ];
}
function sortTransformersByEnforcement(transformers) {
  const pre = [];
  const post = [];
  const normal = [];
  for (const transformer of transformers) {
    switch (transformer.enforce) {
      case "pre":
        pre.push(transformer);
        break;
      case "post":
        post.push(transformer);
        break;
      default:
        normal.push(transformer);
    }
  }
  return { pre, post, normal };
}
var namedColors = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
];
var decorations = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  8: "hidden",
  9: "strikethrough"
};
function findSequence(value, position) {
  const nextEscape = value.indexOf("\x1B", position);
  if (nextEscape !== -1) {
    if (value[nextEscape + 1] === "[") {
      const nextClose = value.indexOf("m", nextEscape);
      if (nextClose !== -1) {
        return {
          sequence: value.substring(nextEscape + 2, nextClose).split(";"),
          startPosition: nextEscape,
          position: nextClose + 1
        };
      }
    }
  }
  return {
    position: value.length
  };
}
function parseColor(sequence) {
  const colorMode = sequence.shift();
  if (colorMode === "2") {
    const rgb = sequence.splice(0, 3).map((x) => Number.parseInt(x));
    if (rgb.length !== 3 || rgb.some((x) => Number.isNaN(x)))
      return;
    return {
      type: "rgb",
      rgb
    };
  } else if (colorMode === "5") {
    const index = sequence.shift();
    if (index) {
      return { type: "table", index: Number(index) };
    }
  }
}
function parseSequence(sequence) {
  const commands = [];
  while (sequence.length > 0) {
    const code = sequence.shift();
    if (!code)
      continue;
    const codeInt = Number.parseInt(code);
    if (Number.isNaN(codeInt))
      continue;
    if (codeInt === 0) {
      commands.push({ type: "resetAll" });
    } else if (codeInt <= 9) {
      const decoration = decorations[codeInt];
      if (decoration) {
        commands.push({
          type: "setDecoration",
          value: decorations[codeInt]
        });
      }
    } else if (codeInt <= 29) {
      const decoration = decorations[codeInt - 20];
      if (decoration) {
        commands.push({
          type: "resetDecoration",
          value: decoration
        });
        if (decoration === "dim") {
          commands.push({
            type: "resetDecoration",
            value: "bold"
          });
        }
      }
    } else if (codeInt <= 37) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 30] }
      });
    } else if (codeInt === 38) {
      const color = parseColor(sequence);
      if (color) {
        commands.push({
          type: "setForegroundColor",
          value: color
        });
      }
    } else if (codeInt === 39) {
      commands.push({
        type: "resetForegroundColor"
      });
    } else if (codeInt <= 47) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 40] }
      });
    } else if (codeInt === 48) {
      const color = parseColor(sequence);
      if (color) {
        commands.push({
          type: "setBackgroundColor",
          value: color
        });
      }
    } else if (codeInt === 49) {
      commands.push({
        type: "resetBackgroundColor"
      });
    } else if (codeInt === 53) {
      commands.push({
        type: "setDecoration",
        value: "overline"
      });
    } else if (codeInt === 55) {
      commands.push({
        type: "resetDecoration",
        value: "overline"
      });
    } else if (codeInt >= 90 && codeInt <= 97) {
      commands.push({
        type: "setForegroundColor",
        value: { type: "named", name: namedColors[codeInt - 90 + 8] }
      });
    } else if (codeInt >= 100 && codeInt <= 107) {
      commands.push({
        type: "setBackgroundColor",
        value: { type: "named", name: namedColors[codeInt - 100 + 8] }
      });
    }
  }
  return commands;
}
function createAnsiSequenceParser() {
  let foreground = null;
  let background = null;
  let decorations2 = /* @__PURE__ */ new Set();
  return {
    parse(value) {
      const tokens = [];
      let position = 0;
      do {
        const findResult = findSequence(value, position);
        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);
        if (text.length > 0) {
          tokens.push({
            value: text,
            foreground,
            background,
            decorations: new Set(decorations2)
          });
        }
        if (findResult.sequence) {
          const commands = parseSequence(findResult.sequence);
          for (const styleToken of commands) {
            if (styleToken.type === "resetAll") {
              foreground = null;
              background = null;
              decorations2.clear();
            } else if (styleToken.type === "resetForegroundColor") {
              foreground = null;
            } else if (styleToken.type === "resetBackgroundColor") {
              background = null;
            } else if (styleToken.type === "resetDecoration") {
              decorations2.delete(styleToken.value);
            }
          }
          for (const styleToken of commands) {
            if (styleToken.type === "setForegroundColor") {
              foreground = styleToken.value;
            } else if (styleToken.type === "setBackgroundColor") {
              background = styleToken.value;
            } else if (styleToken.type === "setDecoration") {
              decorations2.add(styleToken.value);
            }
          }
        }
        position = findResult.position;
      } while (position < value.length);
      return tokens;
    }
  };
}
var defaultNamedColorsMap = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function createColorPalette(namedColorsMap = defaultNamedColorsMap) {
  function namedColor(name) {
    return namedColorsMap[name];
  }
  function rgbColor(rgb) {
    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let colorTable;
  function getColorTable() {
    if (colorTable) {
      return colorTable;
    }
    colorTable = [];
    for (let i = 0; i < namedColors.length; i++) {
      colorTable.push(namedColor(namedColors[i]));
    }
    let levels = [0, 95, 135, 175, 215, 255];
    for (let r = 0; r < 6; r++) {
      for (let g = 0; g < 6; g++) {
        for (let b = 0; b < 6; b++) {
          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));
        }
      }
    }
    let level = 8;
    for (let i = 0; i < 24; i++, level += 10) {
      colorTable.push(rgbColor([level, level, level]));
    }
    return colorTable;
  }
  function tableColor(index) {
    return getColorTable()[index];
  }
  function value(color) {
    switch (color.type) {
      case "named":
        return namedColor(color.name);
      case "rgb":
        return rgbColor(color.rgb);
      case "table":
        return tableColor(color.index);
    }
  }
  return {
    value
  };
}
function tokenizeAnsiWithTheme(theme, fileContents, options) {
  const colorReplacements = resolveColorReplacements(theme, options);
  const lines = splitLines(fileContents);
  const colorPalette = createColorPalette(
    Object.fromEntries(
      namedColors.map((name) => [
        name,
        theme.colors?.[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]
      ])
    )
  );
  const parser = createAnsiSequenceParser();
  return lines.map(
    (line) => parser.parse(line[0]).map((token) => {
      let color;
      let bgColor;
      if (token.decorations.has("reverse")) {
        color = token.background ? colorPalette.value(token.background) : theme.bg;
        bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
      } else {
        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;
        bgColor = token.background ? colorPalette.value(token.background) : void 0;
      }
      color = applyColorReplacements(color, colorReplacements);
      bgColor = applyColorReplacements(bgColor, colorReplacements);
      if (token.decorations.has("dim"))
        color = dimColor(color);
      let fontStyle = FontStyle.None;
      if (token.decorations.has("bold"))
        fontStyle |= FontStyle.Bold;
      if (token.decorations.has("italic"))
        fontStyle |= FontStyle.Italic;
      if (token.decorations.has("underline"))
        fontStyle |= FontStyle.Underline;
      if (token.decorations.has("strikethrough"))
        fontStyle |= FontStyle.Strikethrough;
      return {
        content: token.value,
        offset: line[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color,
        bgColor,
        fontStyle
      };
    })
  );
}
function dimColor(color) {
  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (hexMatch) {
    if (hexMatch[3]) {
      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;
    } else if (hexMatch[2]) {
      return `#${hexMatch[1]}${hexMatch[2]}80`;
    } else {
      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join("")}80`;
    }
  }
  const cssVarMatch = color.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  if (cssVarMatch)
    return `var(${cssVarMatch[1]}-dim)`;
  return color;
}
function codeToTokensBase(internal, code, options = {}) {
  const {
    lang = "text",
    theme: themeName = internal.getLoadedThemes()[0]
  } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName))
    return splitLines(code).map((line) => [{ content: line[0], offset: line[1] }]);
  const { theme, colorMap } = internal.setTheme(themeName);
  if (lang === "ansi")
    return tokenizeAnsiWithTheme(theme, code, options);
  const _grammar = internal.getLanguage(lang);
  if (options.grammarState) {
    if (options.grammarState.lang !== _grammar.name) {
      throw new ShikiError(`Grammar state language "${options.grammarState.lang}" does not match highlight language "${_grammar.name}"`);
    }
    if (!options.grammarState.themes.includes(theme.name)) {
      throw new ShikiError(`Grammar state themes "${options.grammarState.themes}" do not contain highlight theme "${theme.name}"`);
    }
  }
  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);
}
function getLastGrammarState(...args) {
  if (args.length === 2) {
    return getLastGrammarStateFromMap(args[1]);
  }
  const [internal, code, options = {}] = args;
  const {
    lang = "text",
    theme: themeName = internal.getLoadedThemes()[0]
  } = options;
  if (isPlainLang(lang) || isNoneTheme(themeName))
    throw new ShikiError("Plain language does not have grammar state");
  if (lang === "ansi")
    throw new ShikiError("ANSI language does not have grammar state");
  const { theme, colorMap } = internal.setTheme(themeName);
  const _grammar = internal.getLanguage(lang);
  return new GrammarState(
    _tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack,
    _grammar.name,
    theme.name
  );
}
function tokenizeWithTheme(code, grammar, theme, colorMap, options) {
  const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);
  const grammarState = new GrammarState(
    _tokenizeWithTheme(code, grammar, theme, colorMap, options).stateStack,
    grammar.name,
    theme.name
  );
  setLastGrammarStateToMap(result.tokens, grammarState);
  return result.tokens;
}
function _tokenizeWithTheme(code, grammar, theme, colorMap, options) {
  const colorReplacements = resolveColorReplacements(theme, options);
  const {
    tokenizeMaxLineLength = 0,
    tokenizeTimeLimit = 500
  } = options;
  const lines = splitLines(code);
  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(
    options.grammarContextCode,
    grammar,
    theme,
    colorMap,
    {
      ...options,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : INITIAL;
  let actual = [];
  const final = [];
  for (let i = 0, len = lines.length; i < len; i++) {
    const [line, lineOffset] = lines[i];
    if (line === "") {
      actual = [];
      final.push([]);
      continue;
    }
    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {
      actual = [];
      final.push([{
        content: line,
        offset: lineOffset,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let resultWithScopes;
    let tokensWithScopes;
    let tokensWithScopesIndex;
    if (options.includeExplanation) {
      resultWithScopes = grammar.tokenizeLine(line, stateStack, tokenizeTimeLimit);
      tokensWithScopes = resultWithScopes.tokens;
      tokensWithScopesIndex = 0;
    }
    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);
    const tokensLength = result.tokens.length / 2;
    for (let j = 0; j < tokensLength; j++) {
      const startIndex = result.tokens[2 * j];
      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
      if (startIndex === nextStartIndex)
        continue;
      const metadata = result.tokens[2 * j + 1];
      const color = applyColorReplacements(
        colorMap[EncodedTokenMetadata.getForeground(metadata)],
        colorReplacements
      );
      const fontStyle = EncodedTokenMetadata.getFontStyle(metadata);
      const token = {
        content: line.substring(startIndex, nextStartIndex),
        offset: lineOffset + startIndex,
        color,
        fontStyle
      };
      if (options.includeExplanation) {
        const themeSettingsSelectors = [];
        if (options.includeExplanation !== "scopeName") {
          for (const setting of theme.settings) {
            let selectors;
            switch (typeof setting.scope) {
              case "string":
                selectors = setting.scope.split(/,/).map((scope) => scope.trim());
                break;
              case "object":
                selectors = setting.scope;
                break;
              default:
                continue;
            }
            themeSettingsSelectors.push({
              settings: setting,
              selectors: selectors.map((selector) => selector.split(/ /))
            });
          }
        }
        token.explanation = [];
        let offset = 0;
        while (startIndex + offset < nextStartIndex) {
          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
          const tokenWithScopesText = line.substring(
            tokenWithScopes.startIndex,
            tokenWithScopes.endIndex
          );
          offset += tokenWithScopesText.length;
          token.explanation.push({
            content: tokenWithScopesText,
            scopes: options.includeExplanation === "scopeName" ? explainThemeScopesNameOnly(
              tokenWithScopes.scopes
            ) : explainThemeScopesFull(
              themeSettingsSelectors,
              tokenWithScopes.scopes
            )
          });
          tokensWithScopesIndex += 1;
        }
      }
      actual.push(token);
    }
    final.push(actual);
    actual = [];
    stateStack = result.ruleStack;
  }
  return {
    tokens: final,
    stateStack
  };
}
function explainThemeScopesNameOnly(scopes) {
  return scopes.map((scope) => ({ scopeName: scope }));
}
function explainThemeScopesFull(themeSelectors, scopes) {
  const result = [];
  for (let i = 0, len = scopes.length; i < len; i++) {
    const scope = scopes[i];
    result[i] = {
      scopeName: scope,
      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))
    };
  }
  return result;
}
function matchesOne(selector, scope) {
  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === ".";
}
function matches(selectors, scope, parentScopes) {
  if (!matchesOne(selectors[selectors.length - 1], scope))
    return false;
  let selectorParentIndex = selectors.length - 2;
  let parentIndex = parentScopes.length - 1;
  while (selectorParentIndex >= 0 && parentIndex >= 0) {
    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))
      selectorParentIndex -= 1;
    parentIndex -= 1;
  }
  if (selectorParentIndex === -1)
    return true;
  return false;
}
function explainThemeScope(themeSettingsSelectors, scope, parentScopes) {
  const result = [];
  for (const { selectors, settings } of themeSettingsSelectors) {
    for (const selectorPieces of selectors) {
      if (matches(selectorPieces, scope, parentScopes)) {
        result.push(settings);
        break;
      }
    }
  }
  return result;
}
function codeToTokensWithThemes(internal, code, options) {
  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));
  const themedTokens = themes.map((t) => {
    const tokens2 = codeToTokensBase(internal, code, {
      ...options,
      theme: t.theme
    });
    const state = getLastGrammarStateFromMap(tokens2);
    const theme = typeof t.theme === "string" ? t.theme : t.theme.name;
    return {
      tokens: tokens2,
      state,
      theme
    };
  });
  const tokens = syncThemesTokenization(
    ...themedTokens.map((i) => i.tokens)
  );
  const mergedTokens = tokens[0].map(
    (line, lineIdx) => line.map((_token, tokenIdx) => {
      const mergedToken = {
        content: _token.content,
        variants: {},
        offset: _token.offset
      };
      if ("includeExplanation" in options && options.includeExplanation) {
        mergedToken.explanation = _token.explanation;
      }
      tokens.forEach((t, themeIdx) => {
        const {
          content: _,
          explanation: __,
          offset: ___,
          ...styles
        } = t[lineIdx][tokenIdx];
        mergedToken.variants[themes[themeIdx].color] = styles;
      });
      return mergedToken;
    })
  );
  const mergedGrammarState = themedTokens[0].state ? new GrammarState(
    Object.fromEntries(themedTokens.map((s) => [s.theme, s.state?.getInternalStack(s.theme)])),
    themedTokens[0].state.lang
  ) : void 0;
  if (mergedGrammarState)
    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);
  return mergedTokens;
}
function syncThemesTokenization(...themes) {
  const outThemes = themes.map(() => []);
  const count = themes.length;
  for (let i = 0; i < themes[0].length; i++) {
    const lines = themes.map((t) => t[i]);
    const outLines = outThemes.map(() => []);
    outThemes.forEach((t, i2) => t.push(outLines[i2]));
    const indexes = lines.map(() => 0);
    const current = lines.map((l) => l[0]);
    while (current.every((t) => t)) {
      const minLength = Math.min(...current.map((t) => t.content.length));
      for (let n = 0; n < count; n++) {
        const token = current[n];
        if (token.content.length === minLength) {
          outLines[n].push(token);
          indexes[n] += 1;
          current[n] = lines[n][indexes[n]];
        } else {
          outLines[n].push({
            ...token,
            content: token.content.slice(0, minLength)
          });
          current[n] = {
            ...token,
            content: token.content.slice(minLength),
            offset: token.offset + minLength
          };
        }
      }
    }
  }
  return outThemes;
}
function codeToTokens(internal, code, options) {
  let bg;
  let fg;
  let tokens;
  let themeName;
  let rootStyle;
  let grammarState;
  if ("themes" in options) {
    const {
      defaultColor = "light",
      cssVariablePrefix = "--shiki-",
      colorsRendering = "css-vars"
    } = options;
    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);
    if (themes.length === 0)
      throw new ShikiError("`themes` option must not be empty");
    const themeTokens = codeToTokensWithThemes(
      internal,
      code,
      options
    );
    grammarState = getLastGrammarStateFromMap(themeTokens);
    if (defaultColor && DEFAULT_COLOR_LIGHT_DARK !== defaultColor && !themes.find((t) => t.color === defaultColor))
      throw new ShikiError(`\`themes\` option must contain the defaultColor key \`${defaultColor}\``);
    const themeRegs = themes.map((t) => internal.getTheme(t.theme));
    const themesOrder = themes.map((t) => t.color);
    tokens = themeTokens.map((line) => line.map((token) => flatTokenVariants(token, themesOrder, cssVariablePrefix, defaultColor, colorsRendering)));
    if (grammarState)
      setLastGrammarStateToMap(tokens, grammarState);
    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));
    fg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, "fg", colorsRendering);
    bg = mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, "bg", colorsRendering);
    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(" ")}`;
    rootStyle = defaultColor ? void 0 : [fg, bg].join(";");
  } else if ("theme" in options) {
    const colorReplacements = resolveColorReplacements(options.theme, options);
    tokens = codeToTokensBase(
      internal,
      code,
      options
    );
    const _theme = internal.getTheme(options.theme);
    bg = applyColorReplacements(_theme.bg, colorReplacements);
    fg = applyColorReplacements(_theme.fg, colorReplacements);
    themeName = _theme.name;
    grammarState = getLastGrammarStateFromMap(tokens);
  } else {
    throw new ShikiError("Invalid options, either `theme` or `themes` must be provided");
  }
  return {
    tokens,
    fg,
    bg,
    themeName,
    rootStyle,
    grammarState
  };
}
function mapThemeColors(themes, themeRegs, themeColorReplacements, cssVariablePrefix, defaultColor, property, colorsRendering) {
  return themes.map((t, idx) => {
    const value = applyColorReplacements(themeRegs[idx][property], themeColorReplacements[idx]) || "inherit";
    const cssVar = `${cssVariablePrefix + t.color}${property === "bg" ? "-bg" : ""}:${value}`;
    if (idx === 0 && defaultColor) {
      if (defaultColor === DEFAULT_COLOR_LIGHT_DARK && themes.length > 1) {
        const lightIndex = themes.findIndex((t2) => t2.color === "light");
        const darkIndex = themes.findIndex((t2) => t2.color === "dark");
        if (lightIndex === -1 || darkIndex === -1)
          throw new ShikiError('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
        const lightValue = applyColorReplacements(themeRegs[lightIndex][property], themeColorReplacements[lightIndex]) || "inherit";
        const darkValue = applyColorReplacements(themeRegs[darkIndex][property], themeColorReplacements[darkIndex]) || "inherit";
        return `light-dark(${lightValue}, ${darkValue});${cssVar}`;
      }
      return value;
    }
    if (colorsRendering === "css-vars") {
      return cssVar;
    }
    return null;
  }).filter((i) => !!i).join(";");
}
function codeToHast(internal, code, options, transformerContext = {
  meta: {},
  options,
  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),
  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)
}) {
  let input = code;
  for (const transformer of getTransformers(options))
    input = transformer.preprocess?.call(transformerContext, input, options) || input;
  let {
    tokens,
    fg,
    bg,
    themeName,
    rootStyle,
    grammarState
  } = codeToTokens(internal, input, options);
  const {
    mergeWhitespaces = true,
    mergeSameStyleTokens = false
  } = options;
  if (mergeWhitespaces === true)
    tokens = mergeWhitespaceTokens(tokens);
  else if (mergeWhitespaces === "never")
    tokens = splitWhitespaceTokens(tokens);
  if (mergeSameStyleTokens) {
    tokens = mergeAdjacentStyledTokens(tokens);
  }
  const contextSource = {
    ...transformerContext,
    get source() {
      return input;
    }
  };
  for (const transformer of getTransformers(options))
    tokens = transformer.tokens?.call(contextSource, tokens) || tokens;
  return tokensToHast(
    tokens,
    {
      ...options,
      fg,
      bg,
      themeName,
      rootStyle
    },
    contextSource,
    grammarState
  );
}
function tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {
  const transformers = getTransformers(options);
  const lines = [];
  const root = {
    type: "root",
    children: []
  };
  const {
    structure = "classic",
    tabindex = "0"
  } = options;
  let preNode = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${options.themeName || ""}`,
      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,
      ...tabindex !== false && tabindex != null ? {
        tabindex: tabindex.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(options.meta || {})
        ).filter(([key]) => !key.startsWith("_"))
      )
    },
    children: []
  };
  let codeNode = {
    type: "element",
    tagName: "code",
    properties: {},
    children: lines
  };
  const lineNodes = [];
  const context = {
    ...transformerContext,
    structure,
    addClassToHast,
    get source() {
      return transformerContext.source;
    },
    get tokens() {
      return tokens;
    },
    get options() {
      return options;
    },
    get root() {
      return root;
    },
    get pre() {
      return preNode;
    },
    get code() {
      return codeNode;
    },
    get lines() {
      return lineNodes;
    }
  };
  tokens.forEach((line, idx) => {
    if (idx) {
      if (structure === "inline")
        root.children.push({ type: "element", tagName: "br", properties: {}, children: [] });
      else if (structure === "classic")
        lines.push({ type: "text", value: "\n" });
    }
    let lineNode = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    };
    let col = 0;
    for (const token of line) {
      let tokenNode = {
        type: "element",
        tagName: "span",
        properties: {
          ...token.htmlAttrs
        },
        children: [{ type: "text", value: token.content }]
      };
      const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));
      if (style)
        tokenNode.properties.style = style;
      for (const transformer of transformers)
        tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;
      if (structure === "inline")
        root.children.push(tokenNode);
      else if (structure === "classic")
        lineNode.children.push(tokenNode);
      col += token.content.length;
    }
    if (structure === "classic") {
      for (const transformer of transformers)
        lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;
      lineNodes.push(lineNode);
      lines.push(lineNode);
    }
  });
  if (structure === "classic") {
    for (const transformer of transformers)
      codeNode = transformer?.code?.call(context, codeNode) || codeNode;
    preNode.children.push(codeNode);
    for (const transformer of transformers)
      preNode = transformer?.pre?.call(context, preNode) || preNode;
    root.children.push(preNode);
  }
  let result = root;
  for (const transformer of transformers)
    result = transformer?.root?.call(context, result) || result;
  if (grammarState)
    setLastGrammarStateToMap(result, grammarState);
  return result;
}
function mergeWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    const newLine = [];
    let carryOnContent = "";
    let firstOffset = 0;
    line.forEach((token, idx) => {
      const isDecorated = token.fontStyle && (token.fontStyle & FontStyle.Underline || token.fontStyle & FontStyle.Strikethrough);
      const couldMerge = !isDecorated;
      if (couldMerge && token.content.match(/^\s+$/) && line[idx + 1]) {
        if (!firstOffset)
          firstOffset = token.offset;
        carryOnContent += token.content;
      } else {
        if (carryOnContent) {
          if (couldMerge) {
            newLine.push({
              ...token,
              offset: firstOffset,
              content: carryOnContent + token.content
            });
          } else {
            newLine.push(
              {
                content: carryOnContent,
                offset: firstOffset
              },
              token
            );
          }
          firstOffset = 0;
          carryOnContent = "";
        } else {
          newLine.push(token);
        }
      }
    });
    return newLine;
  });
}
function splitWhitespaceTokens(tokens) {
  return tokens.map((line) => {
    return line.flatMap((token) => {
      if (token.content.match(/^\s+$/))
        return token;
      const match = token.content.match(/^(\s*)(.*?)(\s*)$/);
      if (!match)
        return token;
      const [, leading, content, trailing] = match;
      if (!leading && !trailing)
        return token;
      const expanded = [{
        ...token,
        offset: token.offset + leading.length,
        content
      }];
      if (leading) {
        expanded.unshift({
          content: leading,
          offset: token.offset
        });
      }
      if (trailing) {
        expanded.push({
          content: trailing,
          offset: token.offset + leading.length + content.length
        });
      }
      return expanded;
    });
  });
}
function mergeAdjacentStyledTokens(tokens) {
  return tokens.map((line) => {
    const newLine = [];
    for (const token of line) {
      if (newLine.length === 0) {
        newLine.push({ ...token });
        continue;
      }
      const prevToken = newLine[newLine.length - 1];
      const prevStyle = stringifyTokenStyle(prevToken.htmlStyle || getTokenStyleObject(prevToken));
      const currentStyle = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));
      const isPrevDecorated = prevToken.fontStyle && (prevToken.fontStyle & FontStyle.Underline || prevToken.fontStyle & FontStyle.Strikethrough);
      const isDecorated = token.fontStyle && (token.fontStyle & FontStyle.Underline || token.fontStyle & FontStyle.Strikethrough);
      if (!isPrevDecorated && !isDecorated && prevStyle === currentStyle) {
        prevToken.content += token.content;
      } else {
        newLine.push({ ...token });
      }
    }
    return newLine;
  });
}
var hastToHtml = toHtml;
function codeToHtml(internal, code, options) {
  const context = {
    meta: {},
    options,
    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),
    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)
  };
  let result = hastToHtml(codeToHast(internal, code, options, context));
  for (const transformer of getTransformers(options))
    result = transformer.postprocess?.call(context, result, options) || result;
  return result;
}
var VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
var VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
var RESOLVED_KEY = "__shiki_resolved";
function normalizeTheme(rawTheme) {
  if (rawTheme?.[RESOLVED_KEY])
    return rawTheme;
  const theme = {
    ...rawTheme
  };
  if (theme.tokenColors && !theme.settings) {
    theme.settings = theme.tokenColors;
    delete theme.tokenColors;
  }
  theme.type ||= "dark";
  theme.colorReplacements = { ...theme.colorReplacements };
  theme.settings ||= [];
  let { bg, fg } = theme;
  if (!bg || !fg) {
    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;
    if (globalSetting?.settings?.foreground)
      fg = globalSetting.settings.foreground;
    if (globalSetting?.settings?.background)
      bg = globalSetting.settings.background;
    if (!fg && theme?.colors?.["editor.foreground"])
      fg = theme.colors["editor.foreground"];
    if (!bg && theme?.colors?.["editor.background"])
      bg = theme.colors["editor.background"];
    if (!fg)
      fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
    if (!bg)
      bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
    theme.fg = fg;
    theme.bg = bg;
  }
  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {
    theme.settings.unshift({
      settings: {
        foreground: theme.fg,
        background: theme.bg
      }
    });
  }
  let replacementCount = 0;
  const replacementMap = /* @__PURE__ */ new Map();
  function getReplacementColor(value) {
    if (replacementMap.has(value))
      return replacementMap.get(value);
    replacementCount += 1;
    const hex = `#${replacementCount.toString(16).padStart(8, "0").toLowerCase()}`;
    if (theme.colorReplacements?.[`#${hex}`])
      return getReplacementColor(value);
    replacementMap.set(value, hex);
    return hex;
  }
  theme.settings = theme.settings.map((setting) => {
    const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith("#");
    const replaceBg = setting.settings?.background && !setting.settings.background.startsWith("#");
    if (!replaceFg && !replaceBg)
      return setting;
    const clone = {
      ...setting,
      settings: {
        ...setting.settings
      }
    };
    if (replaceFg) {
      const replacement = getReplacementColor(setting.settings.foreground);
      theme.colorReplacements[replacement] = setting.settings.foreground;
      clone.settings.foreground = replacement;
    }
    if (replaceBg) {
      const replacement = getReplacementColor(setting.settings.background);
      theme.colorReplacements[replacement] = setting.settings.background;
      clone.settings.background = replacement;
    }
    return clone;
  });
  for (const key of Object.keys(theme.colors || {})) {
    if (key === "editor.foreground" || key === "editor.background" || key.startsWith("terminal.ansi")) {
      if (!theme.colors[key]?.startsWith("#")) {
        const replacement = getReplacementColor(theme.colors[key]);
        theme.colorReplacements[replacement] = theme.colors[key];
        theme.colors[key] = replacement;
      }
    }
  }
  Object.defineProperty(theme, RESOLVED_KEY, {
    enumerable: false,
    writable: false,
    value: true
  });
  return theme;
}
async function resolveLangs(langs) {
  return Array.from(new Set((await Promise.all(
    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))
  )).flat()));
}
async function resolveThemes(themes) {
  const resolved = await Promise.all(
    themes.map(
      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))
    )
  );
  return resolved.filter((i) => !!i);
}
var _emitDeprecation = 3;
var _emitError = false;
function warnDeprecated(message, version = 3) {
  if (!_emitDeprecation)
    return;
  if (typeof _emitDeprecation === "number" && version > _emitDeprecation)
    return;
  if (_emitError) {
    throw new Error(`[SHIKI DEPRECATE]: ${message}`);
  } else {
    console.trace(`[SHIKI DEPRECATE]: ${message}`);
  }
}
var ShikiError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};
var Registry2 = class extends Registry {
  constructor(_resolver, _themes, _langs, _alias = {}) {
    super(_resolver);
    this._resolver = _resolver;
    this._themes = _themes;
    this._langs = _langs;
    this._alias = _alias;
    this._themes.map((t) => this.loadTheme(t));
    this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(theme) {
    if (typeof theme === "string")
      return this._resolvedThemes.get(theme);
    else
      return this.loadTheme(theme);
  }
  loadTheme(theme) {
    const _theme = normalizeTheme(theme);
    if (_theme.name) {
      this._resolvedThemes.set(_theme.name, _theme);
      this._loadedThemesCache = null;
    }
    return _theme;
  }
  getLoadedThemes() {
    if (!this._loadedThemesCache)
      this._loadedThemesCache = [...this._resolvedThemes.keys()];
    return this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(theme) {
    let textmateTheme = this._textmateThemeCache.get(theme);
    if (!textmateTheme) {
      textmateTheme = Theme.createFromRawTheme(theme);
      this._textmateThemeCache.set(theme, textmateTheme);
    }
    this._syncRegistry.setTheme(textmateTheme);
  }
  getGrammar(name) {
    if (this._alias[name]) {
      const resolved = /* @__PURE__ */ new Set([name]);
      while (this._alias[name]) {
        name = this._alias[name];
        if (resolved.has(name))
          throw new ShikiError2(`Circular alias \`${Array.from(resolved).join(" -> ")} -> ${name}\``);
        resolved.add(name);
      }
    }
    return this._resolvedGrammars.get(name);
  }
  loadLanguage(lang) {
    if (this.getGrammar(lang.name))
      return;
    const embeddedLazilyBy = new Set(
      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(lang.name))
    );
    this._resolver.addLanguage(lang);
    const grammarConfig = {
      balancedBracketSelectors: lang.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);
    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);
    g.name = lang.name;
    this._resolvedGrammars.set(lang.name, g);
    if (lang.aliases) {
      lang.aliases.forEach((alias) => {
        this._alias[alias] = lang.name;
      });
    }
    this._loadedLanguagesCache = null;
    if (embeddedLazilyBy.size) {
      for (const e of embeddedLazilyBy) {
        this._resolvedGrammars.delete(e.name);
        this._loadedLanguagesCache = null;
        this._syncRegistry?._injectionGrammars?.delete(e.scopeName);
        this._syncRegistry?._grammars?.delete(e.scopeName);
        this.loadLanguage(this._langMap.get(e.name));
      }
    }
  }
  dispose() {
    super.dispose();
    this._resolvedThemes.clear();
    this._resolvedGrammars.clear();
    this._langMap.clear();
    this._langGraph.clear();
    this._loadedThemesCache = null;
  }
  loadLanguages(langs) {
    for (const lang of langs)
      this.resolveEmbeddedLanguages(lang);
    const langsGraphArray = Array.from(this._langGraph.entries());
    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);
    if (missingLangs.length) {
      const dependents = langsGraphArray.filter(([_, lang]) => lang && lang.embeddedLangs?.some((l) => missingLangs.map(([name]) => name).includes(l))).filter((lang) => !missingLangs.includes(lang));
      throw new ShikiError2(`Missing languages ${missingLangs.map(([name]) => `\`${name}\``).join(", ")}, required by ${dependents.map(([name]) => `\`${name}\``).join(", ")}`);
    }
    for (const [_, lang] of langsGraphArray)
      this._resolver.addLanguage(lang);
    for (const [_, lang] of langsGraphArray)
      this.loadLanguage(lang);
  }
  getLoadedLanguages() {
    if (!this._loadedLanguagesCache) {
      this._loadedLanguagesCache = [
        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
      ];
    }
    return this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(lang) {
    this._langMap.set(lang.name, lang);
    this._langGraph.set(lang.name, lang);
    if (lang.embeddedLangs) {
      for (const embeddedLang of lang.embeddedLangs)
        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));
    }
  }
};
var Resolver = class {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(engine, langs) {
    this._onigLib = {
      createOnigScanner: (patterns) => engine.createScanner(patterns),
      createOnigString: (s) => engine.createString(s)
    };
    langs.forEach((i) => this.addLanguage(i));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(langIdOrAlias) {
    return this._langs.get(langIdOrAlias);
  }
  loadGrammar(scopeName) {
    return this._scopeToLang.get(scopeName);
  }
  addLanguage(l) {
    this._langs.set(l.name, l);
    if (l.aliases) {
      l.aliases.forEach((a) => {
        this._langs.set(a, l);
      });
    }
    this._scopeToLang.set(l.scopeName, l);
    if (l.injectTo) {
      l.injectTo.forEach((i) => {
        if (!this._injections.get(i))
          this._injections.set(i, []);
        this._injections.get(i).push(l.scopeName);
      });
    }
  }
  getInjections(scopeName) {
    const scopeParts = scopeName.split(".");
    let injections = [];
    for (let i = 1; i <= scopeParts.length; i++) {
      const subScopeName = scopeParts.slice(0, i).join(".");
      injections = [...injections, ...this._injections.get(subScopeName) || []];
    }
    return injections;
  }
};
var instancesCount = 0;
function createShikiInternalSync(options) {
  instancesCount += 1;
  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)
    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let isDisposed = false;
  if (!options.engine)
    throw new ShikiError2("`engine` option is required for synchronous mode");
  const langs = (options.langs || []).flat(1);
  const themes = (options.themes || []).flat(1).map(normalizeTheme);
  const resolver = new Resolver(options.engine, langs);
  const _registry = new Registry2(resolver, themes, langs, options.langAlias);
  let _lastTheme;
  function getLanguage(name) {
    ensureNotDisposed();
    const _lang = _registry.getGrammar(typeof name === "string" ? name : name.name);
    if (!_lang)
      throw new ShikiError2(`Language \`${name}\` not found, you may need to load it first`);
    return _lang;
  }
  function getTheme(name) {
    if (name === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    ensureNotDisposed();
    const _theme = _registry.getTheme(name);
    if (!_theme)
      throw new ShikiError2(`Theme \`${name}\` not found, you may need to load it first`);
    return _theme;
  }
  function setTheme(name) {
    ensureNotDisposed();
    const theme = getTheme(name);
    if (_lastTheme !== name) {
      _registry.setTheme(theme);
      _lastTheme = name;
    }
    const colorMap = _registry.getColorMap();
    return {
      theme,
      colorMap
    };
  }
  function getLoadedThemes() {
    ensureNotDisposed();
    return _registry.getLoadedThemes();
  }
  function getLoadedLanguages() {
    ensureNotDisposed();
    return _registry.getLoadedLanguages();
  }
  function loadLanguageSync(...langs2) {
    ensureNotDisposed();
    _registry.loadLanguages(langs2.flat(1));
  }
  async function loadLanguage(...langs2) {
    return loadLanguageSync(await resolveLangs(langs2));
  }
  function loadThemeSync(...themes2) {
    ensureNotDisposed();
    for (const theme of themes2.flat(1)) {
      _registry.loadTheme(theme);
    }
  }
  async function loadTheme(...themes2) {
    ensureNotDisposed();
    return loadThemeSync(await resolveThemes(themes2));
  }
  function ensureNotDisposed() {
    if (isDisposed)
      throw new ShikiError2("Shiki instance has been disposed");
  }
  function dispose() {
    if (isDisposed)
      return;
    isDisposed = true;
    _registry.dispose();
    instancesCount -= 1;
  }
  return {
    setTheme,
    getTheme,
    getLanguage,
    getLoadedThemes,
    getLoadedLanguages,
    loadLanguage,
    loadLanguageSync,
    loadTheme,
    loadThemeSync,
    dispose,
    [Symbol.dispose]: dispose
  };
}
async function createShikiInternal(options) {
  if (!options.engine) {
    warnDeprecated("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
  }
  const [
    themes,
    langs,
    engine
  ] = await Promise.all([
    resolveThemes(options.themes || []),
    resolveLangs(options.langs || []),
    options.engine
  ]);
  return createShikiInternalSync({
    ...options,
    themes,
    langs,
    engine
  });
}
async function createHighlighterCore(options) {
  const internal = await createShikiInternal(options);
  return {
    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),
    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),
    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),
    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),
    codeToHast: (code, options2) => codeToHast(internal, code, options2),
    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),
    getBundledLanguages: () => ({}),
    getBundledThemes: () => ({}),
    ...internal,
    getInternalContext: () => internal
  };
}
function makeSingletonHighlighterCore(createHighlighter2) {
  let _shiki;
  async function getSingletonHighlighterCore2(options) {
    if (!_shiki) {
      _shiki = createHighlighter2({
        ...options,
        themes: options.themes || [],
        langs: options.langs || []
      });
      return _shiki;
    } else {
      const s = await _shiki;
      await Promise.all([
        s.loadTheme(...options.themes || []),
        s.loadLanguage(...options.langs || [])
      ]);
      return s;
    }
  }
  return getSingletonHighlighterCore2;
}
var getSingletonHighlighterCore = makeSingletonHighlighterCore(createHighlighterCore);
function createdBundledHighlighter(options) {
  const bundledLanguages2 = options.langs;
  const bundledThemes2 = options.themes;
  const engine = options.engine;
  async function createHighlighter2(options2) {
    function resolveLang(lang) {
      if (typeof lang === "string") {
        if (isSpecialLang(lang))
          return [];
        lang = options2.langAlias?.[lang] || lang;
        const bundle = bundledLanguages2[lang];
        if (!bundle)
          throw new ShikiError(`Language \`${lang}\` is not included in this bundle. You may want to load it from external source.`);
        return bundle;
      }
      return lang;
    }
    function resolveTheme(theme) {
      if (isSpecialTheme(theme))
        return "none";
      if (typeof theme === "string") {
        const bundle = bundledThemes2[theme];
        if (!bundle)
          throw new ShikiError(`Theme \`${theme}\` is not included in this bundle. You may want to load it from external source.`);
        return bundle;
      }
      return theme;
    }
    const _themes = (options2.themes ?? []).map((i) => resolveTheme(i));
    const langs = (options2.langs ?? []).map((i) => resolveLang(i));
    const core = await createHighlighterCore({
      engine: options2.engine ?? engine(),
      ...options2,
      themes: _themes,
      langs
    });
    return {
      ...core,
      loadLanguage(...langs2) {
        return core.loadLanguage(...langs2.map(resolveLang));
      },
      loadTheme(...themes) {
        return core.loadTheme(...themes.map(resolveTheme));
      },
      getBundledLanguages() {
        return bundledLanguages2;
      },
      getBundledThemes() {
        return bundledThemes2;
      }
    };
  }
  return createHighlighter2;
}
function makeSingletonHighlighter(createHighlighter2) {
  let _shiki;
  async function getSingletonHighlighter2(options = {}) {
    if (!_shiki) {
      _shiki = createHighlighter2({
        ...options,
        themes: options.themes || [],
        langs: options.langs || []
      });
      return _shiki;
    } else {
      const s = await _shiki;
      await Promise.all([
        s.loadTheme(...options.themes || []),
        s.loadLanguage(...options.langs || [])
      ]);
      return s;
    }
  }
  return getSingletonHighlighter2;
}
function createSingletonShorthands(createHighlighter2, config) {
  const getSingletonHighlighter2 = makeSingletonHighlighter(createHighlighter2);
  async function get(code, options) {
    const shiki = await getSingletonHighlighter2({
      langs: [options.lang],
      themes: "theme" in options ? [options.theme] : Object.values(options.themes)
    });
    const langs = await config?.guessEmbeddedLanguages?.(code, options.lang, shiki);
    if (langs) {
      await shiki.loadLanguage(...langs);
    }
    return shiki;
  }
  return {
    getSingletonHighlighter(options) {
      return getSingletonHighlighter2(options);
    },
    async codeToHtml(code, options) {
      const shiki = await get(code, options);
      return shiki.codeToHtml(code, options);
    },
    async codeToHast(code, options) {
      const shiki = await get(code, options);
      return shiki.codeToHast(code, options);
    },
    async codeToTokens(code, options) {
      const shiki = await get(code, options);
      return shiki.codeToTokens(code, options);
    },
    async codeToTokensBase(code, options) {
      const shiki = await get(code, options);
      return shiki.codeToTokensBase(code, options);
    },
    async codeToTokensWithThemes(code, options) {
      const shiki = await get(code, options);
      return shiki.codeToTokensWithThemes(code, options);
    },
    async getLastGrammarState(code, options) {
      const shiki = await getSingletonHighlighter2({
        langs: [options.lang],
        themes: [options.theme]
      });
      return shiki.getLastGrammarState(code, options);
    }
  };
}

// node_modules/@pierre/precision-diffs/node_modules/shiki/dist/langs.mjs
var bundledLanguagesInfo = [
  {
    "id": "abap",
    "name": "ABAP",
    "import": (() => import("./abap-HUL4O2BS.js"))
  },
  {
    "id": "actionscript-3",
    "name": "ActionScript",
    "import": (() => import("./actionscript-3-MKU7DDTZ.js"))
  },
  {
    "id": "ada",
    "name": "Ada",
    "import": (() => import("./ada-HCKLR6V7.js"))
  },
  {
    "id": "angular-html",
    "name": "Angular HTML",
    "import": (() => import("./angular-html-VLA2PL2R.js"))
  },
  {
    "id": "angular-ts",
    "name": "Angular TypeScript",
    "import": (() => import("./angular-ts-KR7DM2RL.js"))
  },
  {
    "id": "apache",
    "name": "Apache Conf",
    "import": (() => import("./apache-4LSYNBVM.js"))
  },
  {
    "id": "apex",
    "name": "Apex",
    "import": (() => import("./apex-3PADDXJR.js"))
  },
  {
    "id": "apl",
    "name": "APL",
    "import": (() => import("./apl-T7NLBNBJ.js"))
  },
  {
    "id": "applescript",
    "name": "AppleScript",
    "import": (() => import("./applescript-JILMQZ2L.js"))
  },
  {
    "id": "ara",
    "name": "Ara",
    "import": (() => import("./ara-ZVHQLTRR.js"))
  },
  {
    "id": "asciidoc",
    "name": "AsciiDoc",
    "aliases": [
      "adoc"
    ],
    "import": (() => import("./asciidoc-XNMIQNGW.js"))
  },
  {
    "id": "asm",
    "name": "Assembly",
    "import": (() => import("./asm-7IZHMETS.js"))
  },
  {
    "id": "astro",
    "name": "Astro",
    "import": (() => import("./astro-WUFF36KL.js"))
  },
  {
    "id": "awk",
    "name": "AWK",
    "import": (() => import("./awk-IFANVJFC.js"))
  },
  {
    "id": "ballerina",
    "name": "Ballerina",
    "import": (() => import("./ballerina-DWRAWXOT.js"))
  },
  {
    "id": "bat",
    "name": "Batch File",
    "aliases": [
      "batch"
    ],
    "import": (() => import("./bat-MHYWOBHS.js"))
  },
  {
    "id": "beancount",
    "name": "Beancount",
    "import": (() => import("./beancount-OUS4WDIW.js"))
  },
  {
    "id": "berry",
    "name": "Berry",
    "aliases": [
      "be"
    ],
    "import": (() => import("./berry-5DTO3FYE.js"))
  },
  {
    "id": "bibtex",
    "name": "BibTeX",
    "import": (() => import("./bibtex-Z4QHTNTQ.js"))
  },
  {
    "id": "bicep",
    "name": "Bicep",
    "import": (() => import("./bicep-TIBPHBPJ.js"))
  },
  {
    "id": "blade",
    "name": "Blade",
    "import": (() => import("./blade-74JY65D6.js"))
  },
  {
    "id": "bsl",
    "name": "1C (Enterprise)",
    "aliases": [
      "1c"
    ],
    "import": (() => import("./bsl-DKSQM23Y.js"))
  },
  {
    "id": "c",
    "name": "C",
    "import": (() => import("./c-YFQKFW56.js"))
  },
  {
    "id": "cadence",
    "name": "Cadence",
    "aliases": [
      "cdc"
    ],
    "import": (() => import("./cadence-QJAXKXNU.js"))
  },
  {
    "id": "cairo",
    "name": "Cairo",
    "import": (() => import("./cairo-BGBUMFTO.js"))
  },
  {
    "id": "clarity",
    "name": "Clarity",
    "import": (() => import("./clarity-QBTS6XTO.js"))
  },
  {
    "id": "clojure",
    "name": "Clojure",
    "aliases": [
      "clj"
    ],
    "import": (() => import("./clojure-V3VXKNXE.js"))
  },
  {
    "id": "cmake",
    "name": "CMake",
    "import": (() => import("./cmake-FVO3AYD5.js"))
  },
  {
    "id": "cobol",
    "name": "COBOL",
    "import": (() => import("./cobol-PGCLC5LO.js"))
  },
  {
    "id": "codeowners",
    "name": "CODEOWNERS",
    "import": (() => import("./codeowners-JJLSTAMS.js"))
  },
  {
    "id": "codeql",
    "name": "CodeQL",
    "aliases": [
      "ql"
    ],
    "import": (() => import("./codeql-V6WKX6G3.js"))
  },
  {
    "id": "coffee",
    "name": "CoffeeScript",
    "aliases": [
      "coffeescript"
    ],
    "import": (() => import("./coffee-K3YRBGGG.js"))
  },
  {
    "id": "common-lisp",
    "name": "Common Lisp",
    "aliases": [
      "lisp"
    ],
    "import": (() => import("./common-lisp-LR5FVPAO.js"))
  },
  {
    "id": "coq",
    "name": "Coq",
    "import": (() => import("./coq-VMWDFZC3.js"))
  },
  {
    "id": "cpp",
    "name": "C++",
    "aliases": [
      "c++"
    ],
    "import": (() => import("./cpp-XCQF7BHD.js"))
  },
  {
    "id": "crystal",
    "name": "Crystal",
    "import": (() => import("./crystal-KCDUNZDP.js"))
  },
  {
    "id": "csharp",
    "name": "C#",
    "aliases": [
      "c#",
      "cs"
    ],
    "import": (() => import("./csharp-KSD57EON.js"))
  },
  {
    "id": "css",
    "name": "CSS",
    "import": (() => import("./css-XCHNJJ4M.js"))
  },
  {
    "id": "csv",
    "name": "CSV",
    "import": (() => import("./csv-P3TM2KEJ.js"))
  },
  {
    "id": "cue",
    "name": "CUE",
    "import": (() => import("./cue-3MBI5U2A.js"))
  },
  {
    "id": "cypher",
    "name": "Cypher",
    "aliases": [
      "cql"
    ],
    "import": (() => import("./cypher-SGN2SWYN.js"))
  },
  {
    "id": "d",
    "name": "D",
    "import": (() => import("./d-PLEE6T57.js"))
  },
  {
    "id": "dart",
    "name": "Dart",
    "import": (() => import("./dart-B4PLTR42.js"))
  },
  {
    "id": "dax",
    "name": "DAX",
    "import": (() => import("./dax-4ZSEYQED.js"))
  },
  {
    "id": "desktop",
    "name": "Desktop",
    "import": (() => import("./desktop-5BFX7HH5.js"))
  },
  {
    "id": "diff",
    "name": "Diff",
    "import": (() => import("./diff-BXRXE6SX.js"))
  },
  {
    "id": "docker",
    "name": "Dockerfile",
    "aliases": [
      "dockerfile"
    ],
    "import": (() => import("./docker-63SYLEE3.js"))
  },
  {
    "id": "dotenv",
    "name": "dotEnv",
    "import": (() => import("./dotenv-EOBPIPJQ.js"))
  },
  {
    "id": "dream-maker",
    "name": "Dream Maker",
    "import": (() => import("./dream-maker-BJQBC5FW.js"))
  },
  {
    "id": "edge",
    "name": "Edge",
    "import": (() => import("./edge-2RWLFBXD.js"))
  },
  {
    "id": "elixir",
    "name": "Elixir",
    "import": (() => import("./elixir-ZPGAU7LO.js"))
  },
  {
    "id": "elm",
    "name": "Elm",
    "import": (() => import("./elm-HSDBEGTK.js"))
  },
  {
    "id": "emacs-lisp",
    "name": "Emacs Lisp",
    "aliases": [
      "elisp"
    ],
    "import": (() => import("./emacs-lisp-NFCIETJ6.js"))
  },
  {
    "id": "erb",
    "name": "ERB",
    "import": (() => import("./erb-D2NADTRW.js"))
  },
  {
    "id": "erlang",
    "name": "Erlang",
    "aliases": [
      "erl"
    ],
    "import": (() => import("./erlang-GHMFXV2A.js"))
  },
  {
    "id": "fennel",
    "name": "Fennel",
    "import": (() => import("./fennel-R2NDU535.js"))
  },
  {
    "id": "fish",
    "name": "Fish",
    "import": (() => import("./fish-QFQ3UNLF.js"))
  },
  {
    "id": "fluent",
    "name": "Fluent",
    "aliases": [
      "ftl"
    ],
    "import": (() => import("./fluent-AXQZNKFH.js"))
  },
  {
    "id": "fortran-fixed-form",
    "name": "Fortran (Fixed Form)",
    "aliases": [
      "f",
      "for",
      "f77"
    ],
    "import": (() => import("./fortran-fixed-form-ME7QKLT7.js"))
  },
  {
    "id": "fortran-free-form",
    "name": "Fortran (Free Form)",
    "aliases": [
      "f90",
      "f95",
      "f03",
      "f08",
      "f18"
    ],
    "import": (() => import("./fortran-free-form-LJUY7J4Q.js"))
  },
  {
    "id": "fsharp",
    "name": "F#",
    "aliases": [
      "f#",
      "fs"
    ],
    "import": (() => import("./fsharp-RRG34PPN.js"))
  },
  {
    "id": "gdresource",
    "name": "GDResource",
    "import": (() => import("./gdresource-L427VBWX.js"))
  },
  {
    "id": "gdscript",
    "name": "GDScript",
    "import": (() => import("./gdscript-WFAHCOUQ.js"))
  },
  {
    "id": "gdshader",
    "name": "GDShader",
    "import": (() => import("./gdshader-E5ZXLLT7.js"))
  },
  {
    "id": "genie",
    "name": "Genie",
    "import": (() => import("./genie-24BOABAN.js"))
  },
  {
    "id": "gherkin",
    "name": "Gherkin",
    "import": (() => import("./gherkin-GXNXKHAT.js"))
  },
  {
    "id": "git-commit",
    "name": "Git Commit Message",
    "import": (() => import("./git-commit-OQOCCHL4.js"))
  },
  {
    "id": "git-rebase",
    "name": "Git Rebase Message",
    "import": (() => import("./git-rebase-VKWZRP3O.js"))
  },
  {
    "id": "gleam",
    "name": "Gleam",
    "import": (() => import("./gleam-VCGLKGAE.js"))
  },
  {
    "id": "glimmer-js",
    "name": "Glimmer JS",
    "aliases": [
      "gjs"
    ],
    "import": (() => import("./glimmer-js-JOSWTAAL.js"))
  },
  {
    "id": "glimmer-ts",
    "name": "Glimmer TS",
    "aliases": [
      "gts"
    ],
    "import": (() => import("./glimmer-ts-ISQ7ZSAL.js"))
  },
  {
    "id": "glsl",
    "name": "GLSL",
    "import": (() => import("./glsl-O4WWHEX3.js"))
  },
  {
    "id": "gnuplot",
    "name": "Gnuplot",
    "import": (() => import("./gnuplot-2YPHKRNE.js"))
  },
  {
    "id": "go",
    "name": "Go",
    "import": (() => import("./go-5NVQGCNY.js"))
  },
  {
    "id": "graphql",
    "name": "GraphQL",
    "aliases": [
      "gql"
    ],
    "import": (() => import("./graphql-LAWDJUVI.js"))
  },
  {
    "id": "groovy",
    "name": "Groovy",
    "import": (() => import("./groovy-U2JHIE2Q.js"))
  },
  {
    "id": "hack",
    "name": "Hack",
    "import": (() => import("./hack-MT4PPJTH.js"))
  },
  {
    "id": "haml",
    "name": "Ruby Haml",
    "import": (() => import("./haml-V7LK3RSY.js"))
  },
  {
    "id": "handlebars",
    "name": "Handlebars",
    "aliases": [
      "hbs"
    ],
    "import": (() => import("./handlebars-X43GG54U.js"))
  },
  {
    "id": "haskell",
    "name": "Haskell",
    "aliases": [
      "hs"
    ],
    "import": (() => import("./haskell-Z4ETPV57.js"))
  },
  {
    "id": "haxe",
    "name": "Haxe",
    "import": (() => import("./haxe-VZFY6LPH.js"))
  },
  {
    "id": "hcl",
    "name": "HashiCorp HCL",
    "import": (() => import("./hcl-IPMXD2UL.js"))
  },
  {
    "id": "hjson",
    "name": "Hjson",
    "import": (() => import("./hjson-IYSD532K.js"))
  },
  {
    "id": "hlsl",
    "name": "HLSL",
    "import": (() => import("./hlsl-25MPLXCD.js"))
  },
  {
    "id": "html",
    "name": "HTML",
    "import": (() => import("./html-5CC4767C.js"))
  },
  {
    "id": "html-derivative",
    "name": "HTML (Derivative)",
    "import": (() => import("./html-derivative-W2BROVTP.js"))
  },
  {
    "id": "http",
    "name": "HTTP",
    "import": (() => import("./http-CJIOFNBE.js"))
  },
  {
    "id": "hurl",
    "name": "Hurl",
    "import": (() => import("./hurl-4MXXTH4W.js"))
  },
  {
    "id": "hxml",
    "name": "HXML",
    "import": (() => import("./hxml-BQ6SIOAM.js"))
  },
  {
    "id": "hy",
    "name": "Hy",
    "import": (() => import("./hy-IEBRKB2L.js"))
  },
  {
    "id": "imba",
    "name": "Imba",
    "import": (() => import("./imba-VMOPQCXH.js"))
  },
  {
    "id": "ini",
    "name": "INI",
    "aliases": [
      "properties"
    ],
    "import": (() => import("./ini-UUQR2QOY.js"))
  },
  {
    "id": "java",
    "name": "Java",
    "import": (() => import("./java-IHOTTXEK.js"))
  },
  {
    "id": "javascript",
    "name": "JavaScript",
    "aliases": [
      "js",
      "cjs",
      "mjs"
    ],
    "import": (() => import("./javascript-WDQPY6MG.js"))
  },
  {
    "id": "jinja",
    "name": "Jinja",
    "import": (() => import("./jinja-ZJ3EJ76A.js"))
  },
  {
    "id": "jison",
    "name": "Jison",
    "import": (() => import("./jison-ZMQUQ5RO.js"))
  },
  {
    "id": "json",
    "name": "JSON",
    "import": (() => import("./json-QHOP4S26.js"))
  },
  {
    "id": "json5",
    "name": "JSON5",
    "import": (() => import("./json5-MABNIUWO.js"))
  },
  {
    "id": "jsonc",
    "name": "JSON with Comments",
    "import": (() => import("./jsonc-3NXUOST4.js"))
  },
  {
    "id": "jsonl",
    "name": "JSON Lines",
    "import": (() => import("./jsonl-4YZJ3OF4.js"))
  },
  {
    "id": "jsonnet",
    "name": "Jsonnet",
    "import": (() => import("./jsonnet-P2X5NKDX.js"))
  },
  {
    "id": "jssm",
    "name": "JSSM",
    "aliases": [
      "fsl"
    ],
    "import": (() => import("./jssm-ZYX6EJJK.js"))
  },
  {
    "id": "jsx",
    "name": "JSX",
    "import": (() => import("./jsx-XTRQ2DJV.js"))
  },
  {
    "id": "julia",
    "name": "Julia",
    "aliases": [
      "jl"
    ],
    "import": (() => import("./julia-5E66YIDL.js"))
  },
  {
    "id": "kdl",
    "name": "KDL",
    "import": (() => import("./kdl-7VKEW52P.js"))
  },
  {
    "id": "kotlin",
    "name": "Kotlin",
    "aliases": [
      "kt",
      "kts"
    ],
    "import": (() => import("./kotlin-JLJXSWED.js"))
  },
  {
    "id": "kusto",
    "name": "Kusto",
    "aliases": [
      "kql"
    ],
    "import": (() => import("./kusto-PI34WTUQ.js"))
  },
  {
    "id": "latex",
    "name": "LaTeX",
    "import": (() => import("./latex-SUXUBA4C.js"))
  },
  {
    "id": "lean",
    "name": "Lean 4",
    "aliases": [
      "lean4"
    ],
    "import": (() => import("./lean-FCWDZ4YG.js"))
  },
  {
    "id": "less",
    "name": "Less",
    "import": (() => import("./less-NFT6GIQG.js"))
  },
  {
    "id": "liquid",
    "name": "Liquid",
    "import": (() => import("./liquid-YT65IM4H.js"))
  },
  {
    "id": "llvm",
    "name": "LLVM IR",
    "import": (() => import("./llvm-VVT5KKFV.js"))
  },
  {
    "id": "log",
    "name": "Log file",
    "import": (() => import("./log-LFD7B66H.js"))
  },
  {
    "id": "logo",
    "name": "Logo",
    "import": (() => import("./logo-XGWHZOU6.js"))
  },
  {
    "id": "lua",
    "name": "Lua",
    "import": (() => import("./lua-6ISAKNHM.js"))
  },
  {
    "id": "luau",
    "name": "Luau",
    "import": (() => import("./luau-34ZRHCYK.js"))
  },
  {
    "id": "make",
    "name": "Makefile",
    "aliases": [
      "makefile"
    ],
    "import": (() => import("./make-WGQJ666F.js"))
  },
  {
    "id": "markdown",
    "name": "Markdown",
    "aliases": [
      "md"
    ],
    "import": (() => import("./markdown-7LDCUEJC.js"))
  },
  {
    "id": "marko",
    "name": "Marko",
    "import": (() => import("./marko-SVE6D3ZV.js"))
  },
  {
    "id": "matlab",
    "name": "MATLAB",
    "import": (() => import("./matlab-RQNILGVZ.js"))
  },
  {
    "id": "mdc",
    "name": "MDC",
    "import": (() => import("./mdc-TBOPY453.js"))
  },
  {
    "id": "mdx",
    "name": "MDX",
    "import": (() => import("./mdx-SL6G24QH.js"))
  },
  {
    "id": "mermaid",
    "name": "Mermaid",
    "aliases": [
      "mmd"
    ],
    "import": (() => import("./mermaid-2WUI5OZE.js"))
  },
  {
    "id": "mipsasm",
    "name": "MIPS Assembly",
    "aliases": [
      "mips"
    ],
    "import": (() => import("./mipsasm-NAGCVX2N.js"))
  },
  {
    "id": "mojo",
    "name": "Mojo",
    "import": (() => import("./mojo-INQEOG7B.js"))
  },
  {
    "id": "move",
    "name": "Move",
    "import": (() => import("./move-44P6H2Y7.js"))
  },
  {
    "id": "narrat",
    "name": "Narrat Language",
    "aliases": [
      "nar"
    ],
    "import": (() => import("./narrat-Y24WGRGD.js"))
  },
  {
    "id": "nextflow",
    "name": "Nextflow",
    "aliases": [
      "nf"
    ],
    "import": (() => import("./nextflow-Q3ZBJIZD.js"))
  },
  {
    "id": "nginx",
    "name": "Nginx",
    "import": (() => import("./nginx-P4CIRT65.js"))
  },
  {
    "id": "nim",
    "name": "Nim",
    "import": (() => import("./nim-7HHNFWAF.js"))
  },
  {
    "id": "nix",
    "name": "Nix",
    "import": (() => import("./nix-Y6DCV3T3.js"))
  },
  {
    "id": "nushell",
    "name": "nushell",
    "aliases": [
      "nu"
    ],
    "import": (() => import("./nushell-YNBMBMPR.js"))
  },
  {
    "id": "objective-c",
    "name": "Objective-C",
    "aliases": [
      "objc"
    ],
    "import": (() => import("./objective-c-XO67PEDQ.js"))
  },
  {
    "id": "objective-cpp",
    "name": "Objective-C++",
    "import": (() => import("./objective-cpp-NQKSKDKO.js"))
  },
  {
    "id": "ocaml",
    "name": "OCaml",
    "import": (() => import("./ocaml-72IAIZYQ.js"))
  },
  {
    "id": "pascal",
    "name": "Pascal",
    "import": (() => import("./pascal-EXKOK5U7.js"))
  },
  {
    "id": "perl",
    "name": "Perl",
    "import": (() => import("./perl-77MOYABK.js"))
  },
  {
    "id": "php",
    "name": "PHP",
    "import": (() => import("./php-FUGX5B4M.js"))
  },
  {
    "id": "pkl",
    "name": "Pkl",
    "import": (() => import("./pkl-YJDPA4RO.js"))
  },
  {
    "id": "plsql",
    "name": "PL/SQL",
    "import": (() => import("./plsql-KBJEHFGE.js"))
  },
  {
    "id": "po",
    "name": "Gettext PO",
    "aliases": [
      "pot",
      "potx"
    ],
    "import": (() => import("./po-CQAYR22F.js"))
  },
  {
    "id": "polar",
    "name": "Polar",
    "import": (() => import("./polar-J33BRSIJ.js"))
  },
  {
    "id": "postcss",
    "name": "PostCSS",
    "import": (() => import("./postcss-BLSNMCDL.js"))
  },
  {
    "id": "powerquery",
    "name": "PowerQuery",
    "import": (() => import("./powerquery-HML47ACL.js"))
  },
  {
    "id": "powershell",
    "name": "PowerShell",
    "aliases": [
      "ps",
      "ps1"
    ],
    "import": (() => import("./powershell-6EIZZ7EL.js"))
  },
  {
    "id": "prisma",
    "name": "Prisma",
    "import": (() => import("./prisma-EML6JOSR.js"))
  },
  {
    "id": "prolog",
    "name": "Prolog",
    "import": (() => import("./prolog-MUWPQ7WK.js"))
  },
  {
    "id": "proto",
    "name": "Protocol Buffer 3",
    "aliases": [
      "protobuf"
    ],
    "import": (() => import("./proto-76LLXIHR.js"))
  },
  {
    "id": "pug",
    "name": "Pug",
    "aliases": [
      "jade"
    ],
    "import": (() => import("./pug-RXJ2EMD3.js"))
  },
  {
    "id": "puppet",
    "name": "Puppet",
    "import": (() => import("./puppet-LOQVLCBE.js"))
  },
  {
    "id": "purescript",
    "name": "PureScript",
    "import": (() => import("./purescript-XSBDMLXI.js"))
  },
  {
    "id": "python",
    "name": "Python",
    "aliases": [
      "py"
    ],
    "import": (() => import("./python-HEVG3OI7.js"))
  },
  {
    "id": "qml",
    "name": "QML",
    "import": (() => import("./qml-YBQASHFR.js"))
  },
  {
    "id": "qmldir",
    "name": "QML Directory",
    "import": (() => import("./qmldir-JBJXYHBN.js"))
  },
  {
    "id": "qss",
    "name": "Qt Style Sheets",
    "import": (() => import("./qss-XSWW5OPM.js"))
  },
  {
    "id": "r",
    "name": "R",
    "import": (() => import("./r-GUAZJ2GU.js"))
  },
  {
    "id": "racket",
    "name": "Racket",
    "import": (() => import("./racket-QBY4D5G2.js"))
  },
  {
    "id": "raku",
    "name": "Raku",
    "aliases": [
      "perl6"
    ],
    "import": (() => import("./raku-2YSIPTED.js"))
  },
  {
    "id": "razor",
    "name": "ASP.NET Razor",
    "import": (() => import("./razor-F5FAYGB7.js"))
  },
  {
    "id": "reg",
    "name": "Windows Registry Script",
    "import": (() => import("./reg-JCTSKHPW.js"))
  },
  {
    "id": "regexp",
    "name": "RegExp",
    "aliases": [
      "regex"
    ],
    "import": (() => import("./regexp-KKGKHOMD.js"))
  },
  {
    "id": "rel",
    "name": "Rel",
    "import": (() => import("./rel-RFCUDFSC.js"))
  },
  {
    "id": "riscv",
    "name": "RISC-V",
    "import": (() => import("./riscv-JDFPTYWB.js"))
  },
  {
    "id": "rosmsg",
    "name": "ROS Interface",
    "import": (() => import("./rosmsg-RZKXGDOT.js"))
  },
  {
    "id": "rst",
    "name": "reStructuredText",
    "import": (() => import("./rst-CNZIYAAQ.js"))
  },
  {
    "id": "ruby",
    "name": "Ruby",
    "aliases": [
      "rb"
    ],
    "import": (() => import("./ruby-QGR3CW7K.js"))
  },
  {
    "id": "rust",
    "name": "Rust",
    "aliases": [
      "rs"
    ],
    "import": (() => import("./rust-NZVUEL5D.js"))
  },
  {
    "id": "sas",
    "name": "SAS",
    "import": (() => import("./sas-WTCC7UHP.js"))
  },
  {
    "id": "sass",
    "name": "Sass",
    "import": (() => import("./sass-3BI6YTRP.js"))
  },
  {
    "id": "scala",
    "name": "Scala",
    "import": (() => import("./scala-HDDFNTP3.js"))
  },
  {
    "id": "scheme",
    "name": "Scheme",
    "import": (() => import("./scheme-EHJHDMP5.js"))
  },
  {
    "id": "scss",
    "name": "SCSS",
    "import": (() => import("./scss-AN6TJJP7.js"))
  },
  {
    "id": "sdbl",
    "name": "1C (Query)",
    "aliases": [
      "1c-query"
    ],
    "import": (() => import("./sdbl-ADFDCHRJ.js"))
  },
  {
    "id": "shaderlab",
    "name": "ShaderLab",
    "aliases": [
      "shader"
    ],
    "import": (() => import("./shaderlab-O5BNJD4L.js"))
  },
  {
    "id": "shellscript",
    "name": "Shell",
    "aliases": [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    "import": (() => import("./shellscript-3SFMVOFF.js"))
  },
  {
    "id": "shellsession",
    "name": "Shell Session",
    "aliases": [
      "console"
    ],
    "import": (() => import("./shellsession-2WURKDNP.js"))
  },
  {
    "id": "smalltalk",
    "name": "Smalltalk",
    "import": (() => import("./smalltalk-IKZOIPVO.js"))
  },
  {
    "id": "solidity",
    "name": "Solidity",
    "import": (() => import("./solidity-25TJ2XM5.js"))
  },
  {
    "id": "soy",
    "name": "Closure Templates",
    "aliases": [
      "closure-templates"
    ],
    "import": (() => import("./soy-4VXJBRUB.js"))
  },
  {
    "id": "sparql",
    "name": "SPARQL",
    "import": (() => import("./sparql-UAWZGPI2.js"))
  },
  {
    "id": "splunk",
    "name": "Splunk Query Language",
    "aliases": [
      "spl"
    ],
    "import": (() => import("./splunk-MW4CZ5AZ.js"))
  },
  {
    "id": "sql",
    "name": "SQL",
    "import": (() => import("./sql-KMZS7W7Y.js"))
  },
  {
    "id": "ssh-config",
    "name": "SSH Config",
    "import": (() => import("./ssh-config-A7DPRRNB.js"))
  },
  {
    "id": "stata",
    "name": "Stata",
    "import": (() => import("./stata-55CJKQSC.js"))
  },
  {
    "id": "stylus",
    "name": "Stylus",
    "aliases": [
      "styl"
    ],
    "import": (() => import("./stylus-TDI5FVRP.js"))
  },
  {
    "id": "svelte",
    "name": "Svelte",
    "import": (() => import("./svelte-AC33O2EL.js"))
  },
  {
    "id": "swift",
    "name": "Swift",
    "import": (() => import("./swift-LTDAKBVL.js"))
  },
  {
    "id": "system-verilog",
    "name": "SystemVerilog",
    "import": (() => import("./system-verilog-ZY3L4HU2.js"))
  },
  {
    "id": "systemd",
    "name": "Systemd Units",
    "import": (() => import("./systemd-RAHVLII2.js"))
  },
  {
    "id": "talonscript",
    "name": "TalonScript",
    "aliases": [
      "talon"
    ],
    "import": (() => import("./talonscript-JG3B3EQD.js"))
  },
  {
    "id": "tasl",
    "name": "Tasl",
    "import": (() => import("./tasl-4OVZTH22.js"))
  },
  {
    "id": "tcl",
    "name": "Tcl",
    "import": (() => import("./tcl-XV3B7MRZ.js"))
  },
  {
    "id": "templ",
    "name": "Templ",
    "import": (() => import("./templ-CZN7BGAF.js"))
  },
  {
    "id": "terraform",
    "name": "Terraform",
    "aliases": [
      "tf",
      "tfvars"
    ],
    "import": (() => import("./terraform-JHDIPRKU.js"))
  },
  {
    "id": "tex",
    "name": "TeX",
    "import": (() => import("./tex-IHPY7KRC.js"))
  },
  {
    "id": "toml",
    "name": "TOML",
    "import": (() => import("./toml-CU6YBP46.js"))
  },
  {
    "id": "ts-tags",
    "name": "TypeScript with Tags",
    "aliases": [
      "lit"
    ],
    "import": (() => import("./ts-tags-NYAP3BLF.js"))
  },
  {
    "id": "tsv",
    "name": "TSV",
    "import": (() => import("./tsv-QIBCVEXX.js"))
  },
  {
    "id": "tsx",
    "name": "TSX",
    "import": (() => import("./tsx-BYWADZF6.js"))
  },
  {
    "id": "turtle",
    "name": "Turtle",
    "import": (() => import("./turtle-H7IHO2BG.js"))
  },
  {
    "id": "twig",
    "name": "Twig",
    "import": (() => import("./twig-VDTQLRCT.js"))
  },
  {
    "id": "typescript",
    "name": "TypeScript",
    "aliases": [
      "ts",
      "cts",
      "mts"
    ],
    "import": (() => import("./typescript-X7G67ROP.js"))
  },
  {
    "id": "typespec",
    "name": "TypeSpec",
    "aliases": [
      "tsp"
    ],
    "import": (() => import("./typespec-MXCDKGYM.js"))
  },
  {
    "id": "typst",
    "name": "Typst",
    "aliases": [
      "typ"
    ],
    "import": (() => import("./typst-3F6N2UIG.js"))
  },
  {
    "id": "v",
    "name": "V",
    "import": (() => import("./v-YNXTWYFP.js"))
  },
  {
    "id": "vala",
    "name": "Vala",
    "import": (() => import("./vala-FDJUZG5Z.js"))
  },
  {
    "id": "vb",
    "name": "Visual Basic",
    "aliases": [
      "cmd"
    ],
    "import": (() => import("./vb-FUKDILBW.js"))
  },
  {
    "id": "verilog",
    "name": "Verilog",
    "import": (() => import("./verilog-NZHEEAQJ.js"))
  },
  {
    "id": "vhdl",
    "name": "VHDL",
    "import": (() => import("./vhdl-FJTMU2QY.js"))
  },
  {
    "id": "viml",
    "name": "Vim Script",
    "aliases": [
      "vim",
      "vimscript"
    ],
    "import": (() => import("./viml-EW7XGTAV.js"))
  },
  {
    "id": "vue",
    "name": "Vue",
    "import": (() => import("./vue-4VMHVBUA.js"))
  },
  {
    "id": "vue-html",
    "name": "Vue HTML",
    "import": (() => import("./vue-html-IUJ4OC7F.js"))
  },
  {
    "id": "vue-vine",
    "name": "Vue Vine",
    "import": (() => import("./vue-vine-QXAFYIXD.js"))
  },
  {
    "id": "vyper",
    "name": "Vyper",
    "aliases": [
      "vy"
    ],
    "import": (() => import("./vyper-Z35FGPRH.js"))
  },
  {
    "id": "wasm",
    "name": "WebAssembly",
    "import": (() => import("./wasm-KOVBULCK.js"))
  },
  {
    "id": "wenyan",
    "name": "Wenyan",
    "aliases": [
      ""
    ],
    "import": (() => import("./wenyan-C3CFGLV5.js"))
  },
  {
    "id": "wgsl",
    "name": "WGSL",
    "import": (() => import("./wgsl-VISNEZAA.js"))
  },
  {
    "id": "wikitext",
    "name": "Wikitext",
    "aliases": [
      "mediawiki",
      "wiki"
    ],
    "import": (() => import("./wikitext-DDZRG2UK.js"))
  },
  {
    "id": "wit",
    "name": "WebAssembly Interface Types",
    "import": (() => import("./wit-3MOQ6T2X.js"))
  },
  {
    "id": "wolfram",
    "name": "Wolfram",
    "aliases": [
      "wl"
    ],
    "import": (() => import("./wolfram-J3WBUYYE.js"))
  },
  {
    "id": "xml",
    "name": "XML",
    "import": (() => import("./xml-Z3PN22FM.js"))
  },
  {
    "id": "xsl",
    "name": "XSL",
    "import": (() => import("./xsl-7J42OLPX.js"))
  },
  {
    "id": "yaml",
    "name": "YAML",
    "aliases": [
      "yml"
    ],
    "import": (() => import("./yaml-3SMYBNRX.js"))
  },
  {
    "id": "zenscript",
    "name": "ZenScript",
    "import": (() => import("./zenscript-2V4Z3CPA.js"))
  },
  {
    "id": "zig",
    "name": "Zig",
    "import": (() => import("./zig-HF666F2S.js"))
  }
];
var bundledLanguagesBase = Object.fromEntries(bundledLanguagesInfo.map((i) => [i.id, i.import]));
var bundledLanguagesAlias = Object.fromEntries(bundledLanguagesInfo.flatMap((i) => i.aliases?.map((a) => [a, i.import]) || []));
var bundledLanguages = {
  ...bundledLanguagesBase,
  ...bundledLanguagesAlias
};

// node_modules/@pierre/precision-diffs/node_modules/shiki/dist/themes.mjs
var bundledThemesInfo = [
  {
    "id": "andromeeda",
    "displayName": "Andromeeda",
    "type": "dark",
    "import": (() => import("./andromeeda-RNIE42MX.js"))
  },
  {
    "id": "aurora-x",
    "displayName": "Aurora X",
    "type": "dark",
    "import": (() => import("./aurora-x-VLT2FUP7.js"))
  },
  {
    "id": "ayu-dark",
    "displayName": "Ayu Dark",
    "type": "dark",
    "import": (() => import("./ayu-dark-M6ILK2C5.js"))
  },
  {
    "id": "catppuccin-frappe",
    "displayName": "Catppuccin Frapp",
    "type": "dark",
    "import": (() => import("./catppuccin-frappe-5XNTEHTL.js"))
  },
  {
    "id": "catppuccin-latte",
    "displayName": "Catppuccin Latte",
    "type": "light",
    "import": (() => import("./catppuccin-latte-BJLTEULR.js"))
  },
  {
    "id": "catppuccin-macchiato",
    "displayName": "Catppuccin Macchiato",
    "type": "dark",
    "import": (() => import("./catppuccin-macchiato-WR3HECJQ.js"))
  },
  {
    "id": "catppuccin-mocha",
    "displayName": "Catppuccin Mocha",
    "type": "dark",
    "import": (() => import("./catppuccin-mocha-YZC25JSD.js"))
  },
  {
    "id": "dark-plus",
    "displayName": "Dark Plus",
    "type": "dark",
    "import": (() => import("./dark-plus-BSRZ7XGN.js"))
  },
  {
    "id": "dracula",
    "displayName": "Dracula Theme",
    "type": "dark",
    "import": (() => import("./dracula-BJ2BLIW3.js"))
  },
  {
    "id": "dracula-soft",
    "displayName": "Dracula Theme Soft",
    "type": "dark",
    "import": (() => import("./dracula-soft-67KEOORK.js"))
  },
  {
    "id": "everforest-dark",
    "displayName": "Everforest Dark",
    "type": "dark",
    "import": (() => import("./everforest-dark-A3JGOSSS.js"))
  },
  {
    "id": "everforest-light",
    "displayName": "Everforest Light",
    "type": "light",
    "import": (() => import("./everforest-light-HCL7XBMX.js"))
  },
  {
    "id": "github-dark",
    "displayName": "GitHub Dark",
    "type": "dark",
    "import": (() => import("./github-dark-3QKIQGMO.js"))
  },
  {
    "id": "github-dark-default",
    "displayName": "GitHub Dark Default",
    "type": "dark",
    "import": (() => import("./github-dark-default-QOYLDELM.js"))
  },
  {
    "id": "github-dark-dimmed",
    "displayName": "GitHub Dark Dimmed",
    "type": "dark",
    "import": (() => import("./github-dark-dimmed-HDXLZI3W.js"))
  },
  {
    "id": "github-dark-high-contrast",
    "displayName": "GitHub Dark High Contrast",
    "type": "dark",
    "import": (() => import("./github-dark-high-contrast-ETBWTAL2.js"))
  },
  {
    "id": "github-light",
    "displayName": "GitHub Light",
    "type": "light",
    "import": (() => import("./github-light-DLOSUD5W.js"))
  },
  {
    "id": "github-light-default",
    "displayName": "GitHub Light Default",
    "type": "light",
    "import": (() => import("./github-light-default-R3HOH7MX.js"))
  },
  {
    "id": "github-light-high-contrast",
    "displayName": "GitHub Light High Contrast",
    "type": "light",
    "import": (() => import("./github-light-high-contrast-UXQMK6UG.js"))
  },
  {
    "id": "gruvbox-dark-hard",
    "displayName": "Gruvbox Dark Hard",
    "type": "dark",
    "import": (() => import("./gruvbox-dark-hard-OV67ZKEY.js"))
  },
  {
    "id": "gruvbox-dark-medium",
    "displayName": "Gruvbox Dark Medium",
    "type": "dark",
    "import": (() => import("./gruvbox-dark-medium-VPG6QYVS.js"))
  },
  {
    "id": "gruvbox-dark-soft",
    "displayName": "Gruvbox Dark Soft",
    "type": "dark",
    "import": (() => import("./gruvbox-dark-soft-GM3FE4KU.js"))
  },
  {
    "id": "gruvbox-light-hard",
    "displayName": "Gruvbox Light Hard",
    "type": "light",
    "import": (() => import("./gruvbox-light-hard-WHXLG5NU.js"))
  },
  {
    "id": "gruvbox-light-medium",
    "displayName": "Gruvbox Light Medium",
    "type": "light",
    "import": (() => import("./gruvbox-light-medium-57ZFKM24.js"))
  },
  {
    "id": "gruvbox-light-soft",
    "displayName": "Gruvbox Light Soft",
    "type": "light",
    "import": (() => import("./gruvbox-light-soft-NCC4HIUF.js"))
  },
  {
    "id": "houston",
    "displayName": "Houston",
    "type": "dark",
    "import": (() => import("./houston-G4C3OMBQ.js"))
  },
  {
    "id": "kanagawa-dragon",
    "displayName": "Kanagawa Dragon",
    "type": "dark",
    "import": (() => import("./kanagawa-dragon-TOMMA4DB.js"))
  },
  {
    "id": "kanagawa-lotus",
    "displayName": "Kanagawa Lotus",
    "type": "light",
    "import": (() => import("./kanagawa-lotus-7GA6TV6E.js"))
  },
  {
    "id": "kanagawa-wave",
    "displayName": "Kanagawa Wave",
    "type": "dark",
    "import": (() => import("./kanagawa-wave-ZH6VG345.js"))
  },
  {
    "id": "laserwave",
    "displayName": "LaserWave",
    "type": "dark",
    "import": (() => import("./laserwave-M636JQXH.js"))
  },
  {
    "id": "light-plus",
    "displayName": "Light Plus",
    "type": "light",
    "import": (() => import("./light-plus-FGNZTMIC.js"))
  },
  {
    "id": "material-theme",
    "displayName": "Material Theme",
    "type": "dark",
    "import": (() => import("./material-theme-ZM3IUWZW.js"))
  },
  {
    "id": "material-theme-darker",
    "displayName": "Material Theme Darker",
    "type": "dark",
    "import": (() => import("./material-theme-darker-LO4ASCNK.js"))
  },
  {
    "id": "material-theme-lighter",
    "displayName": "Material Theme Lighter",
    "type": "light",
    "import": (() => import("./material-theme-lighter-BMZAYRZY.js"))
  },
  {
    "id": "material-theme-ocean",
    "displayName": "Material Theme Ocean",
    "type": "dark",
    "import": (() => import("./material-theme-ocean-OKYKRIFB.js"))
  },
  {
    "id": "material-theme-palenight",
    "displayName": "Material Theme Palenight",
    "type": "dark",
    "import": (() => import("./material-theme-palenight-LHTVNZUZ.js"))
  },
  {
    "id": "min-dark",
    "displayName": "Min Dark",
    "type": "dark",
    "import": (() => import("./min-dark-RZS4VUIR.js"))
  },
  {
    "id": "min-light",
    "displayName": "Min Light",
    "type": "light",
    "import": (() => import("./min-light-5L3IFI53.js"))
  },
  {
    "id": "monokai",
    "displayName": "Monokai",
    "type": "dark",
    "import": (() => import("./monokai-4YWERSBK.js"))
  },
  {
    "id": "night-owl",
    "displayName": "Night Owl",
    "type": "dark",
    "import": (() => import("./night-owl-T24TNFL5.js"))
  },
  {
    "id": "nord",
    "displayName": "Nord",
    "type": "dark",
    "import": (() => import("./nord-5XZFOPXJ.js"))
  },
  {
    "id": "one-dark-pro",
    "displayName": "One Dark Pro",
    "type": "dark",
    "import": (() => import("./one-dark-pro-JTFUYIQN.js"))
  },
  {
    "id": "one-light",
    "displayName": "One Light",
    "type": "light",
    "import": (() => import("./one-light-6B7JTOQS.js"))
  },
  {
    "id": "plastic",
    "displayName": "Plastic",
    "type": "dark",
    "import": (() => import("./plastic-GADJDJPQ.js"))
  },
  {
    "id": "poimandres",
    "displayName": "Poimandres",
    "type": "dark",
    "import": (() => import("./poimandres-NVKFFCM6.js"))
  },
  {
    "id": "red",
    "displayName": "Red",
    "type": "dark",
    "import": (() => import("./red-VMOERCO2.js"))
  },
  {
    "id": "rose-pine",
    "displayName": "Ros Pine",
    "type": "dark",
    "import": (() => import("./rose-pine-52UAHX34.js"))
  },
  {
    "id": "rose-pine-dawn",
    "displayName": "Ros Pine Dawn",
    "type": "light",
    "import": (() => import("./rose-pine-dawn-3GDI4AQI.js"))
  },
  {
    "id": "rose-pine-moon",
    "displayName": "Ros Pine Moon",
    "type": "dark",
    "import": (() => import("./rose-pine-moon-LLE6Q4FH.js"))
  },
  {
    "id": "slack-dark",
    "displayName": "Slack Dark",
    "type": "dark",
    "import": (() => import("./slack-dark-D3UST4PW.js"))
  },
  {
    "id": "slack-ochin",
    "displayName": "Slack Ochin",
    "type": "light",
    "import": (() => import("./slack-ochin-GWOZHAEE.js"))
  },
  {
    "id": "snazzy-light",
    "displayName": "Snazzy Light",
    "type": "light",
    "import": (() => import("./snazzy-light-7IVR6ARU.js"))
  },
  {
    "id": "solarized-dark",
    "displayName": "Solarized Dark",
    "type": "dark",
    "import": (() => import("./solarized-dark-3EHWKDHF.js"))
  },
  {
    "id": "solarized-light",
    "displayName": "Solarized Light",
    "type": "light",
    "import": (() => import("./solarized-light-SESQQR7M.js"))
  },
  {
    "id": "synthwave-84",
    "displayName": "Synthwave '84",
    "type": "dark",
    "import": (() => import("./synthwave-84-YZYBDG5R.js"))
  },
  {
    "id": "tokyo-night",
    "displayName": "Tokyo Night",
    "type": "dark",
    "import": (() => import("./tokyo-night-NQS55DFR.js"))
  },
  {
    "id": "vesper",
    "displayName": "Vesper",
    "type": "dark",
    "import": (() => import("./vesper-ABJJNUM3.js"))
  },
  {
    "id": "vitesse-black",
    "displayName": "Vitesse Black",
    "type": "dark",
    "import": (() => import("./vitesse-black-YN5267HZ.js"))
  },
  {
    "id": "vitesse-dark",
    "displayName": "Vitesse Dark",
    "type": "dark",
    "import": (() => import("./vitesse-dark-IQG6WD4D.js"))
  },
  {
    "id": "vitesse-light",
    "displayName": "Vitesse Light",
    "type": "light",
    "import": (() => import("./vitesse-light-A5ZPOHLZ.js"))
  }
];
var bundledThemes = Object.fromEntries(bundledThemesInfo.map((i) => [i.id, i.import]));

// node_modules/@pierre/precision-diffs/node_modules/shiki/node_modules/@shikijs/engine-oniguruma/dist/index.mjs
var ShikiError3 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ShikiError";
  }
};
function getHeapMax() {
  return 2147483648;
}
function _emscripten_get_now() {
  return typeof performance !== "undefined" ? performance.now() : Date.now();
}
var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
async function main(init) {
  let wasmMemory;
  let buffer;
  const binding = {};
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    binding.HEAPU8 = new Uint8Array(buf);
    binding.HEAPU32 = new Uint32Array(buf);
  }
  function _emscripten_memcpy_big(dest, src, num) {
    binding.HEAPU8.copyWithin(dest, src, src + num);
  }
  function emscripten_realloc_buffer(size) {
    try {
      wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
      updateGlobalBufferAndViews(wasmMemory.buffer);
      return 1;
    } catch {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    const oldSize = binding.HEAPU8.length;
    requestedSize = requestedSize >>> 0;
    const maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize)
      return false;
    for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {
      let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
      const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
      const replacement = emscripten_realloc_buffer(newSize);
      if (replacement)
        return true;
    }
    return false;
  }
  const UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead = 1024) {
    const endIdx = idx + maxBytesToRead;
    let endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    let str = "";
    while (idx < endPtr) {
      let u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      const u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) === 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      const u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) === 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        const ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : "";
  }
  const asmLibraryArg = {
    emscripten_get_now: _emscripten_get_now,
    emscripten_memcpy_big: _emscripten_memcpy_big,
    emscripten_resize_heap: _emscripten_resize_heap,
    fd_write: () => 0
  };
  async function createWasm() {
    const info = {
      env: asmLibraryArg,
      wasi_snapshot_preview1: asmLibraryArg
    };
    const exports = await init(info);
    wasmMemory = exports.memory;
    updateGlobalBufferAndViews(wasmMemory.buffer);
    Object.assign(binding, exports);
    binding.UTF8ToString = UTF8ToString;
  }
  await createWasm();
  return binding;
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var onigBinding = null;
function throwLastOnigError(onigBinding2) {
  throw new ShikiError3(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));
}
var UtfString = class _UtfString {
  constructor(str) {
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16Value");
    __publicField(this, "utf8Value");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    const utf16Length = str.length;
    const utf8Length = _UtfString._utf8ByteLength(str);
    const computeIndicesMapping = utf8Length !== utf16Length;
    const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;
    if (computeIndicesMapping)
      utf16OffsetToUtf8[utf16Length] = utf8Length;
    const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;
    if (computeIndicesMapping)
      utf8OffsetToUtf16[utf8Length] = utf16Length;
    const utf8Value = new Uint8Array(utf8Length);
    let i8 = 0;
    for (let i16 = 0; i16 < utf16Length; i16++) {
      const charCode = str.charCodeAt(i16);
      let codePoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i16 + 1 < utf16Length) {
          const nextCharCode = str.charCodeAt(i16 + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (computeIndicesMapping) {
        utf16OffsetToUtf8[i16] = i8;
        if (wasSurrogatePair)
          utf16OffsetToUtf8[i16 + 1] = i8;
        if (codePoint <= 127) {
          utf8OffsetToUtf16[i8 + 0] = i16;
        } else if (codePoint <= 2047) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
        } else if (codePoint <= 65535) {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
        } else {
          utf8OffsetToUtf16[i8 + 0] = i16;
          utf8OffsetToUtf16[i8 + 1] = i16;
          utf8OffsetToUtf16[i8 + 2] = i16;
          utf8OffsetToUtf16[i8 + 3] = i16;
        }
      }
      if (codePoint <= 127) {
        utf8Value[i8++] = codePoint;
      } else if (codePoint <= 2047) {
        utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint <= 65535) {
        utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      } else {
        utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;
        utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;
        utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
        utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
      }
      if (wasSurrogatePair)
        i16++;
    }
    this.utf16Length = utf16Length;
    this.utf8Length = utf8Length;
    this.utf16Value = str;
    this.utf8Value = utf8Value;
    this.utf16OffsetToUtf8 = utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utf8OffsetToUtf16;
  }
  static _utf8ByteLength(str) {
    let result = 0;
    for (let i = 0, len = str.length; i < len; i++) {
      const charCode = str.charCodeAt(i);
      let codepoint = charCode;
      let wasSurrogatePair = false;
      if (charCode >= 55296 && charCode <= 56319) {
        if (i + 1 < len) {
          const nextCharCode = str.charCodeAt(i + 1);
          if (nextCharCode >= 56320 && nextCharCode <= 57343) {
            codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
            wasSurrogatePair = true;
          }
        }
      }
      if (codepoint <= 127)
        result += 1;
      else if (codepoint <= 2047)
        result += 2;
      else if (codepoint <= 65535)
        result += 3;
      else
        result += 4;
      if (wasSurrogatePair)
        i++;
    }
    return result;
  }
  createString(onigBinding2) {
    const result = onigBinding2.omalloc(this.utf8Length);
    onigBinding2.HEAPU8.set(this.utf8Value, result);
    return result;
  }
};
var _OnigString = class _OnigString2 {
  constructor(str) {
    __publicField(this, "id", ++_OnigString2.LAST_ID);
    __publicField(this, "_onigBinding");
    __publicField(this, "content");
    __publicField(this, "utf16Length");
    __publicField(this, "utf8Length");
    __publicField(this, "utf16OffsetToUtf8");
    __publicField(this, "utf8OffsetToUtf16");
    __publicField(this, "ptr");
    if (!onigBinding)
      throw new ShikiError3("Must invoke loadWasm first.");
    this._onigBinding = onigBinding;
    this.content = str;
    const utfString = new UtfString(str);
    this.utf16Length = utfString.utf16Length;
    this.utf8Length = utfString.utf8Length;
    this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;
    this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;
    if (this.utf8Length < 1e4 && !_OnigString2._sharedPtrInUse) {
      if (!_OnigString2._sharedPtr)
        _OnigString2._sharedPtr = onigBinding.omalloc(1e4);
      _OnigString2._sharedPtrInUse = true;
      onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString2._sharedPtr);
      this.ptr = _OnigString2._sharedPtr;
    } else {
      this.ptr = utfString.createString(onigBinding);
    }
  }
  convertUtf8OffsetToUtf16(utf8Offset) {
    if (this.utf8OffsetToUtf16) {
      if (utf8Offset < 0)
        return 0;
      if (utf8Offset > this.utf8Length)
        return this.utf16Length;
      return this.utf8OffsetToUtf16[utf8Offset];
    }
    return utf8Offset;
  }
  convertUtf16OffsetToUtf8(utf16Offset) {
    if (this.utf16OffsetToUtf8) {
      if (utf16Offset < 0)
        return 0;
      if (utf16Offset > this.utf16Length)
        return this.utf8Length;
      return this.utf16OffsetToUtf8[utf16Offset];
    }
    return utf16Offset;
  }
  dispose() {
    if (this.ptr === _OnigString2._sharedPtr)
      _OnigString2._sharedPtrInUse = false;
    else
      this._onigBinding.ofree(this.ptr);
  }
};
__publicField(_OnigString, "LAST_ID", 0);
__publicField(_OnigString, "_sharedPtr", 0);
__publicField(_OnigString, "_sharedPtrInUse", false);
var OnigString = _OnigString;
var OnigScanner = class {
  constructor(patterns) {
    __publicField(this, "_onigBinding");
    __publicField(this, "_ptr");
    if (!onigBinding)
      throw new ShikiError3("Must invoke loadWasm first.");
    const strPtrsArr = [];
    const strLenArr = [];
    for (let i = 0, len = patterns.length; i < len; i++) {
      const utfString = new UtfString(patterns[i]);
      strPtrsArr[i] = utfString.createString(onigBinding);
      strLenArr[i] = utfString.utf8Length;
    }
    const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);
    const strLenPtr = onigBinding.omalloc(4 * patterns.length);
    onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);
    const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);
    for (let i = 0, len = patterns.length; i < len; i++)
      onigBinding.ofree(strPtrsArr[i]);
    onigBinding.ofree(strLenPtr);
    onigBinding.ofree(strPtrsPtr);
    if (scannerPtr === 0)
      throwLastOnigError(onigBinding);
    this._onigBinding = onigBinding;
    this._ptr = scannerPtr;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(string, startPosition, arg) {
    let options = 0;
    if (typeof arg === "number") {
      options = arg;
    }
    if (typeof string === "string") {
      string = new OnigString(string);
      const result = this._findNextMatchSync(string, startPosition, false, options);
      string.dispose();
      return result;
    }
    return this._findNextMatchSync(string, startPosition, false, options);
  }
  _findNextMatchSync(string, startPosition, debugCall, options) {
    const onigBinding2 = this._onigBinding;
    const resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
    if (resultPtr === 0) {
      return null;
    }
    const HEAPU32 = onigBinding2.HEAPU32;
    let offset = resultPtr / 4;
    const index = HEAPU32[offset++];
    const count = HEAPU32[offset++];
    const captureIndices = [];
    for (let i = 0; i < count; i++) {
      const beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      const end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
      captureIndices[i] = {
        start: beg,
        end,
        length: end - beg
      };
    }
    return {
      index,
      captureIndices
    };
  }
};
function isInstantiatorOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.instantiator === "function";
}
function isInstantiatorModule(dataOrOptions) {
  return typeof dataOrOptions.default === "function";
}
function isDataOptionsObject(dataOrOptions) {
  return typeof dataOrOptions.data !== "undefined";
}
function isResponse(dataOrOptions) {
  return typeof Response !== "undefined" && dataOrOptions instanceof Response;
}
function isArrayBuffer(data) {
  return typeof ArrayBuffer !== "undefined" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer !== "undefined" && Buffer.isBuffer?.(data) || typeof SharedArrayBuffer !== "undefined" && data instanceof SharedArrayBuffer || typeof Uint32Array !== "undefined" && data instanceof Uint32Array;
}
var initPromise;
function loadWasm(options) {
  if (initPromise)
    return initPromise;
  async function _load() {
    onigBinding = await main(async (info) => {
      let instance = options;
      instance = await instance;
      if (typeof instance === "function")
        instance = await instance(info);
      if (typeof instance === "function")
        instance = await instance(info);
      if (isInstantiatorOptionsObject(instance)) {
        instance = await instance.instantiator(info);
      } else if (isInstantiatorModule(instance)) {
        instance = await instance.default(info);
      } else {
        if (isDataOptionsObject(instance))
          instance = instance.data;
        if (isResponse(instance)) {
          if (typeof WebAssembly.instantiateStreaming === "function")
            instance = await _makeResponseStreamingLoader(instance)(info);
          else
            instance = await _makeResponseNonStreamingLoader(instance)(info);
        } else if (isArrayBuffer(instance)) {
          instance = await _makeArrayBufferLoader(instance)(info);
        } else if (instance instanceof WebAssembly.Module) {
          instance = await _makeArrayBufferLoader(instance)(info);
        } else if ("default" in instance && instance.default instanceof WebAssembly.Module) {
          instance = await _makeArrayBufferLoader(instance.default)(info);
        }
      }
      if ("instance" in instance)
        instance = instance.instance;
      if ("exports" in instance)
        instance = instance.exports;
      return instance;
    });
  }
  initPromise = _load();
  return initPromise;
}
function _makeArrayBufferLoader(data) {
  return (importObject) => WebAssembly.instantiate(data, importObject);
}
function _makeResponseStreamingLoader(data) {
  return (importObject) => WebAssembly.instantiateStreaming(data, importObject);
}
function _makeResponseNonStreamingLoader(data) {
  return async (importObject) => {
    const arrayBuffer = await data.arrayBuffer();
    return WebAssembly.instantiate(arrayBuffer, importObject);
  };
}
async function createOnigurumaEngine(options) {
  if (options)
    await loadWasm(options);
  return {
    createScanner(patterns) {
      return new OnigScanner(patterns.map((p) => typeof p === "string" ? p : p.source));
    },
    createString(s) {
      return new OnigString(s);
    }
  };
}

// node_modules/@pierre/precision-diffs/node_modules/shiki/dist/bundle-full.mjs
var createHighlighter = createdBundledHighlighter({
  langs: bundledLanguages,
  themes: bundledThemes,
  engine: () => createOnigurumaEngine(import("./wasm-2IEUCOXM.js"))
});
var {
  codeToHtml: codeToHtml2,
  codeToHast: codeToHast2,
  codeToTokens: codeToTokens2,
  codeToTokensBase: codeToTokensBase2,
  codeToTokensWithThemes: codeToTokensWithThemes2,
  getSingletonHighlighter,
  getLastGrammarState: getLastGrammarState2
} = createSingletonShorthands(
  createHighlighter,
  { guessEmbeddedLanguages }
);

// node_modules/@pierre/precision-diffs/node_modules/shiki/node_modules/@shikijs/engine-javascript/dist/shared/engine-javascript.hzpS1_41.mjs
var MAX = 4294967295;
var JavaScriptScanner = class {
  constructor(patterns, options = {}) {
    this.patterns = patterns;
    this.options = options;
    const {
      forgiving = false,
      cache,
      regexConstructor
    } = options;
    if (!regexConstructor) {
      throw new Error("Option `regexConstructor` is not provided");
    }
    this.regexps = patterns.map((p) => {
      if (typeof p !== "string") {
        return p;
      }
      const cached = cache?.get(p);
      if (cached) {
        if (cached instanceof RegExp) {
          return cached;
        }
        if (forgiving)
          return null;
        throw cached;
      }
      try {
        const regex = regexConstructor(p);
        cache?.set(p, regex);
        return regex;
      } catch (e) {
        cache?.set(p, e);
        if (forgiving)
          return null;
        throw e;
      }
    });
  }
  regexps;
  findNextMatchSync(string, startPosition, _options) {
    const str = typeof string === "string" ? string : string.content;
    const pending = [];
    function toResult(index, match, offset = 0) {
      return {
        index,
        captureIndices: match.indices.map((indice) => {
          if (indice == null) {
            return {
              start: MAX,
              end: MAX,
              length: 0
            };
          }
          return {
            start: indice[0] + offset,
            end: indice[1] + offset,
            length: indice[1] - indice[0]
          };
        })
      };
    }
    for (let i = 0; i < this.regexps.length; i++) {
      const regexp = this.regexps[i];
      if (!regexp)
        continue;
      try {
        regexp.lastIndex = startPosition;
        const match = regexp.exec(str);
        if (!match)
          continue;
        if (match.index === startPosition) {
          return toResult(i, match, 0);
        }
        pending.push([i, match, 0]);
      } catch (e) {
        if (this.options.forgiving)
          continue;
        throw e;
      }
    }
    if (pending.length) {
      const minIndex = Math.min(...pending.map((m) => m[1].index));
      for (const [i, match, offset] of pending) {
        if (match.index === minIndex) {
          return toResult(i, match, offset);
        }
      }
    }
    return null;
  }
};

// node_modules/@pierre/precision-diffs/node_modules/shiki/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs
function defaultJavaScriptRegexConstructor(pattern, options) {
  return toRegExp(
    pattern,
    {
      global: true,
      hasIndices: true,
      // This has no benefit for the standard JS engine, but it avoids a perf penalty for
      // precompiled grammars when constructing extremely long patterns that aren't always used
      lazyCompileLength: 3e3,
      rules: {
        // Needed since TextMate grammars merge backrefs across patterns
        allowOrphanBackrefs: true,
        // Improves search performance for generated regexes
        asciiWordBoundaries: true,
        // Follow `vscode-oniguruma` which enables this Oniguruma option by default
        captureGroup: true,
        // Oniguruma uses depth limit `20`; lowered here to keep regexes shorter and maybe
        // sometimes faster, but can be increased if issues reported due to low limit
        recursionLimit: 5,
        // Oniguruma option for `^`->`\A`, `$`->`\Z`; improves search performance without any
        // change in meaning since TM grammars search line by line
        singleline: true
      },
      ...options
    }
  );
}
function createJavaScriptRegexEngine(options = {}) {
  const _options = Object.assign(
    {
      target: "auto",
      cache: /* @__PURE__ */ new Map()
    },
    options
  );
  _options.regexConstructor ||= (pattern) => defaultJavaScriptRegexConstructor(pattern, { target: _options.target });
  return {
    createScanner(patterns) {
      return new JavaScriptScanner(patterns, _options);
    },
    createString(s) {
      return {
        content: s
      };
    }
  };
}

// node_modules/@pierre/precision-diffs/dist/SharedHighlighter.js
var highlighter;
var loadedThemes = /* @__PURE__ */ new Map();
var loadedLanguages = /* @__PURE__ */ new Map();
async function getSharedHighlighter({ themes, langs, preferWasmHighlighter = false }) {
  if (isHighlighterNull(highlighter)) {
    highlighter = new Promise((resolve) => {
      (preferWasmHighlighter ? loadWasm(import("./wasm-2IEUCOXM.js")) : Promise.resolve()).then(() => {
        const themesToLoad = [];
        for (const theme of themes) {
          loadedThemes.set(theme, true);
          const customTheme = CustomThemes.get(theme);
          if (customTheme != null) themesToLoad.push(customTheme());
          else themesToLoad.push(theme);
        }
        for (const language of langs) loadedLanguages.set(language, true);
        loadedLanguages.set("text", true);
        return createHighlighter({
          themes: themesToLoad,
          langs: [...langs, "text"],
          engine: preferWasmHighlighter ? createOnigurumaEngine() : createJavaScriptRegexEngine()
        });
      }).then((instance$1) => {
        highlighter = instance$1;
        resolve(instance$1);
      });
    });
    return highlighter;
  }
  const instance = isHighlighterLoading(highlighter) ? await highlighter : highlighter;
  const loaders = [];
  for (const language of langs) {
    const loadedOrLoading = loadedLanguages.get(language);
    if (loadedOrLoading == null) {
      const promise = instance.loadLanguage(language).then(() => void loadedLanguages.set(language, true));
      loadedLanguages.set(language, promise);
      loaders.push(promise);
    } else if (loadedOrLoading !== true) loaders.push(loadedOrLoading);
  }
  for (const themeName of themes) {
    const loadedOrLoading = loadedThemes.get(themeName);
    if (loadedOrLoading == null) {
      const customTheme = CustomThemes.get(themeName);
      const promise = instance.loadTheme(customTheme != null ? customTheme() : themeName).then(() => void loadedThemes.set(themeName, true));
      loadedThemes.set(themeName, promise);
      loaders.push(promise);
    } else if (loadedOrLoading !== true) loaders.push(loadedOrLoading);
  }
  if (loaders.length > 0) await Promise.all(loaders);
  return instance;
}
function hasLoadedThemes(themes) {
  for (const theme of themes) {
    if (loadedThemes.get(theme) === true) continue;
    return false;
  }
  return true;
}
function hasLoadedLanguage(lang) {
  return loadedLanguages.get(lang) === true;
}
function isHighlighterLoaded(h = highlighter) {
  return h != null && !("then" in h);
}
function isHighlighterLoading(h = highlighter) {
  return h != null && "then" in h;
}
function isHighlighterNull(h = highlighter) {
  return h == null;
}
async function preloadHighlighter(options) {
  await getSharedHighlighter(options);
}
async function disposeHighlighter() {
  if (highlighter == null) return;
  (await highlighter).dispose();
  loadedThemes.clear();
  loadedLanguages.clear();
  highlighter = void 0;
}
var CustomThemes = /* @__PURE__ */ new Map();
function registerCustomTheme(themeName, loader) {
  if (CustomThemes.has(themeName)) {
    console.error("SharedHighlight.registerCustomTheme: theme name already registered", themeName);
    return;
  }
  CustomThemes.set(themeName, loader);
}
registerCustomTheme("pierre-dark", () => import("./pierre-dark-4ZOFUVGF.js"));
registerCustomTheme("pierre-light", () => import("./pierre-light-POXD45IJ.js"));

// node_modules/@pierre/precision-diffs/dist/constants.js
var COMMIT_METADATA_SPLIT = /(?=^From [a-f0-9]+ .+$)/m;
var GIT_DIFF_FILE_BREAK_REGEX = /(?=^diff --git)/gm;
var UNIFIED_DIFF_FILE_BREAK_REGEX = /(?=^---\s+\S)/gm;
var FILE_CONTEXT_BLOB = /(?=^@@ )/gm;
var HUNK_HEADER = /^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@(?: (.*))?/m;
var SPLIT_WITH_NEWLINES = new RegExp("(?<=\\n)");
var FILENAME_HEADER_REGEX = /^(---|\+\+\+)\s+([^\t\n]+)/;
var FILENAME_HEADER_REGEX_GIT = /^(---|\+\+\+)\s+[ab]\/([^\t\n]+)/;
var ALTERNATE_FILE_NAMES_GIT = /^diff --git (?:"a\/(.+?)"|a\/(.+?)) (?:"b\/(.+?)"|b\/(.+?))$/;
var FILE_MODE_FROM_INDEX = /^index (?:[0-9a-f]+)\.\.(?:[0-9a-f]+)(?: (\d+))?/;
var HEADER_METADATA_SLOT_ID = "header-metadata";
var DEFAULT_THEMES = {
  dark: "pierre-dark",
  light: "pierre-light"
};

// node_modules/@pierre/precision-diffs/dist/utils/getLineAnnotationName.js
function getLineAnnotationName(annotation) {
  return `annotation-${"side" in annotation ? `${annotation.side}-` : ""}${annotation.lineNumber}`;
}

// node_modules/@pierre/precision-diffs/dist/utils/getFiletypeFromFileName.js
var EXTENSION_TO_FILE_FORMAT = {
  "1c": "1c",
  abap: "abap",
  as: "actionscript-3",
  ada: "ada",
  adb: "ada",
  ads: "ada",
  adoc: "asciidoc",
  asciidoc: "asciidoc",
  "component.html": "angular-html",
  "component.ts": "angular-ts",
  conf: "nginx",
  htaccess: "apache",
  cls: "tex",
  trigger: "apex",
  apl: "apl",
  applescript: "applescript",
  scpt: "applescript",
  ara: "ara",
  asm: "asm",
  s: "riscv",
  astro: "astro",
  awk: "awk",
  bal: "ballerina",
  sh: "zsh",
  bash: "zsh",
  bat: "cmd",
  cmd: "cmd",
  be: "berry",
  beancount: "beancount",
  bib: "bibtex",
  bicep: "bicep",
  "blade.php": "blade",
  bsl: "bsl",
  c: "c",
  h: "objective-cpp",
  cs: "csharp",
  cpp: "cpp",
  hpp: "cpp",
  cc: "cpp",
  cxx: "cpp",
  hh: "cpp",
  cdc: "cdc",
  cairo: "cairo",
  clar: "clarity",
  clj: "clojure",
  cljs: "clojure",
  cljc: "clojure",
  soy: "soy",
  cmake: "cmake",
  "CMakeLists.txt": "cmake",
  cob: "cobol",
  cbl: "cobol",
  cobol: "cobol",
  CODEOWNERS: "codeowners",
  ql: "ql",
  coffee: "coffeescript",
  lisp: "lisp",
  cl: "lisp",
  lsp: "lisp",
  log: "log",
  v: "verilog",
  cql: "cql",
  cr: "crystal",
  css: "css",
  csv: "csv",
  cue: "cue",
  cypher: "cypher",
  cyp: "cypher",
  d: "d",
  dart: "dart",
  dax: "dax",
  desktop: "desktop",
  diff: "diff",
  patch: "diff",
  Dockerfile: "dockerfile",
  dockerfile: "dockerfile",
  env: "dotenv",
  dm: "dream-maker",
  edge: "edge",
  el: "emacs-lisp",
  ex: "elixir",
  exs: "elixir",
  elm: "elm",
  erb: "erb",
  erl: "erlang",
  hrl: "erlang",
  f: "fortran-fixed-form",
  for: "fortran-fixed-form",
  fs: "fsharp",
  fsi: "fsharp",
  fsx: "fsharp",
  f03: "f03",
  f08: "f08",
  f18: "f18",
  f77: "f77",
  f90: "fortran-free-form",
  f95: "fortran-free-form",
  fnl: "fennel",
  fish: "fish",
  ftl: "ftl",
  tres: "gdresource",
  res: "gdresource",
  gd: "gdscript",
  gdshader: "gdshader",
  gs: "genie",
  feature: "gherkin",
  COMMIT_EDITMSG: "git-commit",
  "git-rebase-todo": "git-rebase",
  gjs: "glimmer-js",
  gleam: "gleam",
  gts: "glimmer-ts",
  glsl: "glsl",
  vert: "glsl",
  frag: "glsl",
  shader: "shaderlab",
  gp: "gnuplot",
  plt: "gnuplot",
  gnuplot: "gnuplot",
  go: "go",
  graphql: "graphql",
  gql: "graphql",
  groovy: "groovy",
  gvy: "groovy",
  hack: "hack",
  haml: "haml",
  hbs: "handlebars",
  handlebars: "handlebars",
  hs: "haskell",
  lhs: "haskell",
  hx: "haxe",
  hcl: "hcl",
  hjson: "hjson",
  hlsl: "hlsl",
  fx: "hlsl",
  html: "html",
  htm: "html",
  http: "http",
  rest: "http",
  hxml: "hxml",
  hy: "hy",
  imba: "imba",
  ini: "ini",
  cfg: "ini",
  jade: "pug",
  pug: "pug",
  java: "java",
  js: "javascript",
  mjs: "javascript",
  cjs: "javascript",
  jinja: "jinja",
  jinja2: "jinja",
  j2: "jinja",
  jison: "jison",
  jl: "julia",
  json: "json",
  json5: "json5",
  jsonc: "jsonc",
  jsonl: "jsonl",
  jsonnet: "jsonnet",
  libsonnet: "jsonnet",
  jssm: "jssm",
  jsx: "jsx",
  kt: "kotlin",
  kts: "kts",
  kql: "kusto",
  tex: "tex",
  ltx: "tex",
  lean: "lean4",
  less: "less",
  liquid: "liquid",
  lit: "lit",
  ll: "llvm",
  logo: "logo",
  lua: "lua",
  luau: "luau",
  Makefile: "makefile",
  mk: "makefile",
  makefile: "makefile",
  md: "markdown",
  markdown: "markdown",
  marko: "marko",
  m: "wolfram",
  mat: "matlab",
  mdc: "mdc",
  mdx: "mdx",
  wiki: "wikitext",
  mediawiki: "wikitext",
  mmd: "mermaid",
  mermaid: "mermaid",
  mips: "mipsasm",
  mojo: "mojo",
  "": "mojo",
  move: "move",
  nar: "narrat",
  nf: "nextflow",
  nim: "nim",
  nims: "nim",
  nimble: "nim",
  nix: "nix",
  nu: "nushell",
  mm: "objective-cpp",
  ml: "ocaml",
  mli: "ocaml",
  mll: "ocaml",
  mly: "ocaml",
  pas: "pascal",
  p: "pascal",
  pl: "prolog",
  pm: "perl",
  t: "perl",
  raku: "raku",
  p6: "raku",
  pl6: "raku",
  php: "php",
  phtml: "php",
  pls: "plsql",
  sql: "sql",
  po: "po",
  polar: "polar",
  pcss: "postcss",
  pot: "pot",
  potx: "potx",
  pq: "powerquery",
  pqm: "powerquery",
  ps1: "powershell",
  psm1: "powershell",
  psd1: "powershell",
  prisma: "prisma",
  pro: "prolog",
  P: "prolog",
  properties: "properties",
  proto: "protobuf",
  pp: "puppet",
  purs: "purescript",
  py: "python",
  pyw: "python",
  pyi: "python",
  qml: "qml",
  qmldir: "qmldir",
  qss: "qss",
  r: "r",
  R: "r",
  rkt: "racket",
  rktl: "racket",
  razor: "razor",
  cshtml: "razor",
  rb: "ruby",
  rbw: "ruby",
  reg: "reg",
  regex: "regexp",
  rel: "rel",
  rs: "rust",
  rst: "rst",
  rake: "ruby",
  gemspec: "ruby",
  sas: "sas",
  sass: "sass",
  scala: "scala",
  sc: "scala",
  scm: "scheme",
  ss: "scheme",
  sld: "scheme",
  scss: "scss",
  sdbl: "sdbl",
  shadergraph: "shader",
  st: "smalltalk",
  sol: "solidity",
  sparql: "sparql",
  rq: "sparql",
  spl: "splunk",
  config: "ssh-config",
  do: "stata",
  ado: "stata",
  dta: "stata",
  styl: "stylus",
  stylus: "stylus",
  svelte: "svelte",
  swift: "swift",
  sv: "system-verilog",
  svh: "system-verilog",
  service: "systemd",
  socket: "systemd",
  device: "systemd",
  timer: "systemd",
  talon: "talonscript",
  tasl: "tasl",
  tcl: "tcl",
  templ: "templ",
  tf: "tf",
  tfvars: "tfvars",
  toml: "toml",
  ts: "typescript",
  tsp: "typespec",
  tsv: "tsv",
  tsx: "tsx",
  ttl: "turtle",
  twig: "twig",
  typ: "typst",
  vv: "v",
  vala: "vala",
  vapi: "vala",
  vb: "vb",
  vbs: "vb",
  bas: "vb",
  vh: "verilog",
  vhd: "vhdl",
  vhdl: "vhdl",
  vim: "vimscript",
  vue: "vue",
  "vine.ts": "vue-vine",
  vy: "vyper",
  wasm: "wasm",
  wat: "wasm",
  wy: "",
  wgsl: "wgsl",
  wit: "wit",
  wl: "wolfram",
  nb: "wolfram",
  xml: "xml",
  xsl: "xsl",
  xslt: "xsl",
  yaml: "yaml",
  yml: "yml",
  zs: "zenscript",
  zig: "zig",
  zsh: "zsh",
  sty: "tex"
};
function getFiletypeFromFileName(fileName) {
  if (EXTENSION_TO_FILE_FORMAT[fileName] != null) return EXTENSION_TO_FILE_FORMAT[fileName];
  const compoundMatch = fileName.match(/\.([^/\\]+\.[^/\\]+)$/);
  if (compoundMatch != null && EXTENSION_TO_FILE_FORMAT[compoundMatch[1]] != null) return EXTENSION_TO_FILE_FORMAT[compoundMatch[1]] ?? "text";
  return EXTENSION_TO_FILE_FORMAT[fileName.match(/\.([^.]+)$/)?.[1] ?? ""] ?? "text";
}
function extendFileFormatMap(map) {
  for (const key in map) EXTENSION_TO_FILE_FORMAT[key] = map[key];
}

// node_modules/@pierre/precision-diffs/dist/utils/parseLineType.js
function parseLineType(line, maxLineLength) {
  const firstChar = line.substring(0, 1);
  if (firstChar !== "+" && firstChar !== "-" && firstChar !== " " && firstChar !== "\\") throw new Error(`parseLineType: Invalid firstChar: "${firstChar}", full line: "${line}"`);
  return {
    line: line.substring(1),
    type: firstChar === " " ? "context" : firstChar === "\\" ? "metadata" : firstChar === "+" ? "addition" : "deletion",
    longLine: line.length - 1 >= maxLineLength
  };
}

// node_modules/@pierre/precision-diffs/dist/utils/createMirroredAnnotationSpan.js
function createMirroredAnnotationSpan({ deletionLineNumber, additionLineNumber, hunkIndex, lineIndex, deletionAnnotations, additionAnnotations, unified }) {
  const dAnnotations = [];
  for (const anno of deletionAnnotations[deletionLineNumber] ?? []) dAnnotations.push(getLineAnnotationName(anno));
  const aAnnotations = [];
  for (const anno of additionAnnotations[additionLineNumber] ?? []) (unified ? dAnnotations : aAnnotations).push(getLineAnnotationName(anno));
  if (aAnnotations.length === 0 && dAnnotations.length === 0) {
    if (unified) return;
    return [void 0, void 0];
  }
  if (unified) return {
    type: "annotation",
    hunkIndex,
    lineIndex,
    annotations: dAnnotations
  };
  return [{
    type: "annotation",
    hunkIndex,
    lineIndex,
    annotations: dAnnotations
  }, {
    type: "annotation",
    hunkIndex,
    lineIndex,
    annotations: aAnnotations
  }];
}

// node_modules/@pierre/precision-diffs/dist/utils/createSingleAnnotationSpan.js
function createSingleAnnotationSpan({ rowNumber, hunkIndex, lineIndex, annotationMap }) {
  const span = {
    type: "annotation",
    hunkIndex,
    lineIndex,
    annotations: []
  };
  for (const anno of annotationMap[rowNumber] ?? []) span.annotations.push(getLineAnnotationName(anno));
  return span.annotations.length > 0 ? span : void 0;
}

// node_modules/@pierre/precision-diffs/dist/utils/formatCSSVariablePrefix.js
function formatCSSVariablePrefix(prefix = "pjs") {
  return `--${prefix}-`;
}

// node_modules/@pierre/precision-diffs/dist/utils/getHighlighterThemeStyles.js
function getHighlighterThemeStyles({ theme = DEFAULT_THEMES, highlighter: highlighter2, prefix }) {
  let styles = "";
  if (typeof theme === "string") {
    const themeData = highlighter2.getTheme(theme);
    styles += `color:${themeData.fg};`;
    styles += `background-color:${themeData.bg};`;
    styles += `${formatCSSVariablePrefix(prefix)}fg:${themeData.fg};`;
    styles += `${formatCSSVariablePrefix(prefix)}bg:${themeData.bg};`;
    styles += getThemeVariables(themeData, prefix);
  } else {
    let themeData = highlighter2.getTheme(theme.dark);
    styles += `${formatCSSVariablePrefix(prefix)}dark:${themeData.fg};`;
    styles += `${formatCSSVariablePrefix(prefix)}dark-bg:${themeData.bg};`;
    styles += getThemeVariables(themeData, prefix, "dark");
    themeData = highlighter2.getTheme(theme.light);
    styles += `${formatCSSVariablePrefix(prefix)}light:${themeData.fg};`;
    styles += `${formatCSSVariablePrefix(prefix)}light-bg:${themeData.bg};`;
    styles += getThemeVariables(themeData, prefix, "light");
  }
  return styles;
}
function getThemeVariables(themeData, prefix, modePrefix) {
  modePrefix = modePrefix != null ? `${modePrefix}-` : "";
  let styles = "";
  const additionGreen = themeData.colors?.["gitDecoration.addedResourceForeground"] ?? themeData.colors?.["terminal.ansiGreen"];
  if (additionGreen != null) styles += `${formatCSSVariablePrefix(prefix)}${modePrefix}addition-color:${additionGreen};`;
  const deletionRed = themeData.colors?.["gitDecoration.deletedResourceForeground"] ?? themeData.colors?.["terminal.ansiRed"];
  if (deletionRed != null) styles += `${formatCSSVariablePrefix(prefix)}${modePrefix}deletion-color:${deletionRed};`;
  const modifiedBlue = themeData.colors?.["gitDecoration.modifiedResourceForeground"] ?? themeData.colors?.["terminal.ansiBlue"];
  if (modifiedBlue != null) styles += `${formatCSSVariablePrefix(prefix)}${modePrefix}modified-color:${modifiedBlue};`;
  return styles;
}

// node_modules/@pierre/precision-diffs/dist/utils/getIconForType.js
function getIconForType(type) {
  switch (type) {
    case "file":
      return "pjs-icon-file-code";
    case "change":
      return "pjs-icon-symbol-modified";
    case "new":
      return "pjs-icon-symbol-added";
    case "deleted":
      return "pjs-icon-symbol-deleted";
    case "rename-pure":
    case "rename-changed":
      return "pjs-icon-symbol-moved";
  }
}

// node_modules/@pierre/precision-diffs/dist/utils/hast_utils.js
function createTextNode(value) {
  return {
    type: "text",
    value
  };
}
function createHastElement({ tagName, children = [], properties = {} }) {
  return {
    type: "element",
    tagName,
    properties,
    children
  };
}
function createSeparator({ type, content, expandIndex, slotName, isFirstHunk, isLastHunk }) {
  const children = [];
  if (type === "metadata" && content != null) children.push(createHastElement({
    tagName: "div",
    children: [createTextNode(content)],
    properties: { "data-separator-content": "" }
  }));
  if (type === "line-info" && content != null) {
    const contentChildren = [createTextNode(content)];
    if (expandIndex != null) contentChildren.unshift(createIcon({ name: "pjs-icon-chevrons-narrow" }));
    children.push(createHastElement({
      tagName: "div",
      children: contentChildren,
      properties: { "data-separator-content": "" }
    }));
  }
  if (type === "custom" && slotName != null) children.push(createHastElement({
    tagName: "slot",
    properties: { name: slotName }
  }));
  return createHastElement({
    tagName: "div",
    children,
    properties: {
      "data-separator": children.length === 0 ? "" : type,
      "data-expand-index": expandIndex,
      "data-separator-first": isFirstHunk ? "" : void 0,
      "data-separator-last": isLastHunk ? "" : void 0
    }
  });
}
function createIcon({ name, width = 16, height = 16, properties }) {
  return createHastElement({
    tagName: "svg",
    properties: {
      width,
      height,
      viewBox: "0 0 16 16",
      ...properties
    },
    children: [createHastElement({
      tagName: "use",
      properties: { href: `#${name.replace(/^#/, "")}` }
    })]
  });
}
function createAnnotationElement(span) {
  return createHastElement({
    tagName: "div",
    children: [createHastElement({
      tagName: "div",
      children: span.annotations?.map((slotId) => createHastElement({
        tagName: "slot",
        properties: { name: slotId }
      })),
      properties: { "data-annotation-content": "" }
    })],
    properties: { "data-line-annotation": `${span.hunkIndex},${span.lineIndex}` }
  });
}
function createEmptyRowBuffer(size) {
  return createHastElement({
    tagName: "div",
    properties: {
      "data-buffer": "",
      style: `grid-row: span ${size};min-height:calc(${size} * 1lh)`
    }
  });
}
function findCodeElement(nodes) {
  let firstChild = nodes.children[0];
  while (firstChild != null) {
    if (firstChild.type === "element" && firstChild.tagName === "code") return firstChild;
    if ("children" in firstChild) firstChild = firstChild.children[0];
    else firstChild = null;
  }
}
function convertLine(node, line, state) {
  const lineInfo = state.lineInfo[line];
  if (lineInfo == null) {
    console.error({
      node,
      line,
      state
    });
    throw new Error(`convertLine: line ${line}, contains no state.lineInfo`);
  }
  node.tagName = "span";
  node.properties["data-column-content"] = "";
  if (lineInfo.metadataContent != null) node.children.push(createHastElement({
    tagName: "span",
    children: [createTextNode(lineInfo.metadataContent)],
    properties: { "data-no-newline": "" }
  }));
  else if (node.children.length === 0) node.children.push(createTextNode("\n"));
  const children = [node];
  if (!state.disableLineNumbers) children.unshift(createHastElement({
    tagName: "span",
    children: lineInfo.metadataContent == null ? [{
      type: "text",
      value: `${lineInfo.lineNumber}`
    }] : [],
    properties: { "data-column-number": "" }
  }));
  return createHastElement({
    tagName: "div",
    children,
    properties: {
      "data-line": lineInfo.metadataContent == null ? `${lineInfo.lineNumber}` : "",
      "data-line-type": lineInfo.type
    }
  });
}
function createPreWrapperProperties({ diffIndicators = "bars", disableBackground = false, highlighter: highlighter2, overflow = "scroll", split, theme = DEFAULT_THEMES, themeType = "system", totalLines }) {
  const properties = {
    "data-pjs": "",
    "data-type": split ? "split" : "file",
    "data-overflow": overflow,
    style: getHighlighterThemeStyles({
      theme,
      highlighter: highlighter2
    }),
    tabIndex: 0
  };
  properties.style += `--pjs-min-number-column-width-default:${`${totalLines}`.length}ch;`;
  if (typeof theme === "string" && themeType !== "system") properties["data-theme-type"] = themeType;
  else if (typeof theme === "string") properties["data-theme-type"] = highlighter2.getTheme(theme).type;
  switch (diffIndicators) {
    case "bars":
    case "classic":
      properties["data-indicators"] = diffIndicators;
      break;
  }
  if (!disableBackground) properties["data-background"] = "";
  return properties;
}
function createFileHeaderElement({ fileOrDiff, theme, highlighter: highlighter2, prefix, themeType = "system" }) {
  const fileDiff = "type" in fileOrDiff ? fileOrDiff : void 0;
  const properties = {
    "data-pjs-header": "",
    style: getHighlighterThemeStyles({
      theme,
      highlighter: highlighter2,
      prefix
    })
  };
  if (fileDiff != null) properties["data-change-type"] = fileDiff.type;
  if (typeof theme === "string") properties["data-theme-type"] = highlighter2.getTheme(theme).type;
  else if (themeType !== "system") properties["data-theme-type"] = themeType;
  return createHastElement({
    tagName: "div",
    children: [createHeaderElement({
      name: fileOrDiff.name,
      prevName: "prevName" in fileOrDiff ? fileOrDiff.prevName : void 0,
      iconType: fileDiff?.type ?? "file"
    }), createMetadataElement(fileDiff)],
    properties
  });
}
function createHeaderElement({ name, prevName, iconType }) {
  const children = [createIcon({
    name: getIconForType(iconType),
    properties: { "data-change-icon": iconType }
  })];
  if (prevName != null) {
    children.push(createHastElement({
      tagName: "div",
      children: [createTextNode(prevName)],
      properties: { "data-prev-name": "" }
    }));
    children.push(createIcon({
      name: "pjs-icon-arrow",
      properties: { "data-rename-icon": "" }
    }));
  }
  children.push(createHastElement({
    tagName: "div",
    children: [createTextNode(name)],
    properties: { "data-title": "" }
  }));
  return createHastElement({
    tagName: "div",
    children,
    properties: { "data-header-content": "" }
  });
}
function createMetadataElement(fileDiff) {
  const children = [];
  if (fileDiff != null) {
    let additions = 0;
    let deletions = 0;
    for (const hunk of fileDiff.hunks) for (const line of hunk.hunkContent ?? []) if (line.startsWith("+")) additions++;
    else if (line.startsWith("-")) deletions++;
    if (deletions > 0) children.push(createHastElement({
      tagName: "span",
      children: [createTextNode(`-${deletions}`)],
      properties: { "data-deletions-count": "" }
    }));
    if (additions > 0) children.push(createHastElement({
      tagName: "span",
      children: [createTextNode(`+${additions}`)],
      properties: { "data-additions-count": "" }
    }));
    if (deletions === 0 && additions === 0) children.push(createHastElement({
      tagName: "span",
      children: [createTextNode("No diff")]
    }));
  }
  children.push(createHastElement({
    tagName: "slot",
    properties: { name: HEADER_METADATA_SLOT_ID }
  }));
  return createHastElement({
    tagName: "div",
    children,
    properties: { "data-metadata": "" }
  });
}

// node_modules/@pierre/precision-diffs/node_modules/@shikijs/transformers/dist/index.mjs
var symbol = Symbol("highlighted-lines");
function transformerStyleToClass(options = {}) {
  const {
    classPrefix = "__shiki_",
    classSuffix = "",
    classReplacer = (className) => className
  } = options;
  const classToStyle = /* @__PURE__ */ new Map();
  function stringifyStyle(style) {
    return Object.entries(style).map(([key, value]) => `${key}:${value}`).join(";");
  }
  function registerStyle(style) {
    const str = typeof style === "string" ? style : stringifyStyle(style);
    let className = classPrefix + cyrb53(str) + classSuffix;
    className = classReplacer(className);
    if (!classToStyle.has(className)) {
      classToStyle.set(
        className,
        typeof style === "string" ? style : { ...style }
      );
    }
    return className;
  }
  return {
    name: "@shikijs/transformers:style-to-class",
    pre(t) {
      if (!t.properties.style)
        return;
      const className = registerStyle(t.properties.style);
      delete t.properties.style;
      this.addClassToHast(t, className);
    },
    tokens(lines) {
      for (const line of lines) {
        for (const token of line) {
          if (!token.htmlStyle)
            continue;
          const className = registerStyle(token.htmlStyle);
          token.htmlStyle = {};
          token.htmlAttrs ||= {};
          if (!token.htmlAttrs.class)
            token.htmlAttrs.class = className;
          else
            token.htmlAttrs.class += ` ${className}`;
        }
      }
    },
    getClassRegistry() {
      return classToStyle;
    },
    getCSS() {
      let css = "";
      for (const [className, style] of classToStyle.entries()) {
        css += `.${className}{${typeof style === "string" ? style : stringifyStyle(style)}}`;
      }
      return css;
    },
    clearRegistry() {
      classToStyle.clear();
    }
  };
}
function cyrb53(str, seed = 0) {
  let h1 = 3735928559 ^ seed;
  let h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString(36).slice(0, 6);
}

// node_modules/@pierre/precision-diffs/dist/utils/createTransformerWithState.js
function createTransformerWithState({ disableLineNumbers, useCSSClasses }) {
  const state = {
    lineInfo: {},
    decorations: [],
    disableLineNumbers
  };
  const transformers = [{
    line(node) {
      delete node.properties.class;
      return node;
    },
    pre(pre) {
      const code = findCodeElement(pre);
      const children = [];
      if (code != null) {
        let index = 1;
        for (const node of code.children) {
          if (node.type !== "element") continue;
          if (index === 1 && state.lineInfo[0]?.spans != null) for (const span of state.lineInfo[0]?.spans ?? []) if (span.type === "gap") children.push(createEmptyRowBuffer(span.rows));
          else children.push(createAnnotationElement(span));
          children.push(convertLine(node, index, state));
          const lineInfo = state.lineInfo[index];
          if (lineInfo?.spans != null) for (const span of lineInfo.spans) if (span.type === "gap") children.push(createEmptyRowBuffer(span.rows));
          else children.push(createAnnotationElement(span));
          index++;
        }
        code.children = children;
      }
      return pre;
    }
  }];
  if (useCSSClasses) transformers.push(tokenStyleNormalizer, toClass);
  return {
    state,
    transformers,
    toClass
  };
}
var toClass = transformerStyleToClass({ classPrefix: "hl-" });
var tokenStyleNormalizer = {
  name: "token-style-normalizer",
  tokens(lines) {
    for (const line of lines) for (const token of line) {
      if (token.htmlStyle != null) continue;
      const style = {};
      if (token.color != null) style.color = token.color;
      if (token.bgColor != null) style["background-color"] = token.bgColor;
      if (token.fontStyle != null && token.fontStyle !== 0) {
        if ((token.fontStyle & 1) !== 0) style["font-style"] = "italic";
        if ((token.fontStyle & 2) !== 0) style["font-weight"] = "bold";
        if ((token.fontStyle & 4) !== 0) style["text-decoration"] = "underline";
      }
      if (Object.keys(style).length > 0) token.htmlStyle = style;
    }
  }
};

// node_modules/@pierre/precision-diffs/dist/utils/getThemes.js
function getThemes(theme = DEFAULT_THEMES) {
  const themesArr = [];
  if (typeof theme === "string") themesArr.push(theme);
  else {
    themesArr.push(theme.dark);
    themesArr.push(theme.light);
  }
  return themesArr;
}

// node_modules/@pierre/precision-diffs/dist/utils/getHighlighterOptions.js
function getHighlighterOptions(lang, options) {
  return {
    langs: [lang ?? "text"],
    themes: getThemes(options.theme),
    preferWasmHighlighter: options.preferWasmHighlighter
  };
}

// node_modules/@pierre/precision-diffs/dist/utils/getHunkSeparatorSlotName.js
function getHunkSeparatorSlotName(type, hunkIndex) {
  return `hunk-separator-${type}-${hunkIndex}`;
}

// node_modules/@pierre/precision-diffs/dist/utils/getTotalLineCountFromHunks.js
function getTotalLineCountFromHunks(hunks) {
  const lastHunk = hunks[hunks.length - 1];
  if (lastHunk == null) return 0;
  return Math.max(lastHunk.additionStart + lastHunk.additionCount, lastHunk.deletedStart + lastHunk.deletedCount);
}

// node_modules/diff/libesm/diff/base.js
var Diff = class {
  diff(oldStr, newStr, options = {}) {
    let callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if ("callback" in options) {
      callback = options.callback;
    }
    const oldString = this.castInput(oldStr, options);
    const newString = this.castInput(newStr, options);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options));
    const newTokens = this.removeEmpty(this.tokenize(newString, options));
    return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options, callback) {
    var _a;
    const done = (value) => {
      value = this.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return void 0;
      } else {
        return value;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path, added, removed, oldPosInc, options) {
    const last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || !!options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value, options) {
    return value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value, options) {
    return Array.from(value);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value = newTokens.slice(newPos, newPos + component.count);
          value = value.map(function(value2, i) {
            const oldValue = oldTokens[oldPos + i];
            return oldValue.length > value2.length ? oldValue : value2;
          });
          component.value = this.join(value);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
};

// node_modules/diff/libesm/diff/character.js
var CharacterDiff = class extends Diff {
};
var characterDiff = new CharacterDiff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}

// node_modules/diff/libesm/util/string.js
function longestCommonPrefix(str1, str2) {
  let i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
function longestCommonSuffix(str1, str2) {
  let i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error(`string ${JSON.stringify(string)} doesn't start with prefix ${JSON.stringify(oldPrefix)}; this is a bug`);
  }
  return newPrefix + string.slice(oldPrefix.length);
}
function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string + newSuffix;
  }
  if (string.slice(-oldSuffix.length) != oldSuffix) {
    throw Error(`string ${JSON.stringify(string)} doesn't end with suffix ${JSON.stringify(oldSuffix)}; this is a bug`);
  }
  return string.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
}
function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a, b) {
  let startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  let endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  const map = Array(endB);
  let k = 0;
  map[0] = 0;
  for (let j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map[j] = map[k];
    } else {
      map[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (let i = startA; i < a.length; i++) {
    while (k > 0 && a[i] != b[k]) {
      k = map[k];
    }
    if (a[i] == b[k]) {
      k++;
    }
  }
  return k;
}
function trailingWs(string) {
  let i;
  for (i = string.length - 1; i >= 0; i--) {
    if (!string[i].match(/\s/)) {
      break;
    }
  }
  return string.substring(i + 1);
}
function leadingWs(string) {
  const match = string.match(/^\s*/);
  return match ? match[0] : "";
}

// node_modules/diff/libesm/diff/word.js
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp(`[${extendedWordChars}]+|\\s+|[^${extendedWordChars}]`, "ug");
var WordDiff = class extends Diff {
  equals(left, right, options) {
    if (options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left.trim() === right.trim();
  }
  tokenize(value, options = {}) {
    let parts;
    if (options.intlSegmenter) {
      const segmenter = options.intlSegmenter;
      if (segmenter.resolvedOptions().granularity != "word") {
        throw new Error('The segmenter passed must have a granularity of "word"');
      }
      parts = Array.from(segmenter.segment(value), (segment) => segment.segment);
    } else {
      parts = value.match(tokenizeIncludingWhitespace) || [];
    }
    const tokens = [];
    let prevPart = null;
    parts.forEach((part) => {
      if (/\s/.test(part)) {
        if (prevPart == null) {
          tokens.push(part);
        } else {
          tokens.push(tokens.pop() + part);
        }
      } else if (prevPart != null && /\s/.test(prevPart)) {
        if (tokens[tokens.length - 1] == prevPart) {
          tokens.push(tokens.pop() + part);
        } else {
          tokens.push(prevPart + part);
        }
      } else {
        tokens.push(part);
      }
      prevPart = part;
    });
    return tokens;
  }
  join(tokens) {
    return tokens.map((token, i) => {
      if (i == 0) {
        return token;
      } else {
        return token.replace(/^\s+/, "");
      }
    }).join("");
  }
  postProcess(changes, options) {
    if (!changes || options.oneChangePerToken) {
      return changes;
    }
    let lastKeep = null;
    let insertion = null;
    let deletion = null;
    changes.forEach((change) => {
      if (change.added) {
        insertion = change;
      } else if (change.removed) {
        deletion = change;
      } else {
        if (insertion || deletion) {
          dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
        }
        lastKeep = change;
        insertion = null;
        deletion = null;
      }
    });
    if (insertion || deletion) {
      dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
    }
    return changes;
  }
};
var wordDiff = new WordDiff();
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    const oldWsPrefix = leadingWs(deletion.value);
    const oldWsSuffix = trailingWs(deletion.value);
    const newWsPrefix = leadingWs(insertion.value);
    const newWsSuffix = trailingWs(insertion.value);
    if (startKeep) {
      const commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      const commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      const ws = leadingWs(insertion.value);
      insertion.value = insertion.value.substring(ws.length);
    }
    if (endKeep) {
      const ws = leadingWs(endKeep.value);
      endKeep.value = endKeep.value.substring(ws.length);
    }
  } else if (startKeep && endKeep) {
    const newWsFull = leadingWs(endKeep.value), delWsStart = leadingWs(deletion.value), delWsEnd = trailingWs(deletion.value);
    const newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    const newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    const endKeepWsPrefix = leadingWs(endKeep.value);
    const deletionWsSuffix = trailingWs(deletion.value);
    const overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    const startKeepWsSuffix = trailingWs(startKeep.value);
    const deletionWsPrefix = leadingWs(deletion.value);
    const overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, overlap);
  }
}
var WordsWithSpaceDiff = class extends Diff {
  tokenize(value) {
    const regex = new RegExp(`(\\r?\\n)|[${extendedWordChars}]+|[^\\S\\n\\r]+|[^${extendedWordChars}]`, "ug");
    return value.match(regex) || [];
  }
};
var wordsWithSpaceDiff = new WordsWithSpaceDiff();
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordsWithSpaceDiff.diff(oldStr, newStr, options);
}

// node_modules/diff/libesm/diff/line.js
var LineDiff = class extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  equals(left, right, options) {
    if (options.ignoreWhitespace) {
      if (!options.newlineIsToken || !left.includes("\n")) {
        left = left.trim();
      }
      if (!options.newlineIsToken || !right.includes("\n")) {
        right = right.trim();
      }
    } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
      if (left.endsWith("\n")) {
        left = left.slice(0, -1);
      }
      if (right.endsWith("\n")) {
        right = right.slice(0, -1);
      }
    }
    return super.equals(left, right, options);
  }
};
var lineDiff = new LineDiff();
function diffLines(oldStr, newStr, options) {
  return lineDiff.diff(oldStr, newStr, options);
}
function tokenize(value, options) {
  if (options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  const retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i = 0; i < linesAndNewlines.length; i++) {
    const line = linesAndNewlines[i];
    if (i % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
}

// node_modules/diff/libesm/diff/sentence.js
function isSentenceEndPunct(char) {
  return char == "." || char == "!" || char == "?";
}
var SentenceDiff = class extends Diff {
  tokenize(value) {
    var _a;
    const result = [];
    let tokenStartI = 0;
    for (let i = 0; i < value.length; i++) {
      if (i == value.length - 1) {
        result.push(value.slice(tokenStartI));
        break;
      }
      if (isSentenceEndPunct(value[i]) && value[i + 1].match(/\s/)) {
        result.push(value.slice(tokenStartI, i + 1));
        i = tokenStartI = i + 1;
        while ((_a = value[i + 1]) === null || _a === void 0 ? void 0 : _a.match(/\s/)) {
          i++;
        }
        result.push(value.slice(tokenStartI, i + 1));
        tokenStartI = i + 1;
      }
    }
    return result;
  }
};
var sentenceDiff = new SentenceDiff();

// node_modules/diff/libesm/diff/css.js
var CssDiff = class extends Diff {
  tokenize(value) {
    return value.split(/([{}:;,]|\s+)/);
  }
};
var cssDiff = new CssDiff();

// node_modules/diff/libesm/diff/json.js
var JsonDiff = class extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize;
  }
  get useLongestToken() {
    return true;
  }
  castInput(value, options) {
    const { undefinedReplacement, stringifyReplacer = (k, v) => typeof v === "undefined" ? undefinedReplacement : v } = options;
    return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), null, "  ");
  }
  equals(left, right, options) {
    return super.equals(left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options);
  }
};
var jsonDiff = new JsonDiff();
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key === void 0 ? "" : key, obj);
  }
  let i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  let canonicalizedObj;
  if ("[object Array]" === Object.prototype.toString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, String(i));
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (typeof obj === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    const sortedKeys = [];
    let key2;
    for (key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        sortedKeys.push(key2);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      key2 = sortedKeys[i];
      canonicalizedObj[key2] = canonicalize(obj[key2], stack, replacementStack, replacer, key2);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}

// node_modules/diff/libesm/diff/array.js
var ArrayDiff = class extends Diff {
  tokenize(value) {
    return value.slice();
  }
  join(value) {
    return value;
  }
  removeEmpty(value) {
    return value;
  }
};
var arrayDiff = new ArrayDiff();

// node_modules/diff/libesm/patch/create.js
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  let optionsObj;
  if (!options) {
    optionsObj = {};
  } else if (typeof options === "function") {
    optionsObj = { callback: options };
  } else {
    optionsObj = options;
  }
  if (typeof optionsObj.context === "undefined") {
    optionsObj.context = 4;
  }
  const context = optionsObj.context;
  if (optionsObj.newlineIsToken) {
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  }
  if (!optionsObj.callback) {
    return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));
  } else {
    const { callback } = optionsObj;
    diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), { callback: (diff) => {
      const patch = diffLinesResultToPatch(diff);
      callback(patch);
    } }));
  }
  function diffLinesResultToPatch(diff) {
    if (!diff) {
      return;
    }
    diff.push({ value: "", lines: [] });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    const hunks = [];
    let oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    for (let i = 0; i < diff.length; i++) {
      const current = diff[i], lines = current.lines || splitLines2(current.value);
      current.lines = lines;
      if (current.added || current.removed) {
        if (!oldRangeStart) {
          const prev = diff[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = context > 0 ? contextLines(prev.lines.slice(-context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        for (const line of lines) {
          curRange.push((current.added ? "+" : "-") + line);
        }
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= context * 2 && i < diff.length - 2) {
            for (const line of contextLines(lines)) {
              curRange.push(line);
            }
          } else {
            const contextSize = Math.min(lines.length, context);
            for (const line of contextLines(lines.slice(0, contextSize))) {
              curRange.push(line);
            }
            const hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    }
    for (const hunk of hunks) {
      for (let i = 0; i < hunk.lines.length; i++) {
        if (hunk.lines[i].endsWith("\n")) {
          hunk.lines[i] = hunk.lines[i].slice(0, -1);
        } else {
          hunk.lines.splice(i + 1, 0, "\\ No newline at end of file");
          i++;
        }
      }
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
}
function formatPatch(patch) {
  if (Array.isArray(patch)) {
    return patch.map(formatPatch).join("\n");
  }
  const ret = [];
  if (patch.oldFileName == patch.newFileName) {
    ret.push("Index: " + patch.oldFileName);
  }
  ret.push("===================================================================");
  ret.push("--- " + patch.oldFileName + (typeof patch.oldHeader === "undefined" ? "" : "	" + patch.oldHeader));
  ret.push("+++ " + patch.newFileName + (typeof patch.newHeader === "undefined" ? "" : "	" + patch.newHeader));
  for (let i = 0; i < patch.hunks.length; i++) {
    const hunk = patch.hunks[i];
    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    for (const line of hunk.lines) {
      ret.push(line);
    }
  }
  return ret.join("\n") + "\n";
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (typeof options === "function") {
    options = { callback: options };
  }
  if (!(options === null || options === void 0 ? void 0 : options.callback)) {
    const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
    if (!patchObj) {
      return;
    }
    return formatPatch(patchObj);
  } else {
    const { callback } = options;
    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options), { callback: (patchObj) => {
      if (!patchObj) {
        callback(void 0);
      } else {
        callback(formatPatch(patchObj));
      }
    } }));
  }
}
function splitLines2(text) {
  const hasTrailingNl = text.endsWith("\n");
  const result = text.split("\n").map((line) => line + "\n");
  if (hasTrailingNl) {
    result.pop();
  } else {
    result.push(result.pop().slice(0, -1));
  }
  return result;
}

// node_modules/@pierre/precision-diffs/dist/utils/parseDiffDecorations.js
function parseDecorations({ diffGroups, disableDecorations = false, lineDiffType, maxLineDiffLength, diffStyle }) {
  const unified = diffStyle === "unified";
  const unifiedDecorations = [];
  const additionDecorations = [];
  const deletionDecorations = [];
  if (disableDecorations || lineDiffType === "none") return {
    unifiedDecorations,
    deletionDecorations,
    additionDecorations
  };
  for (const group of diffGroups) {
    const len = Math.min(group.additionLines.length, group.deletionLines.length);
    for (let i = 0; i < len; i++) {
      const deletionLine = group.deletionLines[i];
      const additionLine = group.additionLines[i];
      if (deletionLine == null || additionLine == null) break;
      if (deletionLine.length > maxLineDiffLength || additionLine.length > maxLineDiffLength) continue;
      const lineDiff2 = lineDiffType === "char" ? diffChars(deletionLine, additionLine) : diffWordsWithSpace(deletionLine, additionLine);
      const deletionSpans = [];
      const additionSpans = [];
      const enableJoin = lineDiffType === "word-alt";
      for (const item of lineDiff2) if (!item.added && !item.removed) {
        pushOrJoinSpan({
          item,
          arr: deletionSpans,
          enableJoin,
          isNeutral: true
        });
        pushOrJoinSpan({
          item,
          arr: additionSpans,
          enableJoin,
          isNeutral: true
        });
      } else if (item.removed) pushOrJoinSpan({
        item,
        arr: deletionSpans,
        enableJoin
      });
      else pushOrJoinSpan({
        item,
        arr: additionSpans,
        enableJoin
      });
      let spanIndex = 0;
      for (const span of additionSpans) {
        if (span[0] === 1) (unified ? unifiedDecorations : additionDecorations).push(createDiffSpanDecoration({
          line: group.additionStartIndex + i,
          spanStart: spanIndex,
          spanLength: span[1].length
        }));
        spanIndex += span[1].length;
      }
      spanIndex = 0;
      for (const span of deletionSpans) {
        if (span[0] === 1) (unified ? unifiedDecorations : deletionDecorations).push(createDiffSpanDecoration({
          line: group.deletionStartIndex + i,
          spanStart: spanIndex,
          spanLength: span[1].length
        }));
        spanIndex += span[1].length;
      }
    }
  }
  return {
    unifiedDecorations,
    deletionDecorations,
    additionDecorations
  };
}
function createDiffSpanDecoration({ line, spanStart, spanLength }) {
  return {
    start: {
      line,
      character: spanStart
    },
    end: {
      line,
      character: spanStart + spanLength
    },
    properties: { "data-diff-span": "" },
    alwaysWrap: true
  };
}
function pushOrJoinSpan({ item, arr, enableJoin, isNeutral = false }) {
  const lastItem = arr[arr.length - 1];
  if (lastItem == null || item.value === "\n" || !enableJoin) {
    arr.push([isNeutral ? 0 : 1, item.value]);
    return;
  }
  const isLastItemNeutral = lastItem[0] === 0;
  if (isNeutral === isLastItemNeutral || isNeutral && item.value.length === 1 && !isLastItemNeutral) {
    lastItem[1] += item.value;
    return;
  }
  arr.push([isNeutral ? 0 : 1, item.value]);
}

// node_modules/@pierre/precision-diffs/dist/utils/pushOrMergeSpan.js
function pushOrMergeSpan(span, index, spanMap) {
  if (span == null) return;
  let lineInfo = spanMap[index];
  if (lineInfo == null && index === 0 && span.type === "gap") {
    lineInfo = {
      type: "context",
      lineNumber: -1,
      lineIndex: -1,
      spans: []
    };
    spanMap[0] = lineInfo;
  } else if (lineInfo == null) {
    console.error("pushOrMergeSpan: Attempting to apply an invalid span", {
      span,
      index,
      spanMap
    });
    return;
  }
  const spans = lineInfo.spans ?? [];
  lineInfo.spans = spans;
  if (spans.length === 0) spans.push(span);
  else {
    let gapSize = span.type === "gap" ? span.rows : 0;
    const annotations = [];
    let merged = false;
    for (const item of spans) if (item.type === "annotation") {
      if (span.type === "annotation" && span.lineIndex === item.lineIndex) {
        merged = true;
        item.annotations = mergeAnnotations(item.annotations, span.annotations);
      }
      annotations.push(item);
    } else gapSize += item.rows;
    if (span.type === "annotation" && !merged) annotations.push(span);
    const spanMarkers = new Array(gapSize).fill(0);
    for (const annotation of annotations) {
      const annotationIndex = annotation.lineIndex - lineInfo.lineIndex;
      const currentItem = spanMarkers[annotationIndex];
      if (currentItem === 0 || currentItem == null) spanMarkers.splice(annotationIndex, 0, annotation);
      else currentItem.annotations = mergeAnnotations(currentItem.annotations, annotation.annotations);
    }
    const newSpans = [];
    let spanSize = 0;
    for (const item of spanMarkers) if (item === 0) spanSize++;
    else {
      if (spanSize > 0) {
        newSpans.push({
          type: "gap",
          rows: spanSize
        });
        spanSize = 0;
      }
      newSpans.push(item);
    }
    if (spanSize > 0) newSpans.push({
      type: "gap",
      rows: spanSize
    });
    lineInfo.spans = newSpans;
  }
}
function mergeAnnotations(base, newAnnotations) {
  if (newAnnotations.length === 0) return base;
  const baseSet = new Set(base);
  for (const item of newAnnotations) baseSet.add(item);
  return Array.from(baseSet);
}

// node_modules/@pierre/precision-diffs/dist/DiffHunksRenderer.js
var DiffHunksRenderer = class {
  highlighter;
  options;
  diff;
  expandedHunks = /* @__PURE__ */ new Set();
  deletionAnnotations = {};
  additionAnnotations = {};
  queuedDiff;
  queuedRender;
  computedLang = "text";
  constructor(options = { theme: DEFAULT_THEMES }) {
    this.options = options;
  }
  cleanUp() {
    this.highlighter = void 0;
    this.diff = void 0;
    this.queuedDiff = void 0;
    this.queuedRender = void 0;
  }
  setOptions(options) {
    this.options = options;
  }
  expandHunk(index) {
    this.expandedHunks.add(index);
  }
  isHunkExpanded(index) {
    return this.getOptionsWithDefaults().expandUnchanged || this.expandedHunks.has(index);
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setThemeType(themeType) {
    if (this.getOptionsWithDefaults().themeType === themeType) return;
    this.mergeOptions({ themeType });
  }
  setLineAnnotations(lineAnnotations) {
    this.additionAnnotations = {};
    this.deletionAnnotations = {};
    for (const annotation of lineAnnotations) {
      const map = (() => {
        switch (annotation.side) {
          case "deletions":
            return this.deletionAnnotations;
          case "additions":
            return this.additionAnnotations;
        }
      })();
      const arr = map[annotation.lineNumber] ?? [];
      map[annotation.lineNumber] = arr;
      arr.push(annotation);
    }
  }
  getOptionsWithDefaults() {
    const { diffIndicators = "bars", diffStyle = "split", disableBackground = false, disableLineNumbers = false, expandUnchanged = false, hunkSeparators = "line-info", lineDiffType = "word-alt", maxLineDiffLength = 1e3, maxLineLengthForHighlighting = 1e3, overflow = "scroll", theme = DEFAULT_THEMES, themeType = "system", useCSSClasses = false } = this.options;
    return {
      diffIndicators,
      diffStyle,
      disableBackground,
      disableLineNumbers,
      expandUnchanged,
      hunkSeparators,
      lineDiffType,
      maxLineDiffLength,
      maxLineLengthForHighlighting,
      overflow,
      theme,
      themeType,
      useCSSClasses
    };
  }
  async initializeHighlighter() {
    this.highlighter = await getSharedHighlighter(getHighlighterOptions(this.computedLang, this.options));
    return this.highlighter;
  }
  async render(diff) {
    this.queuedDiff = diff;
    if (this.queuedRender != null) return this.queuedRender;
    this.queuedRender = (async () => {
      this.computedLang = this.options.lang ?? getFiletypeFromFileName(diff.name);
      if (!hasLoadedLanguage(this.computedLang) || !hasLoadedThemes(getThemes(this.options.theme))) this.highlighter = void 0;
      this.highlighter ??= await this.initializeHighlighter();
      if (this.queuedDiff == null) return;
      return this.renderDiff(this.queuedDiff, this.highlighter);
    })();
    const result = await this.queuedRender;
    this.queuedDiff = void 0;
    this.queuedRender = void 0;
    return result;
  }
  renderDiff(fileDiff, highlighter2) {
    const { disableLineNumbers, diffStyle, overflow, themeType, disableBackground, diffIndicators, expandUnchanged, useCSSClasses, theme } = this.getOptionsWithDefaults();
    this.diff = fileDiff;
    const additionsAST = [];
    const deletionsAST = [];
    const unifiedAST = [];
    const { state, transformers, toClass: toClass2 } = createTransformerWithState({
      disableLineNumbers,
      useCSSClasses
    });
    let hunkIndex = 0;
    const hunkData = [];
    let prevHunk;
    const hunks = (() => {
      if (fileDiff.hunks.length > 0) return fileDiff.hunks;
      if (expandUnchanged && this.diff?.newLines != null && this.diff.newLines.length > 0) {
        const lineCount = this.diff.newLines.length + 1;
        return [{
          additionCount: 0,
          additionStart: lineCount,
          deletedCount: 0,
          deletedStart: lineCount,
          hunkContent: [],
          hunkContext: void 0,
          hunkSpecs: void 0
        }];
      }
      return [];
    })();
    for (const hunk of hunks) {
      this.renderHunks({
        hunk,
        prevHunk,
        hunkIndex,
        highlighter: highlighter2,
        state,
        transformers,
        isFirstHunk: hunkIndex === 0,
        isLastHunk: hunkIndex === fileDiff.hunks.length - 1,
        additionsAST,
        deletionsAST,
        unifiedAST,
        hunkData
      });
      hunkIndex++;
      prevHunk = hunk;
    }
    const totalLines = Math.max(getTotalLineCountFromHunks(fileDiff.hunks), fileDiff.newLines?.length ?? 0, fileDiff.oldLines?.length ?? 0);
    return {
      additionsAST: additionsAST.length > 0 ? additionsAST : void 0,
      deletionsAST: deletionsAST.length > 0 ? deletionsAST : void 0,
      unifiedAST: unifiedAST.length > 0 ? unifiedAST : void 0,
      hunkData,
      css: toClass2.getCSS(),
      preNode: createHastElement({
        tagName: "pre",
        properties: createPreWrapperProperties({
          diffIndicators,
          disableBackground,
          highlighter: highlighter2,
          overflow,
          split: diffStyle === "unified" ? false : additionsAST.length > 0 && additionsAST.length > 0,
          theme,
          themeType,
          totalLines
        })
      }),
      totalLines
    };
  }
  renderFullAST(result, children = []) {
    if (result.unifiedAST != null) children.push(createHastElement({
      tagName: "code",
      children: result.unifiedAST,
      properties: {
        "data-code": "",
        "data-unified": ""
      }
    }));
    if (result.deletionsAST != null) children.push(createHastElement({
      tagName: "code",
      children: result.deletionsAST,
      properties: {
        "data-code": "",
        "data-deletions": ""
      }
    }));
    if (result.additionsAST != null) children.push(createHastElement({
      tagName: "code",
      children: result.additionsAST,
      properties: {
        "data-code": "",
        "data-additions": ""
      }
    }));
    return {
      ...result.preNode,
      children
    };
  }
  renderFullHTML(result, tempChildren = []) {
    return toHtml(this.renderFullAST(result, tempChildren));
  }
  renderPartialHTML(children, columnType) {
    if (columnType == null) return toHtml(children);
    return toHtml(createHastElement({
      tagName: "code",
      children,
      properties: {
        "data-code": "",
        [`data-${columnType}`]: ""
      }
    }));
  }
  createHastOptions(transformers, decorations2, forceTextLang = false) {
    const { theme } = this.getOptionsWithDefaults();
    if (typeof theme === "string") return {
      theme,
      cssVariablePrefix: formatCSSVariablePrefix(),
      lang: forceTextLang ? "text" : this.computedLang,
      defaultColor: false,
      transformers,
      decorations: decorations2
    };
    return {
      themes: theme,
      cssVariablePrefix: formatCSSVariablePrefix(),
      lang: forceTextLang ? "text" : this.computedLang,
      defaultColor: false,
      transformers,
      decorations: decorations2
    };
  }
  renderHunks({ hunk, hunkIndex, highlighter: highlighter2, state, transformers, prevHunk, isFirstHunk, isLastHunk, additionsAST, deletionsAST, unifiedAST, hunkData }) {
    if (hunk.hunkContent == null) return;
    const { hunkSeparators } = this.getOptionsWithDefaults();
    const { additions, deletions, unified, hasLongLines } = this.processLines(hunk, hunkIndex, prevHunk, isLastHunk);
    const expandable = this.diff?.newLines != null;
    const generateLinesAST = (type, computed, linesAST) => {
      const content = computed.content.join("").replace(/\n$/, "");
      state.lineInfo = computed.lineInfo;
      const nodes = highlighter2.codeToHast(content, this.createHastOptions(transformers, computed.decorations, hasLongLines));
      if (!this.isHunkExpanded(hunkIndex)) {
        if (hunkSeparators === "line-info" || hunkSeparators === "custom") {
          const lines = (() => {
            const hunkStart = hunk.additionStart;
            if (prevHunk == null) return hunkStart - 1;
            return hunkStart - (prevHunk.additionStart + prevHunk.additionCount);
          })();
          if (lines > 0) {
            const slotName = getHunkSeparatorSlotName(type, hunkIndex);
            linesAST.push(createSeparator({
              type: hunkSeparators,
              content: getModifiedLinesString(lines),
              expandIndex: expandable ? hunkIndex : void 0,
              slotName,
              isFirstHunk,
              isLastHunk: false
            }));
            hunkData.push({
              slotName,
              lines,
              type,
              expandable
            });
          }
        } else if (hunkSeparators === "metadata" && hunk.hunkSpecs != null) linesAST.push(createSeparator({
          type: "metadata",
          content: hunk.hunkSpecs,
          isFirstHunk,
          isLastHunk: false
        }));
        else if (hunkSeparators === "simple" && hunkIndex > 0) linesAST.push(createSeparator({
          type: "simple",
          isFirstHunk,
          isLastHunk: false
        }));
      }
      for (const line of getLineNodes(nodes)) linesAST.push(line);
      if (isLastHunk && !this.isHunkExpanded(hunkIndex + 1) && this.diff?.newLines != null && (hunkSeparators === "line-info" || hunkSeparators === "custom")) {
        const lines = this.diff.newLines.length - (hunk.additionStart + hunk.additionCount - 1);
        if (lines > 0) {
          const slotName = getHunkSeparatorSlotName(type, hunkIndex + 1);
          linesAST.push(createSeparator({
            type: hunkSeparators,
            content: getModifiedLinesString(lines),
            expandIndex: expandable ? hunkIndex + 1 : void 0,
            slotName,
            isFirstHunk: false,
            isLastHunk
          }));
          hunkData.push({
            slotName,
            lines,
            type,
            expandable
          });
        }
      }
    };
    if (unified.content.length > 0) generateLinesAST("unified", unified, unifiedAST);
    if (deletions.content.length > 0) generateLinesAST("deletions", deletions, deletionsAST);
    if (additions.content.length > 0) generateLinesAST("additions", additions, additionsAST);
  }
  processLines(hunk, hunkIndex, prevHunk, isLastHunk) {
    const { maxLineLengthForHighlighting, diffStyle, expandUnchanged, lineDiffType, maxLineDiffLength } = this.getOptionsWithDefaults();
    const { deletionAnnotations, additionAnnotations } = this;
    const unified = diffStyle === "unified";
    let hasLongLines = false;
    const additionContent = [];
    const additionLineInfo = {};
    let additionLineNumber = hunk.additionStart - 1;
    const deletionContent = [];
    const deletionLineInfo = {};
    let deletionLineNumber = hunk.deletedStart - 1;
    const unifiedContent = [];
    const unifiedLineInfo = {};
    const diffGroups = [];
    const unresolvedSpans = [];
    let currentChangeGroup;
    function resolveUnresolvedSpans() {
      if (currentChangeGroup == null) {
        if (unresolvedSpans.length > 0) console.error("DiffHunksRenderer.processLines: resolveUnresolvedSpans: In a weird state...", unresolvedSpans);
        return;
      }
      for (const unresolvedSpan of unresolvedSpans) {
        const deletionIndex = currentChangeGroup.deletionStartIndex + unresolvedSpan.hunkIndex;
        const additionIndex = currentChangeGroup.additionStartIndex + unresolvedSpan.hunkIndex;
        const resolvedSpan = {
          type: "annotation",
          hunkIndex,
          lineIndex: unresolvedSpan.span.lineIndex,
          annotations: []
        };
        if (unresolvedSpan.type === "addition") pushOrMergeSpan(resolvedSpan, Math.min(deletionIndex, currentChangeGroup.deletionStartIndex + currentChangeGroup.deletionLines.length), deletionLineInfo);
        else pushOrMergeSpan(resolvedSpan, Math.min(additionIndex, currentChangeGroup.additionStartIndex + currentChangeGroup.additionLines.length), additionLineInfo);
      }
      unresolvedSpans.length = 0;
    }
    function addToChangeGroup(type, line, span) {
      if (currentChangeGroup == null) {
        currentChangeGroup = {
          deletionStartIndex: unified ? -1 : deletionContent.length,
          additionStartIndex: unified ? -1 : additionContent.length,
          deletionLines: [],
          additionLines: [],
          diffGroupStartIndex: lineIndex
        };
        diffGroups.push(currentChangeGroup);
      }
      if (unified) {
        if (type === "deletion" && currentChangeGroup.deletionStartIndex === -1) currentChangeGroup.deletionStartIndex = unifiedContent.length;
        if (type === "addition" && currentChangeGroup.additionStartIndex === -1) currentChangeGroup.additionStartIndex = unifiedContent.length;
      }
      if (type === "addition") currentChangeGroup.additionLines.push(line);
      else currentChangeGroup.deletionLines.push(line);
      if (span != null && !unified) unresolvedSpans.push({
        type,
        hunkIndex: type === "deletion" ? currentChangeGroup.deletionLines.length : currentChangeGroup.additionLines.length,
        span
      });
      return currentChangeGroup;
    }
    function createGapSpanIfNecessary() {
      if (!unified && lastType !== "context" && lastType != null && currentChangeGroup != null) {
        const additionGroupSize = currentChangeGroup.additionLines.length;
        const deletionGroupSize = currentChangeGroup.deletionLines.length;
        if (additionGroupSize > deletionGroupSize) pushOrMergeSpan({
          type: "gap",
          rows: additionGroupSize - deletionGroupSize
        }, deletionContent.length, deletionLineInfo);
        else if (deletionGroupSize > additionGroupSize) pushOrMergeSpan({
          type: "gap",
          rows: deletionGroupSize - additionGroupSize
        }, additionContent.length, additionLineInfo);
      }
      resolveUnresolvedSpans();
    }
    const processRawLine = (line, type, isExpandedContext = false) => {
      lineIndex++;
      if (type === "context") createGapSpanIfNecessary();
      if (type === "context") {
        if (currentChangeGroup != null) lineIndex = currentChangeGroup.diffGroupStartIndex + Math.max(currentChangeGroup.additionLines.length, currentChangeGroup.deletionLines.length);
        currentChangeGroup = void 0;
        if (unified) {
          unifiedContent.push(line);
          unifiedLineInfo[unifiedContent.length] = {
            type: isExpandedContext ? "context-expanded" : "context",
            lineNumber: additionLineNumber + 1,
            lineIndex
          };
          pushOrMergeSpan(createMirroredAnnotationSpan({
            deletionLineNumber: deletionLineNumber + 1,
            additionLineNumber: additionLineNumber + 1,
            hunkIndex,
            lineIndex: unifiedContent.length,
            deletionAnnotations,
            additionAnnotations,
            unified: true
          }), unifiedContent.length, unifiedLineInfo);
        } else {
          deletionContent.push(line);
          additionContent.push(line);
          deletionLineInfo[deletionContent.length] = {
            type: isExpandedContext ? "context-expanded" : "context",
            lineNumber: deletionLineNumber + 1,
            lineIndex
          };
          additionLineInfo[additionContent.length] = {
            type: isExpandedContext ? "context-expanded" : "context",
            lineNumber: additionLineNumber + 1,
            lineIndex
          };
          const [deletionSpan, additionSpan] = createMirroredAnnotationSpan({
            deletionLineNumber: deletionLineNumber + 1,
            additionLineNumber: additionLineNumber + 1,
            hunkIndex,
            lineIndex,
            deletionAnnotations,
            additionAnnotations,
            unified: false
          });
          pushOrMergeSpan(deletionSpan, deletionContent.length, deletionLineInfo);
          pushOrMergeSpan(additionSpan, additionContent.length, additionLineInfo);
        }
        additionLineNumber++;
        deletionLineNumber++;
      } else if (type === "metadata") {
        const lineInfo = {
          type: lastType === "addition" ? "change-addition" : lastType === "deletion" ? "change-deletion" : "context",
          lineNumber: -1,
          lineIndex: -1,
          metadataContent: line.trim()
        };
        if (unified) {
          unifiedContent.push("\n");
          unifiedLineInfo[unifiedContent.length] = lineInfo;
        } else {
          if (lastType === "context" || lastType === "deletion") {
            deletionContent.push("\n");
            deletionLineInfo[deletionContent.length] = lineInfo;
            addToChangeGroup("deletion", "\n");
          }
          if (lastType === "context" || lastType === "addition") {
            additionContent.push("\n");
            additionLineInfo[additionContent.length] = lineInfo;
            addToChangeGroup("addition", "\n");
          }
        }
      } else if (type === "deletion") {
        const { content, lineInfo } = /* @__PURE__ */ (() => unified ? {
          content: unifiedContent,
          lineInfo: unifiedLineInfo
        } : {
          content: deletionContent,
          lineInfo: deletionLineInfo
        })();
        const span = createSingleAnnotationSpan({
          rowNumber: deletionLineNumber + 1,
          hunkIndex,
          lineIndex,
          annotationMap: this.deletionAnnotations
        });
        addToChangeGroup("deletion", line, span);
        content.push(line);
        lineInfo[content.length] = {
          type: "change-deletion",
          lineNumber: deletionLineNumber + 1,
          lineIndex
        };
        pushOrMergeSpan(span, content.length, lineInfo);
        deletionLineNumber++;
      } else if (type === "addition") {
        if (lastType === "deletion" && !unified) lineIndex = currentChangeGroup?.diffGroupStartIndex ?? lineIndex;
        const { content, lineInfo } = /* @__PURE__ */ (() => unified ? {
          content: unifiedContent,
          lineInfo: unifiedLineInfo
        } : {
          content: additionContent,
          lineInfo: additionLineInfo
        })();
        const span = createSingleAnnotationSpan({
          rowNumber: additionLineNumber + 1,
          hunkIndex,
          lineIndex,
          annotationMap: this.additionAnnotations
        });
        addToChangeGroup("addition", line, span);
        content.push(line);
        lineInfo[content.length] = {
          type: "change-addition",
          lineNumber: additionLineNumber + 1,
          lineIndex
        };
        pushOrMergeSpan(span, content.length, lineInfo);
        additionLineNumber++;
      }
      lastType = type;
    };
    let lineIndex = -1;
    let lastType;
    if (this.isHunkExpanded(hunkIndex) && this.diff?.newLines != null) {
      const { expandAddedStart, expandDeletedStart } = (() => {
        if (prevHunk != null) return {
          expandAddedStart: prevHunk.additionStart + prevHunk.additionCount - 1,
          expandDeletedStart: prevHunk.deletedStart + prevHunk.deletedCount - 1
        };
        return {
          expandAddedStart: 0,
          expandDeletedStart: 0
        };
      })();
      if (additionLineNumber - expandAddedStart > 0) {
        additionLineNumber = expandAddedStart;
        deletionLineNumber = expandDeletedStart;
        for (let i = additionLineNumber; i < hunk.additionStart - 1; i++) {
          const line = this.diff.newLines[i];
          hasLongLines = hasLongLines || line.length > maxLineLengthForHighlighting;
          processRawLine(line, "context", expandUnchanged ? false : true);
        }
      }
    }
    for (const rawLine of hunk.hunkContent ?? []) {
      const { line, type, longLine } = parseLineType(rawLine, maxLineLengthForHighlighting);
      hasLongLines = hasLongLines || longLine;
      processRawLine(line, type);
    }
    createGapSpanIfNecessary();
    if (isLastHunk && this.isHunkExpanded(hunkIndex + 1) && this.diff?.newLines != null) for (let i = additionLineNumber; i < this.diff.newLines.length; i++) {
      const line = this.diff.newLines[i];
      hasLongLines = hasLongLines || line.length > maxLineLengthForHighlighting;
      processRawLine(line, "context", expandUnchanged ? false : true);
    }
    resolveUnresolvedSpans();
    const { unifiedDecorations, deletionDecorations, additionDecorations } = parseDecorations({
      diffGroups,
      lineDiffType,
      diffStyle,
      maxLineDiffLength
    });
    return {
      hasLongLines,
      additions: {
        content: additionContent,
        lineInfo: additionLineInfo,
        decorations: additionDecorations
      },
      deletions: {
        content: deletionContent,
        lineInfo: deletionLineInfo,
        decorations: deletionDecorations
      },
      unified: {
        content: unifiedContent,
        lineInfo: unifiedLineInfo,
        decorations: unifiedDecorations
      }
    };
  }
};
function getLineNodes(nodes) {
  let firstChild = nodes.children[0];
  while (firstChild != null) {
    if (firstChild.type === "element" && firstChild.tagName === "code") return firstChild.children;
    if ("children" in firstChild) firstChild = firstChild.children[0];
    else firstChild = null;
  }
  console.error(nodes);
  throw new Error("DiffHunksRenderer.getNodesToRender: Unable to find children");
}
function getModifiedLinesString(lines) {
  return `${lines} unmodified line${lines > 1 ? "s" : ""}`;
}

// node_modules/@pierre/precision-diffs/dist/FileHeaderRenderer.js
var FileHeaderRenderer = class {
  highlighter;
  constructor(options = { theme: DEFAULT_THEMES }) {
    this.options = options;
  }
  cleanUp() {
    this.highlighter = void 0;
    this.queuedRenderFileOrDiff = void 0;
    this.queuedRender = void 0;
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setOptions(options) {
    this.options = options;
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.mergeOptions({ themeType });
  }
  async initializeHighlighter() {
    this.highlighter = await getSharedHighlighter(getHighlighterOptions(void 0, this.options));
    return this.highlighter;
  }
  fileOrDiff;
  queuedRenderFileOrDiff;
  queuedRender;
  async render(fileOrDiff) {
    this.queuedRenderFileOrDiff = fileOrDiff;
    if (this.queuedRender != null) return this.queuedRender;
    this.queuedRender = (async () => {
      if (!hasLoadedThemes(getThemes(this.options.theme))) this.highlighter = void 0;
      this.highlighter ??= await this.initializeHighlighter();
      if (this.queuedRenderFileOrDiff == null) return;
      return this.renderHeader(this.queuedRenderFileOrDiff, this.highlighter);
    })();
    const result = await this.queuedRender;
    this.queuedRenderFileOrDiff = void 0;
    this.queuedRender = void 0;
    return result;
  }
  renderHeader(fileOrDiff, highlighter2) {
    this.fileOrDiff = fileOrDiff;
    return createFileHeaderElement({
      ...this.options,
      fileOrDiff,
      highlighter: highlighter2
    });
  }
  renderResultToHTML(element) {
    return toHtml(element);
  }
};

// node_modules/@pierre/precision-diffs/dist/MouseEventManager.js
function isLineEventData(data, mode) {
  if (data == null) return false;
  if (mode === "file") return data.type === "line";
  else return data.type === "diff-line";
}
function isExpandoEventData(data) {
  return data?.type === "line-info";
}
var MouseEventManager = class {
  hoveredRow;
  pre;
  constructor(mode, options) {
    this.mode = mode;
    this.options = options;
  }
  setOptions(options) {
    this.options = options;
  }
  cleanUp() {
    this.pre?.removeEventListener("click", this.handleMouseClick);
    this.pre?.removeEventListener("mousemove", this.handleMouseMove);
    this.pre?.removeEventListener("mouseout", this.handleMouseLeave);
    delete this.pre?.dataset.interactiveLines;
    delete this.pre?.dataset.interactiveLineNumbers;
    this.pre = void 0;
  }
  setup(pre) {
    const { __debugMouseEvents, onLineClick, onLineNumberClick, onLineEnter, onLineLeave, onHunkExpand } = this.options;
    this.cleanUp();
    this.pre = pre;
    if (onLineClick != null || onLineNumberClick != null || onHunkExpand != null) {
      pre.addEventListener("click", this.handleMouseClick);
      if (onLineClick != null) pre.dataset.interactiveLines = "";
      else if (onLineNumberClick != null) pre.dataset.interactiveLineNumbers = "";
      debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.attachEventListeners: Attaching click events for:", (() => {
        const reasons = [];
        if (__debugMouseEvents === "both" || __debugMouseEvents === "click") {
          if (onLineClick != null) reasons.push("onLineClick");
          if (onLineNumberClick != null) reasons.push("onLineNumberClick");
          if (onHunkExpand != null) reasons.push("expandable hunk separators");
        }
        return reasons;
      })());
    }
    if (onLineEnter != null || onLineLeave != null) {
      pre.addEventListener("mousemove", this.handleMouseMove);
      debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.attachEventListeners: Attaching mouse move event");
      if (onLineLeave != null) {
        pre.addEventListener("mouseleave", this.handleMouseLeave);
        debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.attachEventListeners: Attaching mouse leave event");
      }
    }
  }
  handleMouseClick = (event) => {
    debugLogIfEnabled(this.options.__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseClick:", event);
    this.handleMouseEvent({
      eventType: "click",
      event
    });
  };
  handleMouseMove = (event) => {
    debugLogIfEnabled(this.options.__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseMove:", event);
    this.handleMouseEvent({
      eventType: "move",
      event
    });
  };
  handleMouseLeave = (event) => {
    const { __debugMouseEvents } = this.options;
    debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseLeave: no event");
    if (this.hoveredRow == null) {
      debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseLeave: returned early, no .hoveredRow");
      return;
    }
    this.options.onLineLeave?.({
      ...this.hoveredRow,
      event
    });
    this.hoveredRow = void 0;
  };
  handleMouseEvent({ eventType, event }) {
    const { __debugMouseEvents } = this.options;
    const composedPath = event.composedPath();
    debugLogIfEnabled(__debugMouseEvents, eventType, "FileDiff.DEBUG.handleMouseEvent:", {
      eventType,
      composedPath
    });
    const data = this.getLineData(composedPath);
    debugLogIfEnabled(__debugMouseEvents, eventType, "FileDiff.DEBUG.handleMouseEvent: getLineData result:", data);
    const { onLineClick, onLineNumberClick, onLineEnter, onLineLeave, onHunkExpand } = this.options;
    switch (eventType) {
      case "move":
        if (isLineEventData(data, this.mode) && this.hoveredRow?.lineElement === data.lineElement) {
          debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseEvent: switch, 'move', returned early because same line");
          break;
        }
        if (this.hoveredRow != null) {
          debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseEvent: switch, 'move', clearing an existing hovered row and firing onLineLeave");
          onLineLeave?.({
            ...this.hoveredRow,
            event
          });
          this.hoveredRow = void 0;
        }
        if (isLineEventData(data, this.mode)) {
          debugLogIfEnabled(__debugMouseEvents, "move", "FileDiff.DEBUG.handleMouseEvent: switch, 'move', setting up a new hoveredRow and firing onLineEnter");
          this.hoveredRow = data;
          onLineEnter?.({
            ...this.hoveredRow,
            event
          });
        }
        break;
      case "click":
        debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', with data:", data);
        if (data == null) break;
        if (isExpandoEventData(data) && onHunkExpand != null) {
          debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', expanding a hunk");
          onHunkExpand(data.hunkIndex);
          break;
        }
        if (isLineEventData(data, this.mode)) if (onLineNumberClick != null && data.numberColumn) {
          debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', firing 'onLineNumberClick'");
          onLineNumberClick({
            ...data,
            event
          });
        } else if (onLineClick != null) {
          debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', firing 'onLineClick'");
          onLineClick({
            ...data,
            event
          });
        } else debugLogIfEnabled(__debugMouseEvents, "click", "FileDiff.DEBUG.handleMouseEvent: switch, 'click', fell through, no event to fire");
        break;
    }
  }
  getLineData(path) {
    let numberColumn = false;
    const lineElement = path.find((element) => {
      if (!(element instanceof HTMLElement)) return false;
      numberColumn = numberColumn || "columnNumber" in element.dataset;
      return "line" in element.dataset || "expandIndex" in element.dataset;
    });
    if (!(lineElement instanceof HTMLElement)) return void 0;
    if (lineElement.dataset.expandIndex != null) {
      const hunkIndex = parseInt(lineElement.dataset.expandIndex);
      if (isNaN(hunkIndex)) return;
      return {
        type: "line-info",
        hunkIndex
      };
    }
    const lineNumber = parseInt(lineElement.dataset.line ?? "");
    if (isNaN(lineNumber)) return;
    const lineType = lineElement.dataset.lineType;
    if (lineType !== "context" && lineType !== "context-expanded" && lineType !== "change-deletion" && lineType !== "change-addition") return;
    if (this.mode === "file") return {
      type: "line",
      lineElement,
      lineNumber,
      numberColumn
    };
    return {
      type: "diff-line",
      annotationSide: (() => {
        if (lineType === "change-deletion") return "deletions";
        if (lineType === "change-addition") return "additions";
        const parent = lineElement.closest("[data-code]");
        if (!(parent instanceof HTMLElement)) return "additions";
        return "deletions" in parent.dataset ? "deletions" : "additions";
      })(),
      lineType,
      lineElement,
      lineNumber,
      numberColumn
    };
  }
};
function debugLogIfEnabled(debugLogType = "none", logIfType, ...args) {
  switch (debugLogType) {
    case "none":
      return;
    case "both":
      break;
    case "click":
      if (logIfType !== "click") return;
      break;
    case "move":
      if (logIfType !== "move") return;
      break;
  }
  console.log(...args);
}
function getMouseEventOptions({ onLineClick, onLineNumberClick, onLineEnter, onLineLeave, __debugMouseEvents }, onHunkExpand) {
  return {
    onLineClick,
    onLineNumberClick,
    onLineEnter,
    onLineLeave,
    __debugMouseEvents,
    onHunkExpand
  };
}

// node_modules/@pierre/precision-diffs/dist/ResizeManager.js
var ResizeManager = class {
  observedNodes = /* @__PURE__ */ new Map();
  cleanUp() {
    this.resizeObserver?.disconnect();
    this.observedNodes.clear();
  }
  resizeObserver;
  setup(pre) {
    this.cleanUp();
    const annotationElements = pre.querySelectorAll('[data-line-annotation*=","]');
    this.resizeObserver ??= new ResizeObserver(this.handleResizeObserver);
    const codeElements = pre.querySelectorAll("code");
    for (const codeElement of codeElements) {
      let numberElement = codeElement.querySelector("[data-column-number]");
      if (!(numberElement instanceof HTMLElement)) numberElement = null;
      const item = {
        type: "code",
        codeElement,
        numberElement,
        codeWidth: "auto",
        numberWidth: 0
      };
      this.observedNodes.set(codeElement, item);
      this.resizeObserver.observe(codeElement);
      if (numberElement != null) {
        this.observedNodes.set(numberElement, item);
        this.resizeObserver.observe(numberElement);
      }
    }
    if (codeElements.length <= 1) return;
    const elementMap = /* @__PURE__ */ new Map();
    for (const element of annotationElements) {
      if (!(element instanceof HTMLElement)) continue;
      const { lineAnnotation = "" } = element.dataset;
      if (!/^\d+,\d+$/.test(lineAnnotation)) {
        console.error("DiffFileRenderer.setupResizeObserver: Invalid element or annotation", {
          lineAnnotation,
          element
        });
        continue;
      }
      let pairs = elementMap.get(lineAnnotation);
      if (pairs == null) {
        pairs = [];
        elementMap.set(lineAnnotation, pairs);
      }
      pairs.push(element);
    }
    for (const [key, pair] of elementMap) {
      if (pair.length !== 2) {
        console.error("DiffFileRenderer.setupResizeObserver: Bad Pair", key, pair);
        continue;
      }
      const [container1, container2] = pair;
      const child1 = container1.firstElementChild;
      const child2 = container2.firstElementChild;
      if (!(container1 instanceof HTMLElement) || !(container2 instanceof HTMLElement) || !(child1 instanceof HTMLElement) || !(child2 instanceof HTMLElement)) continue;
      const item = {
        type: "annotations",
        column1: {
          container: container1,
          child: child1,
          childHeight: 0
        },
        column2: {
          container: container2,
          child: child2,
          childHeight: 0
        },
        currentHeight: "auto"
      };
      this.observedNodes.set(child1, item);
      this.observedNodes.set(child2, item);
      this.resizeObserver.observe(child1);
      this.resizeObserver.observe(child2);
    }
  }
  handleResizeObserver = (entries) => {
    for (const entry of entries) {
      const { target, borderBoxSize } = entry;
      if (!(target instanceof HTMLElement)) {
        console.error("FileDiff.handleResizeObserver: Invalid element for ResizeObserver", entry);
        continue;
      }
      const item = this.observedNodes.get(target);
      if (item == null) {
        console.error("FileDiff.handleResizeObserver: Not a valid observed node", entry);
        continue;
      }
      const specs = borderBoxSize[0];
      if (item.type === "annotations") {
        const column = (() => {
          if (target === item.column1.child) return item.column1;
          if (target === item.column2.child) return item.column2;
        })();
        if (column == null) {
          console.error(`FileDiff.handleResizeObserver: Couldn't find a column for`, {
            item,
            target
          });
          continue;
        }
        column.childHeight = specs.blockSize;
        const newHeight = Math.max(item.column1.childHeight, item.column2.childHeight);
        if (newHeight !== item.currentHeight) {
          item.currentHeight = Math.max(newHeight, 0);
          item.column1.container.style.setProperty("--pjs-annotation-min-height", `${item.currentHeight}px`);
          item.column2.container.style.setProperty("--pjs-annotation-min-height", `${item.currentHeight}px`);
        }
      } else if (item.type === "code") {
        if (target === item.codeElement) {
          if (specs.inlineSize !== item.codeWidth) {
            item.codeWidth = specs.inlineSize;
            item.codeElement.style.setProperty("--pjs-column-content-width", `${Math.max(item.codeWidth - item.numberWidth, 0)}px`);
            item.codeElement.style.setProperty("--pjs-column-width", `${item.codeWidth}px`);
          }
        } else if (target === item.numberElement) {
          if (specs.inlineSize !== item.numberWidth) {
            item.numberWidth = specs.inlineSize;
            item.codeElement.style.setProperty("--pjs-column-number-width", `${item.numberWidth}px`);
            if (item.codeWidth !== "auto") item.codeElement.style.setProperty("--pjs-column-content-width", `${Math.max(item.codeWidth - item.numberWidth, 0)}px`);
          }
        }
      }
    }
  };
};

// node_modules/@pierre/precision-diffs/dist/utils/html_render_utils.js
function createSpanFromToken(token) {
  const element = document.createElement("span");
  element.style = stringifyTokenStyle(token.htmlStyle ?? getTokenStyleObject(token));
  element.textContent = token.content;
  return element;
}
function createRow(line) {
  const row = document.createElement("div");
  row.dataset.line = `${line}`;
  const lineColumn = document.createElement("div");
  lineColumn.dataset.columnNumber = "";
  lineColumn.textContent = `${line}`;
  const content = document.createElement("div");
  content.dataset.columnContent = "";
  row.appendChild(lineColumn);
  row.appendChild(content);
  return {
    row,
    content
  };
}
function createCodeNode({ pre, columnType } = {}) {
  const code = document.createElement("code");
  code.dataset.code = "";
  if (columnType != null) code.dataset[columnType] = "";
  pre?.appendChild(code);
  return code;
}
function setWrapperProps({ pre, highlighter: highlighter2, theme = DEFAULT_THEMES, split, wrap, themeType, diffIndicators, disableBackground, totalLines }) {
  const styles = getHighlighterThemeStyles({
    theme,
    highlighter: highlighter2
  });
  if (themeType === "system") delete pre.dataset.themeType;
  else pre.dataset.themeType = themeType;
  if (typeof theme === "string") {
    const themeData = highlighter2.getTheme(theme);
    pre.dataset.themeType = themeData.type;
  }
  switch (diffIndicators) {
    case "bars":
    case "classic":
      pre.dataset.indicators = diffIndicators;
      break;
    case "none":
      delete pre.dataset.indicators;
      break;
  }
  if (disableBackground) delete pre.dataset.background;
  else pre.dataset.background = "";
  pre.dataset.type = split ? "split" : "file";
  pre.dataset.overflow = wrap ? "wrap" : "scroll";
  pre.dataset.pjs = "";
  pre.tabIndex = 0;
  pre.style = styles;
  pre.style.setProperty("--pjs-min-number-column-width-default", `${`${totalLines}`.length}ch`);
  return pre;
}

// node_modules/@pierre/precision-diffs/dist/FileRenderer.js
var FileRenderer = class {
  highlighter;
  fileContent;
  constructor(options = { theme: DEFAULT_THEMES }) {
    this.options = options;
  }
  setOptions(options) {
    this.options = options;
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.mergeOptions({ themeType });
  }
  lineAnnotations = {};
  setLineAnnotations(lineAnnotations) {
    this.lineAnnotations = {};
    for (const annotation of lineAnnotations) {
      const arr = this.lineAnnotations[annotation.lineNumber] ?? [];
      this.lineAnnotations[annotation.lineNumber] = arr;
      arr.push(annotation);
    }
  }
  cleanUp() {
    this.highlighter = void 0;
    this.fileContent = void 0;
    this.queuedFile = void 0;
  }
  computedLang = "text";
  queuedFile;
  queuedRender;
  async render(file, useCSSClasses = false) {
    this.queuedFile = file;
    if (this.queuedRender != null) return this.queuedRender;
    this.queuedRender = (async () => {
      this.computedLang = this.options.lang ?? getFiletypeFromFileName(file.name);
      if (!hasLoadedLanguage(this.computedLang) || !hasLoadedThemes(getThemes(this.options.theme))) this.highlighter = void 0;
      this.highlighter ??= await this.initializeHighlighter();
      if (this.queuedFile == null) return;
      return this.renderFile(this.queuedFile, this.highlighter, useCSSClasses);
    })();
    const result = await this.queuedRender;
    this.queuedFile = void 0;
    this.queuedRender = void 0;
    return result;
  }
  renderFile(file, highlighter2, useCSSClasses) {
    const { theme, themeType, disableLineNumbers = false } = this.options;
    const { state, transformers, toClass: toClass2 } = createTransformerWithState({
      disableLineNumbers,
      useCSSClasses
    });
    const { lineInfoMap, hasLongLines } = this.computeLineInfo(file.contents);
    state.lineInfo = lineInfoMap;
    const codeAST = this.getLineNodes(highlighter2.codeToHast(file.contents.replace(/\n$/, ""), this.createHastOptions(transformers, void 0, hasLongLines)));
    return {
      codeAST,
      preNode: createHastElement({
        tagName: "pre",
        properties: createPreWrapperProperties({
          diffIndicators: "none",
          disableBackground: true,
          highlighter: highlighter2,
          overflow: this.options.overflow,
          split: false,
          theme,
          themeType,
          totalLines: codeAST.length
        })
      }),
      totalLines: codeAST.length,
      css: toClass2.getCSS()
    };
  }
  renderFullHTML(result) {
    return toHtml(this.renderFullAST(result));
  }
  renderFullAST(result, children = []) {
    children.push(createHastElement({
      tagName: "code",
      children: result.codeAST,
      properties: { "data-code": "" }
    }));
    return {
      ...result.preNode,
      children
    };
  }
  renderPartialHTML(children, includeCodeNode = false) {
    if (!includeCodeNode) return toHtml(children);
    return toHtml(createHastElement({
      tagName: "code",
      children,
      properties: { "data-code": "" }
    }));
  }
  getLineNodes(nodes) {
    let firstChild = nodes.children[0];
    while (firstChild != null) {
      if (firstChild.type === "element" && firstChild.tagName === "code") return firstChild.children;
      if ("children" in firstChild) firstChild = firstChild.children[0];
      else firstChild = null;
    }
    console.error(nodes);
    throw new Error("DiffHunksRenderer.getNodesToRender: Unable to find children");
  }
  computeLineInfo(contents) {
    const { startingLineNumber = 1, maxLineLengthForHighlighting = 1e3 } = this.options;
    const lineInfoMap = {};
    let hasLongLines = false;
    let lineIndex = 0;
    for (const line of contents.split(SPLIT_WITH_NEWLINES)) {
      hasLongLines = hasLongLines || line.length > maxLineLengthForHighlighting;
      const lineInfo = {
        type: "context",
        lineIndex,
        lineNumber: startingLineNumber + lineIndex
      };
      const annotations = this.lineAnnotations[startingLineNumber + lineIndex];
      if (annotations != null) lineInfo.spans = [{
        type: "annotation",
        hunkIndex: 0,
        lineIndex,
        annotations: annotations.map((annotation) => getLineAnnotationName(annotation))
      }];
      lineInfoMap[lineIndex + 1] = lineInfo;
      lineIndex++;
    }
    return {
      lineInfoMap,
      hasLongLines
    };
  }
  createHastOptions(transformers, decorations2, forceTextLang = false) {
    const { theme = DEFAULT_THEMES } = this.options;
    if (typeof theme === "string") return {
      theme,
      cssVariablePrefix: formatCSSVariablePrefix(),
      lang: forceTextLang ? "text" : this.computedLang,
      defaultColor: false,
      transformers,
      decorations: decorations2
    };
    return {
      themes: theme,
      cssVariablePrefix: formatCSSVariablePrefix(),
      lang: forceTextLang ? "text" : this.computedLang,
      defaultColor: false,
      transformers,
      decorations: decorations2
    };
  }
  async initializeHighlighter() {
    this.highlighter = await getSharedHighlighter(getHighlighterOptions(this.computedLang, this.options));
    return this.highlighter;
  }
};

// node_modules/@pierre/precision-diffs/dist/style.js
var style_default = ":host {\n  --pjs-bg: #fff;\n  --pjs-fg: #000;\n  --pjs-font-fallback:\n    'SF Mono', Monaco, Consolas, 'Ubuntu Mono', 'Liberation Mono',\n    'Courier New', monospace;\n  --pjs-header-font-fallback:\n    system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', 'Noto Sans',\n    'Liberation Sans', Arial, sans-serif;\n\n  --pjs-mixer: light-dark(black, white);\n  --pjs-gap-fallback: 8px;\n\n  /*\n    // Available CSS Color Overrides\n    --pjs-bg-buffer-override\n    --pjs-bg-hover-override\n    --pjs-bg-context-override\n    --pjs-bg-separator-override\n\n    --pjs-fg-number-override\n\n    --pjs-deletion-color-override\n    --pjs-addition-color-override\n    --pjs-modified-color-override\n\n    --pjs-bg-deletion-override\n    --pjs-bg-deletion-number-override\n    --pjs-bg-deletion-hover-override\n    --pjs-bg-deletion-emphasis-override\n\n    --pjs-bg-addition-override\n    --pjs-bg-addition-number-override\n    --pjs-bg-addition-hover-override\n    --pjs-bg-addition-emphasis-override\n\n    // Available CSS Layout Overrides\n    --pjs-gap-inline\n    --pjs-gap-block\n    --pjs-gap-style\n    --pjs-tab-size\n  */\n\n  color-scheme: light dark;\n  display: block;\n}\n\npre,\ncode {\n  margin: 0;\n  padding: 0;\n  display: block;\n  outline: none;\n}\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n  font-family: var(--pjs-font-family, var(--pjs-font-fallback));\n  font-size: var(--pjs-font-size, 14px);\n  line-height: var(--pjs-line-height, 20px);\n  font-feature-settings: var(--pjs-font-features);\n}\n\n[data-icon-sprite] {\n  display: none;\n}\n\n[data-pjs-header] *,\n[data-pjs-header] *::before,\n[data-pjs-header] *::after {\n  font-family: var(--pjs-header-font-family, var(--pjs-header-font-fallback));\n}\n\n[data-file-info] {\n  padding: 10px;\n  font-weight: 700;\n  color: var(--fg);\n  /* NOTE(amadeus): we cannot use 'in oklch' because current versions of cursor\n   * and vscode use an older build of chrome that appears to have a bug with\n   * color-mix and 'in oklch', so use 'in lab' instead */\n  background-color: color-mix(in lab, var(--bg) 98%, var(--fg));\n  border-block: 1px solid color-mix(in lab, var(--bg) 95%, var(--fg));\n}\n\n[data-pjs-header],\n[data-pjs] {\n  --pjs-bg: light-dark(var(--pjs-light-bg), var(--pjs-dark-bg));\n  /* NOTE(amadeus): we cannot use 'in oklch' because current versions of cursor\n   * and vscode use an older build of chrome that appears to have a bug with\n   * color-mix and 'in oklch', so use 'in lab' instead */\n  --pjs-bg-buffer: var(\n    --pjs-bg-buffer-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 92%, var(--pjs-mixer)),\n      color-mix(in lab, var(--pjs-bg) 92%, var(--pjs-mixer))\n    )\n  );\n  --pjs-bg-hover: var(\n    --pjs-bg-hover-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 97%, var(--pjs-mixer)),\n      color-mix(in lab, var(--pjs-bg) 91%, var(--pjs-mixer))\n    )\n  );\n  --pjs-bg-context: var(\n    --pjs-bg-context-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 98.5%, var(--pjs-mixer)),\n      color-mix(in lab, var(--pjs-bg) 92.5%, var(--pjs-mixer))\n    )\n  );\n  --pjs-bg-separator: var(\n    --pjs-bg-separator-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 96%, var(--pjs-mixer)),\n      color-mix(in lab, var(--pjs-bg) 85%, var(--pjs-mixer))\n    )\n  );\n\n  --pjs-fg: light-dark(var(--pjs-light), var(--pjs-dark));\n  --pjs-fg-number: var(\n    --pjs-fg-number-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-fg) 65%, var(--pjs-bg)),\n      color-mix(in lab, var(--pjs-fg) 65%, var(--pjs-bg))\n    )\n  );\n\n  --pjs-deletion-base: var(\n    --pjs-deletion-color-override,\n    light-dark(\n      var(\n        --pjs-light-deletion-color,\n        var(--pjs-deletion-color, rgb(255, 0, 0))\n      ),\n      var(--pjs-dark-deletion-color, var(--pjs-deletion-color, rgb(255, 0, 0)))\n    )\n  );\n  --pjs-addition-base: var(\n    --pjs-addition-color-override,\n    light-dark(\n      var(\n        --pjs-light-addition-color,\n        var(--pjs-addition-color, rgb(0, 255, 0))\n      ),\n      var(--pjs-dark-addition-color, var(--pjs-addition-color, rgb(0, 255, 0)))\n    )\n  );\n  --pjs-modified-base: var(\n    --pjs-modified-color-override,\n    light-dark(\n      var(\n        --pjs-light-modified-color,\n        var(--pjs-modified-color, rgb(0, 0, 255))\n      ),\n      var(--pjs-dark-modified-color, var(--pjs-modified-color, rgb(0, 0, 255)))\n    )\n  );\n\n  /* NOTE(amadeus): we cannot use 'in oklch' because current versions of cursor\n   * and vscode use an older build of chrome that appears to have a bug with\n   * color-mix and 'in oklch', so use 'in lab' instead */\n  --pjs-bg-deletion: var(\n    --pjs-bg-deletion-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 88%, var(--pjs-deletion-base)),\n      color-mix(in lab, var(--pjs-bg) 80%, var(--pjs-deletion-base))\n    )\n  );\n  --pjs-bg-deletion-number: var(\n    --pjs-bg-deletion-number-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 91%, var(--pjs-deletion-base)),\n      color-mix(in lab, var(--pjs-bg) 85%, var(--pjs-deletion-base))\n    )\n  );\n  --pjs-bg-deletion-hover: var(\n    --pjs-bg-deletion-hover-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 80%, var(--pjs-deletion-base)),\n      color-mix(in lab, var(--pjs-bg) 75%, var(--pjs-deletion-base))\n    )\n  );\n  --pjs-bg-deletion-emphasis: var(\n    --pjs-bg-deletion-emphasis-override,\n    light-dark(\n      rgb(from var(--pjs-deletion-base) r g b / 0.15),\n      rgb(from var(--pjs-deletion-base) r g b / 0.2)\n    )\n  );\n\n  --pjs-bg-addition: var(\n    --pjs-bg-addition-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 88%, var(--pjs-addition-base)),\n      color-mix(in lab, var(--pjs-bg) 80%, var(--pjs-addition-base))\n    )\n  );\n  --pjs-bg-addition-number: var(\n    --pjs-bg-addition-number-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 91%, var(--pjs-addition-base)),\n      color-mix(in lab, var(--pjs-bg) 85%, var(--pjs-addition-base))\n    )\n  );\n  --pjs-bg-addition-hover: var(\n    --pjs-bg-addition-hover-override,\n    light-dark(\n      color-mix(in lab, var(--pjs-bg) 80%, var(--pjs-addition-base)),\n      color-mix(in lab, var(--pjs-bg) 70%, var(--pjs-addition-base))\n    )\n  );\n  --pjs-bg-addition-emphasis: var(\n    --pjs-bg-addition-emphasis-override,\n    light-dark(\n      rgb(from var(--pjs-addition-base) r g b / 0.15),\n      rgb(from var(--pjs-addition-base) r g b / 0.2)\n    )\n  );\n\n  background-color: var(--pjs-bg);\n  color: var(--pjs-fg);\n}\n\n[data-pjs] {\n  --pjs-code-grid: minmax(min-content, max-content) 1fr;\n\n  [data-column-content] span {\n    color: light-dark(var(--pjs-light), var(--pjs-dark));\n    font-weight: var(--pjs-light-font-weight);\n    font-style: var(--pjs-light-font-style);\n  }\n}\n\n[data-column-number] {\n  grid-column: 1 / 2;\n}\n\n[data-column-content] {\n  grid-column: 2 / 3;\n}\n\n[data-pjs][data-dehydrated] {\n  --pjs-code-grid: minmax(min-content, max-content) minmax(0, 1fr);\n}\n\n@media (prefers-color-scheme: dark) {\n  [data-pjs-header],\n  [data-pjs] {\n    color-scheme: dark;\n  }\n\n  [data-pjs] [data-column-content] span {\n    font-weight: var(--pjs-dark-font-weight);\n    font-style: var(--pjs-dark-font-style);\n  }\n}\n\n[data-pjs-header][data-theme-type='light'],\n[data-pjs][data-theme-type='light'] {\n  color-scheme: light;\n}\n\n[data-pjs][data-theme-type='light'] [data-column-content] span {\n  font-weight: var(--pjs-light-font-weight);\n  font-style: var(--pjs-light-font-style);\n}\n\n[data-pjs-header][data-theme-type='dark'],\n[data-pjs][data-theme-type='dark'] {\n  color-scheme: dark;\n}\n\n[data-pjs][data-theme-type='dark'] [data-column-content] span {\n  font-weight: var(--pjs-dark-font-weight);\n  font-style: var(--pjs-dark-font-style);\n}\n\n[data-type='split'][data-overflow='wrap'] {\n  display: grid;\n  grid-auto-flow: dense;\n  grid-template-columns: repeat(2, var(--pjs-code-grid));\n}\n\n[data-type='split'][data-overflow='scroll'] {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 2px;\n}\n\n[data-code] {\n  display: block;\n  display: grid;\n  grid-auto-flow: dense;\n  grid-template-columns: var(--pjs-code-grid);\n  overflow-x: auto;\n  scrollbar-width: none;\n  overscroll-behavior-x: contain;\n  tab-size: var(--pjs-tab-size, 2);\n  align-self: flex-start;\n  padding-block: var(--pjs-gap-block, var(--pjs-gap-fallback));\n}\n\n[data-pjs][data-type='split'][data-overflow='wrap'] {\n  padding-block: var(--pjs-gap-block, var(--pjs-gap-fallback));\n}\n\n[data-pjs-header] ~ [data-pjs] [data-code],\n[data-pjs-header] ~ [data-pjs][data-overflow='wrap'] {\n  padding-top: 0;\n}\n\n[data-type='split'][data-overflow='wrap'] [data-code] {\n  display: contents;\n}\n\n[data-line-annotation],\n[data-line] {\n  position: relative;\n  display: grid;\n  grid-template-columns: subgrid;\n  grid-column: 1 / 3;\n}\n\n[data-interactive-lines] [data-line] {\n  cursor: pointer;\n}\n\n[data-type='split'][data-overflow='wrap'] [data-additions] [data-line],\n[data-type='split'][data-overflow='wrap'] [data-additions] [data-separator],\n[data-type='split'][data-overflow='wrap']\n  [data-additions]\n  [data-line-annotation] {\n  border-left: 2px solid var(--pjs-bg);\n}\n\n[data-buffer] {\n  position: sticky;\n  left: 0;\n  grid-column: 1 / 3;\n  user-select: none;\n  /* We multiply by 1.414 (2) to better approximate the diagonal repeat distance */\n  background-image: repeating-linear-gradient(\n    -45deg,\n    transparent,\n    transparent calc(3px * 1.414),\n    var(--pjs-bg-buffer) calc(3px * 1.414),\n    var(--pjs-bg-buffer) calc(4px * 1.414)\n  );\n  min-height: 1lh;\n  width: var(--pjs-column-width, auto);\n}\n\n[data-separator] {\n  grid-column: span 2;\n}\n\n[data-separator='metadata'],\n[data-separator]:empty {\n  min-height: 4px;\n  background-color: var(--pjs-bg-separator);\n  display: grid;\n  grid-template-columns: subgrid;\n}\n\n[data-separator-content] {\n  user-select: none;\n  fill: currentColor;\n}\n\n[data-separator='metadata'] [data-separator-content] {\n  grid-column: 2 / 3;\n  width: var(--pjs-column-content-width);\n  position: sticky;\n  left: var(--pjs-column-number-width);\n  padding: 4px 1ch;\n}\n\n[data-separator='line-info'] {\n  margin-block: var(--pjs-gap-block, var(--pjs-gap-fallback));\n}\n\n[data-separator='line-info'][data-separator-first] {\n  margin-top: 0;\n}\n\n[data-separator='line-info'][data-separator-last] {\n  margin-bottom: 0;\n}\n\n[data-separator='line-info'] [data-separator-content] {\n  position: sticky;\n  display: flex;\n  align-items: center;\n  gap: calc(1ch / 2);\n  padding: calc(1lh / 4) 1ch;\n  border-radius: 6px;\n  background-color: var(--pjs-bg-separator);\n  width: auto;\n  width: calc(var(--pjs-column-width) - var(--pjs-gap-fallback));\n  opacity: 0.65;\n  font-family: var(--pjs-header-font-family, var(--pjs-header-font-fallback));\n}\n\n[data-separator='line-info'][data-expand-index]:hover [data-separator-content] {\n  opacity: 1;\n}\n\n[data-separator][data-expand-index] {\n  cursor: pointer;\n}\n\n[data-type='file']\n  [data-code]\n  [data-separator='line-info']\n  [data-separator-content] {\n  left: var(--pjs-gap-inline, var(--pjs-gap-fallback));\n  margin-left: var(--pjs-gap-inline, var(--pjs-gap-fallback));\n  margin-right: var(--pjs-gap-inline, var(--pjs-gap-fallback));\n  width: calc(\n    var(--pjs-column-width) -\n      (var(--pjs-gap-inline, var(--pjs-gap-fallback)) * 2)\n  );\n}\n\n[data-type='split']\n  [data-deletions]\n  [data-separator='line-info']\n  [data-separator-content] {\n  left: var(--pjs-gap-fallback);\n  margin-left: var(--pjs-gap-fallback);\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n[data-type='split']\n  [data-additions]\n  [data-separator='line-info']\n  [data-separator-content] {\n  left: 0;\n  margin-right: var(--pjs-gap-inline, var(--pjs-gap-fallback));\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  flex-direction: row-reverse;\n}\n\n[data-line] {\n  background-color: var(--pjs-bg);\n  color: var(--pjs-fg);\n}\n\n[data-type='split'][data-overflow='wrap'] [data-deletions] {\n  [data-line-annotation],\n  [data-buffer],\n  [data-line],\n  [data-separator] {\n    grid-column: 1 / 3;\n  }\n}\n\n[data-line-annotation] {\n  min-height: var(--pjs-annotation-min-height, 0);\n  background-color: var(--pjs-bg-context);\n}\n\n[data-type='split'][data-overflow='wrap'] [data-additions] {\n  [data-line-annotation],\n  [data-buffer],\n  [data-line],\n  [data-separator] {\n    grid-column: 3 / 5;\n  }\n}\n\n[data-separator='custom'] {\n  display: grid;\n  grid-template-columns: subgrid;\n}\n\n[data-column-content],\n[data-column-number] {\n  position: relative;\n  padding-inline: 1ch;\n}\n\n[data-indicators='classic'] [data-column-content] {\n  padding-inline-start: 2ch;\n}\n\n[data-indicators='classic'] {\n  [data-line-type='change-addition'] [data-column-content]::before,\n  [data-line-type='change-deletion'] [data-column-content]::before {\n    display: inline-block;\n    width: 1ch;\n    height: 1lh;\n    position: absolute;\n    top: 0;\n    left: 0;\n    user-select: none;\n  }\n}\n\n[data-indicators='classic'] {\n  [data-line-type='change-addition'] [data-column-content]::before {\n    content: '+';\n    color: var(--pjs-addition-base);\n  }\n  [data-line-type='change-deletion'] [data-column-content]::before {\n    content: '-';\n    color: var(--pjs-deletion-base);\n  }\n}\n\n[data-indicators='bars'] {\n  [data-line-type='change-deletion'] [data-column-number]::before,\n  [data-line-type='change-addition'] [data-column-number]::before {\n    content: '';\n    display: block;\n    width: 4px;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    user-select: none;\n  }\n}\n\n[data-indicators='bars'] {\n  [data-line-type='change-deletion'] [data-column-number]::before {\n    background-image: linear-gradient(\n      0deg,\n      var(--pjs-bg-deletion) 50%,\n      var(--pjs-deletion-base) 50%\n    );\n    background-repeat: repeat;\n    background-size: 2px 2px;\n    background-size: calc(1lh / round(1lh / 2px)) calc(1lh / round(1lh / 2px));\n  }\n  [data-line-type='change-addition'] [data-column-number]::before {\n    background-color: var(--pjs-addition-base);\n  }\n}\n\n[data-overflow='wrap'] [data-column-content],\n[data-overflow='wrap'] [data-annotation-content] {\n  white-space: pre-wrap;\n  word-break: break-word;\n}\n\n[data-overflow='scroll'] [data-column-content] {\n  white-space: pre;\n  min-height: 1lh;\n}\n\n[data-column-number] {\n  box-sizing: content-box;\n  text-align: right;\n  position: sticky;\n  left: 0;\n  user-select: none;\n  background-color: var(--pjs-bg);\n  color: var(--pjs-fg-number);\n  z-index: 1;\n  min-width: var(\n    --pjs-min-number-column-width,\n    var(--pjs-min-number-column-width-default, 3ch)\n  );\n  padding-left: 2ch;\n  border-right: var(--pjs-gap-style, 1px solid var(--pjs-bg));\n}\n\n[data-interactive-line-numbers] [data-column-number] {\n  cursor: pointer;\n}\n\n[data-diff-span] {\n  border-radius: 3px;\n  box-decoration-break: clone;\n  -webkit-box-decoration-break: clone;\n}\n\n[data-line-type='change-addition'] {\n  [data-column-number] {\n    color: var(--pjs-addition-base);\n  }\n\n  [data-diff-span] {\n    background-color: var(--pjs-bg-addition-emphasis);\n  }\n}\n\n[data-line-type='change-deletion'] {\n  [data-column-number] {\n    color: var(--pjs-deletion-base);\n  }\n\n  [data-diff-span] {\n    background-color: var(--pjs-bg-deletion-emphasis);\n  }\n}\n\n[data-background] [data-line-type='change-addition'] {\n  background-color: var(--pjs-bg-addition);\n\n  [data-column-number] {\n    background-color: var(--pjs-bg-addition-number);\n  }\n}\n\n[data-background] [data-line-type='change-deletion'] {\n  background-color: var(--pjs-bg-deletion);\n\n  [data-column-number] {\n    background-color: var(--pjs-bg-deletion-number);\n  }\n}\n\n[data-line-type='context-expanded'] {\n  background-color: var(--pjs-bg-context);\n\n  [data-column-number] {\n    background-color: var(--pjs-bg-context);\n  }\n}\n\n[data-line]:hover {\n  [data-column-number],\n  [data-column-content] {\n    background-color: var(--pjs-bg-hover);\n  }\n}\n\n[data-background] [data-line]:hover {\n  &[data-line-type='change-deletion'] [data-column-number],\n  &[data-line-type='change-deletion'] [data-column-content] {\n    background-color: var(--pjs-bg-deletion-hover);\n  }\n\n  &[data-line-type='change-addition'] [data-column-number],\n  &[data-line-type='change-addition'] [data-column-content] {\n    background-color: var(--pjs-bg-addition-hover);\n  }\n}\n\n[data-pjs-header] {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  gap: var(--pjs-gap-inline, var(--pjs-gap-fallback));\n  min-height: calc(1lh + (var(--pjs-gap-block, var(--pjs-gap-fallback)) * 3));\n  padding-inline: 16px;\n}\n\n[data-header-content] {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  gap: var(--pjs-gap-inline, var(--pjs-gap-fallback));\n  min-width: 0;\n  white-space: nowrap;\n}\n\n[data-header-content] [data-prev-name],\n[data-header-content] [data-title] {\n  direction: rtl;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  min-width: 0;\n  white-space: nowrap;\n}\n\n[data-prev-name] {\n  opacity: 0.7;\n}\n\n[data-rename-icon] {\n  fill: currentColor;\n  flex-shrink: 0;\n  flex-grow: 0;\n}\n\n[data-pjs-header] [data-metadata] {\n  display: flex;\n  align-items: center;\n  gap: 1ch;\n  white-space: nowrap;\n}\n\n[data-pjs-header] [data-additions-count] {\n  font-family: var(--pjs-font-family, var(--pjs-font-fallback));\n  color: var(--pjs-addition-base);\n}\n\n[data-pjs-header] [data-deletions-count] {\n  font-family: var(--pjs-font-family, var(--pjs-font-fallback));\n  color: var(--pjs-deletion-base);\n}\n\n[data-no-newline] {\n  user-select: none;\n  opacity: 0.6;\n}\n\n[data-annotation-content] {\n  position: sticky;\n  left: var(--pjs-column-number-width, 0);\n  grid-column: 2 / -1;\n  width: var(--pjs-column-content-width, auto);\n  align-self: flex-start;\n  z-index: 2;\n}\n\n/* Undo some of the stuff that the 'pre' tag does */\n[data-annotation-slot] {\n  text-wrap-mode: wrap;\n  word-break: normal;\n  white-space-collapse: collapse;\n}\n\n[data-change-icon] {\n  fill: currentColor;\n  flex-shrink: 0;\n}\n\n[data-change-icon='change'],\n[data-change-icon='rename-pure'],\n[data-change-icon='rename-changed'] {\n  color: var(--pjs-modified-base);\n}\n\n[data-change-icon='new'] {\n  color: var(--pjs-addition-base);\n}\n\n[data-change-icon='deleted'] {\n  color: var(--pjs-deletion-base);\n}\n\n[data-change-icon='file'] {\n  opacity: 0.6;\n}\n";

// node_modules/@pierre/precision-diffs/dist/custom-components/Container.js
if (typeof HTMLElement !== "undefined" && customElements.get("file-diff") == null) {
  let sheet;
  class FileDiffContainer extends HTMLElement {
    constructor() {
      super();
      if (this.shadowRoot != null) return;
      const shadowRoot = this.attachShadow({ mode: "open" });
      if (sheet == null) {
        sheet = new CSSStyleSheet();
        sheet.replaceSync(`@layer base, theme, unsafe;
@layer base {
${style_default}
}`);
      }
      shadowRoot.adoptedStyleSheets = [sheet];
    }
  }
  customElements.define("file-diff", FileDiffContainer);
}
var PJSContainerLoaded = true;

// node_modules/@pierre/precision-diffs/dist/sprite.js
var SVGSpriteSheet = `<svg data-icon-sprite aria-hidden="true" width="0" height="0">
  <symbol id="pjs-icon-arrow">
    <path d="M8.46967 4.21967C8.17678 4.51256 8.17678 4.98744 8.46967 5.28033L10.4393 7.25H3.75C3.33579 7.25 3 7.58579 3 8C3 8.41421 3.33579 8.75 3.75 8.75H10.4393L8.46967 10.7197C8.17678 11.0126 8.17678 11.4874 8.46967 11.7803C8.76256 12.0732 9.23744 12.0732 9.53033 11.7803L12.7803 8.53033C13.0732 8.23744 13.0732 7.76256 12.7803 7.46967L9.53033 4.21967C9.23744 3.92678 8.76256 3.92678 8.46967 4.21967Z" />
  </symbol>
  <symbol id="pjs-icon-brand-github" viewBox="0 0 16 16">
    <path d="M8 0c4.42 0 8 3.58 8 8a8.01 8.01 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27s-1.36.09-2 .27c-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8"/>
  </symbol>
  <symbol id="pjs-icon-chevrons-narrow" viewBox="0 0 10 16">
    <path d="M4.47 2.22a.75.75 0 0 1 1.06 0l3.25 3.25a.75.75 0 0 1-1.06 1.06L5 3.81 2.28 6.53a.75.75 0 0 1-1.06-1.06zM1.22 9.47a.75.75 0 0 1 1.06 0L5 12.19l2.72-2.72a.75.75 0 0 1 1.06 1.06l-3.25 3.25a.75.75 0 0 1-1.06 0l-3.25-3.25a.75.75 0 0 1 0-1.06"/>
  </symbol>
  <symbol id="pjs-icon-diff-split" viewBox="0 0 16 16">
    <path d="M14 0H8.5v16H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2m-1.5 6.5v1h1a.5.5 0 0 1 0 1h-1v1a.5.5 0 0 1-1 0v-1h-1a.5.5 0 0 1 0-1h1v-1a.5.5 0 0 1 1 0"/><path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h5.5V0zm.5 7.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1 0-1" opacity=".3"/>
  </symbol>
  <symbol id="pjs-icon-diff-unified" viewBox="0 0 16 16">
    <path d="M16 14a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V8.5h16zm-8-4a.5.5 0 0 0-.5.5v1h-1a.5.5 0 0 0 0 1h1v1a.5.5 0 0 0 1 0v-1h1a.5.5 0 0 0 0-1h-1v-1A.5.5 0 0 0 8 10"/><path d="M14 0a2 2 0 0 1 2 2v5.5H0V2a2 2 0 0 1 2-2zM6.5 3.5a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1z" opacity=".4"/>
  </symbol>
  <symbol id="pjs-icon-file-code" viewBox="0 0 16 16">
    <path d="M10.75 0c.199 0 .39.08.53.22l3.5 3.5c.14.14.22.331.22.53v9A2.75 2.75 0 0 1 12.25 16h-8.5A2.75 2.75 0 0 1 1 13.25V2.75A2.75 2.75 0 0 1 3.75 0zm-7 1.5c-.69 0-1.25.56-1.25 1.25v10.5c0 .69.56 1.25 1.25 1.25h8.5c.69 0 1.25-.56 1.25-1.25V5h-1.25A2.25 2.25 0 0 1 10 2.75V1.5z"/><path d="M7.248 6.19a.75.75 0 0 1 .063 1.058L5.753 9l1.558 1.752a.75.75 0 0 1-1.122.996l-2-2.25a.75.75 0 0 1 0-.996l2-2.25a.75.75 0 0 1 1.06-.063M8.69 7.248a.75.75 0 1 1 1.12-.996l2 2.25a.75.75 0 0 1 0 .996l-2 2.25a.75.75 0 1 1-1.12-.996L10.245 9z"/>
  </symbol>
  <symbol id="pjs-icon-symbol-added" viewBox="0 0 16 16">
    <path d="M8 4a.75.75 0 0 1 .75.75v2.5h2.5a.75.75 0 0 1 0 1.5h-2.5v2.5a.75.75 0 0 1-1.5 0v-2.5h-2.5a.75.75 0 0 1 0-1.5h2.5v-2.5A.75.75 0 0 1 8 4"/><path d="M1.788 4.296c.196-.88.478-1.381.802-1.706s.826-.606 1.706-.802C5.194 1.588 6.387 1.5 8 1.5s2.806.088 3.704.288c.88.196 1.381.478 1.706.802s.607.826.802 1.706c.2.898.288 2.091.288 3.704s-.088 2.806-.288 3.704c-.195.88-.478 1.381-.802 1.706s-.826.607-1.706.802c-.898.2-2.091.288-3.704.288s-2.806-.088-3.704-.288c-.88-.195-1.381-.478-1.706-.802s-.606-.826-.802-1.706C1.588 10.806 1.5 9.613 1.5 8s.088-2.806.288-3.704M8 0C1.412 0 0 1.412 0 8s1.412 8 8 8 8-1.412 8-8-1.412-8-8-8"/>
  </symbol>
  <symbol id="pjs-icon-symbol-deleted" viewBox="0 0 16 16">
    <path d="M4 8a.75.75 0 0 1 .75-.75h6.5a.75.75 0 0 1 0 1.5h-6.5A.75.75 0 0 1 4 8"/><path d="M1.788 4.296c.196-.88.478-1.381.802-1.706s.826-.606 1.706-.802C5.194 1.588 6.387 1.5 8 1.5s2.806.088 3.704.288c.88.196 1.381.478 1.706.802s.607.826.802 1.706c.2.898.288 2.091.288 3.704s-.088 2.806-.288 3.704c-.195.88-.478 1.381-.802 1.706s-.826.607-1.706.802c-.898.2-2.091.288-3.704.288s-2.806-.088-3.704-.288c-.88-.195-1.381-.478-1.706-.802s-.606-.826-.802-1.706C1.588 10.806 1.5 9.613 1.5 8s.088-2.806.288-3.704M8 0C1.412 0 0 1.412 0 8s1.412 8 8 8 8-1.412 8-8-1.412-8-8-8"/>
  </symbol>
  <symbol id="pjs-icon-symbol-diffstat" viewBox="0 0 16 16">
    <path d="M1.788 4.296c.196-.88.478-1.381.802-1.706s.826-.606 1.706-.802C5.194 1.588 6.387 1.5 8 1.5s2.806.088 3.704.288c.88.196 1.381.478 1.706.802s.607.826.802 1.706c.2.898.288 2.091.288 3.704s-.088 2.806-.288 3.704c-.195.88-.478 1.381-.802 1.706s-.826.607-1.706.802c-.898.2-2.091.288-3.704.288s-2.806-.088-3.704-.288c-.88-.195-1.381-.478-1.706-.802s-.606-.826-.802-1.706C1.588 10.806 1.5 9.613 1.5 8s.088-2.806.288-3.704M8 0C1.412 0 0 1.412 0 8s1.412 8 8 8 8-1.412 8-8-1.412-8-8-8"/><path d="M8.75 4.296a.75.75 0 0 0-1.5 0V6.25h-2a.75.75 0 0 0 0 1.5h2v1.5h1.5v-1.5h2a.75.75 0 0 0 0-1.5h-2zM5.25 10a.75.75 0 0 0 0 1.5h5.5a.75.75 0 0 0 0-1.5z"/>
  </symbol>
  <symbol id="pjs-icon-symbol-ignored" viewBox="0 0 16 16">
    <path d="M1.5 8c0 1.613.088 2.806.288 3.704.196.88.478 1.381.802 1.706s.826.607 1.706.802c.898.2 2.091.288 3.704.288s2.806-.088 3.704-.288c.88-.195 1.381-.478 1.706-.802s.607-.826.802-1.706c.2-.898.288-2.091.288-3.704s-.088-2.806-.288-3.704c-.195-.88-.478-1.381-.802-1.706s-.826-.606-1.706-.802C10.806 1.588 9.613 1.5 8 1.5s-2.806.088-3.704.288c-.88.196-1.381.478-1.706.802s-.606.826-.802 1.706C1.588 5.194 1.5 6.387 1.5 8M0 8c0-6.588 1.412-8 8-8s8 1.412 8 8-1.412 8-8 8-8-1.412-8-8m11.53-2.47a.75.75 0 0 0-1.06-1.06l-6 6a.75.75 0 1 0 1.06 1.06z"/>
  </symbol>
  <symbol id="pjs-icon-symbol-modified" viewBox="0 0 16 16">
    <path d="M1.5 8c0 1.613.088 2.806.288 3.704.196.88.478 1.381.802 1.706s.826.607 1.706.802c.898.2 2.091.288 3.704.288s2.806-.088 3.704-.288c.88-.195 1.381-.478 1.706-.802s.607-.826.802-1.706c.2-.898.288-2.091.288-3.704s-.088-2.806-.288-3.704c-.195-.88-.478-1.381-.802-1.706s-.826-.606-1.706-.802C10.806 1.588 9.613 1.5 8 1.5s-2.806.088-3.704.288c-.88.196-1.381.478-1.706.802s-.606.826-.802 1.706C1.588 5.194 1.5 6.387 1.5 8M0 8c0-6.588 1.412-8 8-8s8 1.412 8 8-1.412 8-8 8-8-1.412-8-8m8 3a3 3 0 1 0 0-6 3 3 0 0 0 0 6"/>
  </symbol>
  <symbol id="pjs-icon-symbol-moved" viewBox="0 0 16 16">
    <path d="M1.788 4.296c.196-.88.478-1.381.802-1.706s.826-.606 1.706-.802C5.194 1.588 6.387 1.5 8 1.5s2.806.088 3.704.288c.88.196 1.381.478 1.706.802s.607.826.802 1.706c.2.898.288 2.091.288 3.704s-.088 2.806-.288 3.704c-.195.88-.478 1.381-.802 1.706s-.826.607-1.706.802c-.898.2-2.091.288-3.704.288s-2.806-.088-3.704-.288c-.88-.195-1.381-.478-1.706-.802s-.606-.826-.802-1.706C1.588 10.806 1.5 9.613 1.5 8s.088-2.806.288-3.704M8 0C1.412 0 0 1.412 0 8s1.412 8 8 8 8-1.412 8-8-1.412-8-8-8"/><path d="M8.495 4.695a.75.75 0 0 0-.05 1.06L10.486 8l-2.041 2.246a.75.75 0 0 0 1.11 1.008l2.5-2.75a.75.75 0 0 0 0-1.008l-2.5-2.75a.75.75 0 0 0-1.06-.051m-4 0a.75.75 0 0 0-.05 1.06l2.044 2.248-1.796 1.995a.75.75 0 0 0 1.114 1.004l2.25-2.5a.75.75 0 0 0-.002-1.007l-2.5-2.75a.75.75 0 0 0-1.06-.05"/>
  </symbol>
  <symbol id="pjs-icon-symbol-ref" viewBox="0 0 16 16">
    <path d="M1.5 8c0 1.613.088 2.806.288 3.704.196.88.478 1.381.802 1.706.286.286.71.54 1.41.73V1.86c-.7.19-1.124.444-1.41.73-.324.325-.606.826-.802 1.706C1.588 5.194 1.5 6.387 1.5 8m4 6.397c.697.07 1.522.103 2.5.103 1.613 0 2.806-.088 3.704-.288.88-.195 1.381-.478 1.706-.802s.607-.826.802-1.706c.2-.898.288-2.091.288-3.704s-.088-2.806-.288-3.704c-.195-.88-.478-1.381-.802-1.706s-.826-.606-1.706-.802C10.806 1.588 9.613 1.5 8 1.5c-.978 0-1.803.033-2.5.103zM0 8c0-6.588 1.412-8 8-8s8 1.412 8 8-1.412 8-8 8-8-1.412-8-8m7-2a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1z"/>
  </symbol>
</svg>`;

// node_modules/@pierre/precision-diffs/dist/File.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);
var instanceId = -1;
var File = class {
  static LoadedCustomComponent = PJSContainerLoaded;
  __id = ++instanceId;
  fileContainer;
  spriteSVG;
  pre;
  code;
  unsafeCSSStyle;
  headerElement;
  headerMetadata;
  fileRenderer;
  headerRenderer;
  resizeManager;
  mouseEventManager;
  annotationElements = [];
  lineAnnotations = [];
  file;
  constructor(options = { theme: DEFAULT_THEMES }, isContainerManaged = false) {
    this.options = options;
    this.isContainerManaged = isContainerManaged;
    this.fileRenderer = new FileRenderer(options);
    this.headerRenderer = new FileHeaderRenderer(options);
    this.resizeManager = new ResizeManager();
    this.mouseEventManager = new MouseEventManager("file", getMouseEventOptions(options));
  }
  setOptions(options) {
    if (options == null) return;
    this.options = options;
    this.mouseEventManager.setOptions(getMouseEventOptions(options));
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.mergeOptions({ themeType });
    this.headerRenderer.setThemeType(themeType);
    this.fileRenderer.setThemeType(themeType);
    if (this.headerElement != null) if (themeType === "system") delete this.headerElement.dataset.themeType;
    else this.headerElement.dataset.themeType = themeType;
    if (this.pre != null) switch (themeType) {
      case "system":
        delete this.pre.dataset.themeType;
        break;
      case "light":
      case "dark":
        this.pre.dataset.themeType = themeType;
        break;
    }
  }
  setLineAnnotations(lineAnnotations) {
    this.lineAnnotations = lineAnnotations;
  }
  cleanUp() {
    this.fileRenderer.cleanUp();
    this.headerRenderer.cleanUp();
    this.resizeManager.cleanUp();
    this.mouseEventManager.cleanUp();
    this.file = void 0;
    if (!this.isContainerManaged) this.fileContainer?.parentNode?.removeChild(this.fileContainer);
    this.fileContainer = void 0;
    this.pre = void 0;
    this.headerElement = void 0;
  }
  async hydrate(props) {
    if (props.fileContainer == null) throw new Error("FileDiff: you must provide a fileContainer on hydration");
    for (const element of Array.from(props.fileContainer.shadowRoot?.children ?? [])) {
      if (element instanceof SVGElement) {
        this.spriteSVG = element;
        continue;
      }
      if (!(element instanceof HTMLElement)) continue;
      if (element instanceof HTMLPreElement) {
        this.pre = element;
        continue;
      }
      if (element instanceof HTMLStyleElement) {
        this.unsafeCSSStyle = element;
        continue;
      }
      if ("pjsHeader" in element.dataset) {
        this.headerElement = element;
        continue;
      }
    }
    if (this.pre == null) await this.render(props);
    else {
      this.fileContainer = props.fileContainer;
      delete this.pre.dataset.dehydrated;
      this.lineAnnotations = props.lineAnnotations ?? this.lineAnnotations;
      this.file = props.file;
      this.fileRenderer.initializeHighlighter();
      this.renderAnnotations();
      this.injectUnsafeCSS();
      this.mouseEventManager.setup(this.pre);
      if ((this.options.overflow ?? "scroll") === "scroll") this.resizeManager.setup(this.pre);
    }
  }
  async render({ file, fileContainer, containerWrapper, forceRender = false, lineAnnotations }) {
    if (!forceRender && (0, import_fast_deep_equal.default)(this.file, file)) return;
    this.file = file;
    this.fileRenderer.setOptions(this.options);
    if (lineAnnotations != null) {
      this.fileRenderer.setLineAnnotations(lineAnnotations);
      this.setLineAnnotations(lineAnnotations);
    }
    const { disableFileHeader = false } = this.options;
    if (disableFileHeader) {
      this.headerRenderer.cleanUp();
      if (this.headerElement != null) {
        this.headerElement.parentNode?.removeChild(this.headerElement);
        this.headerElement = void 0;
      }
    } else this.headerRenderer.setOptions(this.options);
    const [highlighter2, headerResult, fileResult] = await Promise.all([
      getSharedHighlighter({
        themes: getThemes(this.options.theme),
        langs: []
      }),
      !disableFileHeader ? this.headerRenderer.render(file) : void 0,
      this.fileRenderer.render(file)
    ]);
    if (headerResult == null && fileResult == null) return;
    fileContainer = this.getOrCreateFileContainer(fileContainer);
    if (headerResult != null) this.applyHeaderToDOM(headerResult, fileContainer);
    if (fileResult != null) {
      if (containerWrapper != null) containerWrapper.appendChild(fileContainer);
      const pre = this.getOrCreatePre(fileContainer);
      this.applyHunksToDOM(fileResult, pre, highlighter2);
      this.renderAnnotations();
    }
  }
  renderAnnotations() {
    if (this.isContainerManaged || this.fileContainer == null) return;
    for (const element of this.annotationElements) element.parentNode?.removeChild(element);
    this.annotationElements.length = 0;
    const { renderAnnotation } = this.options;
    if (renderAnnotation != null && this.lineAnnotations.length > 0) for (const annotation of this.lineAnnotations) {
      const content = renderAnnotation(annotation);
      if (content == null) continue;
      const el = document.createElement("div");
      el.dataset.annotationSlot = "";
      el.slot = getLineAnnotationName(annotation);
      el.appendChild(content);
      this.annotationElements.push(el);
      this.fileContainer.appendChild(el);
    }
  }
  injectUnsafeCSS() {
    if (this.fileContainer?.shadowRoot == null) return;
    const { unsafeCSS } = this.options;
    if (unsafeCSS == null || unsafeCSS === "") return;
    if (this.unsafeCSSStyle == null) {
      this.unsafeCSSStyle = document.createElement("style");
      this.fileContainer.shadowRoot.appendChild(this.unsafeCSSStyle);
    }
    this.unsafeCSSStyle.insertAdjacentText("beforeend", `@layer unsafe {
${unsafeCSS}
}`);
  }
  applyHunksToDOM(result, pre, highlighter2) {
    this.setPreAttributes(pre, highlighter2, result.totalLines);
    pre.innerHTML = "";
    this.code = createCodeNode();
    this.code.innerHTML = this.fileRenderer.renderPartialHTML(result.codeAST);
    pre.appendChild(this.code);
    this.injectUnsafeCSS();
    this.mouseEventManager.setup(pre);
    if ((this.options.overflow ?? "scroll") === "scroll") this.resizeManager.setup(pre);
    else this.resizeManager.cleanUp();
  }
  applyHeaderToDOM(headerAST, container) {
    const { file } = this;
    if (file == null) return;
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = this.headerRenderer.renderResultToHTML(headerAST);
    const newHeader = tempDiv.firstElementChild;
    if (!(newHeader instanceof HTMLElement)) return;
    if (this.headerElement != null) container.shadowRoot?.replaceChild(newHeader, this.headerElement);
    else container.shadowRoot?.prepend(newHeader);
    this.headerElement = newHeader;
    if (this.isContainerManaged) return;
    const { renderCustomMetadata } = this.options;
    if (this.headerMetadata != null) this.headerMetadata.parentNode?.removeChild(this.headerMetadata);
    const content = renderCustomMetadata?.(file) ?? void 0;
    if (content != null) {
      this.headerMetadata = document.createElement("div");
      this.headerMetadata.slot = HEADER_METADATA_SLOT_ID;
      if (content instanceof Element) this.headerMetadata.appendChild(content);
      else this.headerMetadata.innerText = `${content}`;
      container.appendChild(this.headerMetadata);
    }
  }
  getOrCreateFileContainer(fileContainer) {
    this.fileContainer = fileContainer ?? this.fileContainer ?? document.createElement("file-diff");
    if (this.spriteSVG == null) {
      const fragment = document.createElement("div");
      fragment.innerHTML = SVGSpriteSheet;
      const firstChild = fragment.firstChild;
      if (firstChild instanceof SVGElement) {
        this.spriteSVG = firstChild;
        this.fileContainer.shadowRoot?.appendChild(this.spriteSVG);
      }
    }
    return this.fileContainer;
  }
  getOrCreatePre(container) {
    if (this.pre == null) {
      this.pre = document.createElement("pre");
      container.shadowRoot?.appendChild(this.pre);
    } else if (this.pre.parentNode !== container) container.shadowRoot?.appendChild(this.pre);
    return this.pre;
  }
  setPreAttributes(pre, highlighter2, totalLines) {
    const { overflow = "scroll", theme, themeType = "system" } = this.options;
    setWrapperProps({
      pre,
      theme,
      highlighter: highlighter2,
      split: false,
      wrap: overflow === "wrap",
      themeType,
      diffIndicators: "none",
      disableBackground: true,
      totalLines
    });
  }
};

// node_modules/@pierre/precision-diffs/dist/ScrollSyncManager.js
var ScrollSyncManager = class {
  isDeletionsScrolling = false;
  isAdditionsScrolling = false;
  timeoutId = -1;
  codeDeletions;
  codeAdditions;
  cleanUp() {
    this.codeDeletions?.removeEventListener("scroll", this.handleDeletionsScroll);
    this.codeAdditions?.removeEventListener("scroll", this.handleAdditionsScroll);
    clearTimeout(this.timeoutId);
    this.codeDeletions = void 0;
    this.codeAdditions = void 0;
  }
  setup(pre, codeDeletions, codeAdditions) {
    if (codeDeletions == null || codeAdditions == null) for (const element of pre.children ?? []) {
      if (!(element instanceof HTMLElement)) continue;
      if ("deletions" in element.dataset) codeDeletions = element;
      else if ("additions" in element.dataset) codeAdditions = element;
    }
    if (codeAdditions == null || codeDeletions == null) {
      this.cleanUp();
      return;
    }
    this.codeDeletions?.removeEventListener("scroll", this.handleDeletionsScroll);
    this.codeAdditions?.removeEventListener("scroll", this.handleAdditionsScroll);
    this.codeDeletions = codeDeletions;
    this.codeAdditions = codeAdditions;
    codeDeletions.addEventListener("scroll", this.handleDeletionsScroll, { passive: true });
    codeAdditions.addEventListener("scroll", this.handleAdditionsScroll, { passive: true });
  }
  handleDeletionsScroll = () => {
    if (this.isAdditionsScrolling) return;
    this.isDeletionsScrolling = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.isDeletionsScrolling = false;
    }, 300);
    this.codeAdditions?.scrollTo({ left: this.codeDeletions?.scrollLeft });
  };
  handleAdditionsScroll = () => {
    if (this.isDeletionsScrolling) return;
    this.isAdditionsScrolling = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.isAdditionsScrolling = false;
    }, 300);
    this.codeDeletions?.scrollTo({ left: this.codeAdditions?.scrollLeft });
  };
};

// node_modules/@pierre/precision-diffs/dist/utils/parsePatchFiles.js
function processPatch(data) {
  const isGitDiff = GIT_DIFF_FILE_BREAK_REGEX.test(data);
  const rawFiles = data.split(isGitDiff ? GIT_DIFF_FILE_BREAK_REGEX : UNIFIED_DIFF_FILE_BREAK_REGEX);
  let patchMetadata;
  const files = [];
  let currentFile;
  for (const file of rawFiles) {
    if (isGitDiff && !GIT_DIFF_FILE_BREAK_REGEX.test(file)) {
      if (patchMetadata == null) patchMetadata = file;
      else console.error("parsePatchContent: unknown file blob:", file);
      continue;
    } else if (!isGitDiff && !UNIFIED_DIFF_FILE_BREAK_REGEX.test(file)) {
      if (patchMetadata == null) patchMetadata = file;
      else console.error("parsePatchContent: unknown file blob:", file);
      continue;
    }
    const hunks = file.split(FILE_CONTEXT_BLOB);
    currentFile = void 0;
    for (const hunk of hunks) {
      const lines = hunk.split(SPLIT_WITH_NEWLINES);
      const firstLine = lines.shift();
      if (firstLine == null) {
        console.error("parsePatchContent: invalid hunk", hunk);
        continue;
      }
      const match = firstLine.match(HUNK_HEADER);
      if (match == null || currentFile == null) {
        if (currentFile != null) {
          console.error("parsePatchContent: Invalid hunk", hunk);
          continue;
        }
        currentFile = {
          name: "",
          prevName: void 0,
          type: "change",
          hunks: [],
          lines: 0
        };
        lines.unshift(firstLine);
        for (const line of lines) {
          const filenameMatch = line.match(isGitDiff ? FILENAME_HEADER_REGEX_GIT : FILENAME_HEADER_REGEX);
          if (line.startsWith("diff --git")) {
            const [, , prevName, , name] = line.trim().match(ALTERNATE_FILE_NAMES_GIT) ?? [];
            currentFile.name = name;
            if (prevName !== name) currentFile.prevName = prevName;
          } else if (filenameMatch != null) {
            const [, type, fileName] = filenameMatch;
            if (type === "---" && fileName !== "/dev/null") {
              currentFile.prevName = fileName;
              currentFile.name = fileName;
            } else if (type === "+++" && fileName !== "/dev/null") currentFile.name = fileName;
          } else if (isGitDiff) {
            if (line.startsWith("new mode ")) currentFile.mode = line.replace("new mode", "").trim();
            if (line.startsWith("old mode ")) currentFile.oldMode = line.replace("old mode", "").trim();
            if (line.startsWith("new file mode")) {
              currentFile.type = "new";
              currentFile.mode = line.replace("new file mode", "").trim();
            }
            if (line.startsWith("deleted file mode")) {
              currentFile.type = "deleted";
              currentFile.mode = line.replace("deleted file mode", "").trim();
            }
            if (line.startsWith("similarity index")) if (line.startsWith("similarity index 100%")) currentFile.type = "rename-pure";
            else currentFile.type = "rename-changed";
            if (line.startsWith("index ")) {
              const [, mode] = line.trim().match(FILE_MODE_FROM_INDEX) ?? [];
              if (mode != null) currentFile.mode = mode;
            }
            if (line.startsWith("rename from ")) currentFile.prevName = line.replace("rename from ", "");
            if (line.startsWith("rename to ")) currentFile.name = line.replace("rename to ", "");
          }
        }
        continue;
      }
      const hunkData = {
        additionCount: parseInt(match[4] ?? "1"),
        additionStart: parseInt(match[3]),
        deletedCount: parseInt(match[2] ?? "1"),
        deletedStart: parseInt(match[1]),
        hunkContent: lines.length > 0 ? lines : void 0,
        hunkContext: match[5],
        hunkSpecs: firstLine
      };
      if (isNaN(hunkData.additionCount) || isNaN(hunkData.deletedCount) || isNaN(hunkData.additionStart) || isNaN(hunkData.deletedStart)) {
        console.error("parsePatchContent: invalid hunk metadata", hunkData);
        continue;
      }
      if (lines[lines.length - 1] === "\n") lines.pop();
      currentFile.hunks.push(hunkData);
      currentFile.lines += hunkData.hunkContent?.length ?? 0;
    }
    if (currentFile != null) {
      if (!isGitDiff && currentFile.prevName != null && currentFile.name !== currentFile.prevName) if (currentFile.hunks.length > 0) currentFile.type = "rename-changed";
      else currentFile.type = "rename-pure";
      if (currentFile.type !== "rename-pure" && currentFile.type !== "rename-changed") currentFile.prevName = void 0;
      files.push(currentFile);
    }
  }
  return {
    patchMetadata,
    files
  };
}
function parsePatchFiles(data) {
  const patches = [];
  for (const patch of data.split(COMMIT_METADATA_SPLIT)) try {
    patches.push(processPatch(patch));
  } catch (error) {
    console.error(error);
  }
  return patches;
}

// node_modules/@pierre/precision-diffs/dist/utils/parseDiffFromFile.js
function parseDiffFromFile(oldFile, newFile) {
  const fileData = parsePatchFiles(createTwoFilesPatch(oldFile.name, newFile.name, oldFile.contents, newFile.contents, oldFile.header, newFile.header))[0]?.files[0];
  if (fileData == null) throw new Error("parseDiffFrom: FileInvalid diff -- probably need to fix something -- if the files are the same maybe?");
  fileData.oldLines = oldFile.contents.split(SPLIT_WITH_NEWLINES);
  fileData.newLines = newFile.contents.split(SPLIT_WITH_NEWLINES);
  return fileData;
}

// node_modules/@pierre/precision-diffs/dist/FileDiff.js
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal(), 1);
var instanceId2 = -1;
var FileDiff = class {
  static LoadedCustomComponent = PJSContainerLoaded;
  __id = ++instanceId2;
  fileContainer;
  spriteSVG;
  pre;
  unsafeCSSStyle;
  headerElement;
  headerMetadata;
  customHunkElements = [];
  hunksRenderer;
  headerRenderer;
  resizeManager;
  scrollSyncManager;
  mouseEventManager;
  annotationElements = [];
  lineAnnotations = [];
  oldFile;
  newFile;
  fileDiff;
  constructor(options = { theme: DEFAULT_THEMES }, isContainerManaged = false) {
    this.options = options;
    this.isContainerManaged = isContainerManaged;
    this.hunksRenderer = new DiffHunksRenderer({
      ...options,
      hunkSeparators: typeof options.hunkSeparators === "function" ? "custom" : options.hunkSeparators
    });
    this.headerRenderer = new FileHeaderRenderer(options);
    this.resizeManager = new ResizeManager();
    this.scrollSyncManager = new ScrollSyncManager();
    this.mouseEventManager = new MouseEventManager("diff", getMouseEventOptions(options, typeof options.hunkSeparators === "function" || (options.hunkSeparators ?? "line-info") === "line-info" ? this.handleExpandHunk : void 0));
  }
  setOptions(options) {
    if (options == null) return;
    this.options = options;
    this.hunksRenderer.setOptions({
      ...this.options,
      hunkSeparators: typeof options.hunkSeparators === "function" ? "custom" : options.hunkSeparators
    });
    this.mouseEventManager.setOptions(getMouseEventOptions(options, typeof options.hunkSeparators === "function" || (options.hunkSeparators ?? "line-info") === "line-info" ? this.handleExpandHunk : void 0));
  }
  mergeOptions(options) {
    this.options = {
      ...this.options,
      ...options
    };
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.mergeOptions({ themeType });
    this.hunksRenderer.setThemeType(themeType);
    this.headerRenderer.setThemeType(themeType);
    if (this.headerElement != null) if (themeType === "system") delete this.headerElement.dataset.themeType;
    else this.headerElement.dataset.themeType = themeType;
    if (this.pre != null) switch (themeType) {
      case "system":
        delete this.pre.dataset.themeType;
        break;
      case "light":
      case "dark":
        this.pre.dataset.themeType = themeType;
        break;
    }
  }
  setLineAnnotations(lineAnnotations) {
    this.lineAnnotations = lineAnnotations;
  }
  cleanUp() {
    this.hunksRenderer.cleanUp();
    this.headerRenderer.cleanUp();
    this.resizeManager.cleanUp();
    this.mouseEventManager.cleanUp();
    this.scrollSyncManager.cleanUp();
    this.fileDiff = void 0;
    this.oldFile = void 0;
    this.newFile = void 0;
    if (!this.isContainerManaged) this.fileContainer?.parentNode?.removeChild(this.fileContainer);
    this.fileContainer = void 0;
    this.pre = void 0;
    this.headerElement = void 0;
  }
  async hydrate(props) {
    if (props.fileContainer == null) throw new Error("FileDiff: you must provide a fileContainer on hydration");
    for (const element of Array.from(props.fileContainer.shadowRoot?.children ?? [])) {
      if (element instanceof SVGElement) {
        this.spriteSVG = element;
        continue;
      }
      if (!(element instanceof HTMLElement)) continue;
      if (element instanceof HTMLPreElement) {
        this.pre = element;
        continue;
      }
      if ("pjsHeader" in element.dataset) {
        this.headerElement = element;
        continue;
      }
      if (element instanceof HTMLStyleElement) {
        this.unsafeCSSStyle = element;
        continue;
      }
    }
    if (this.pre == null) await this.render(props);
    else {
      this.fileContainer = props.fileContainer;
      delete this.pre.dataset.dehydrated;
      this.lineAnnotations = props.lineAnnotations ?? this.lineAnnotations;
      this.newFile = props.newFile;
      this.oldFile = props.oldFile;
      this.fileDiff = props.fileDiff;
      this.hunksRenderer.initializeHighlighter();
      this.renderAnnotations();
      this.injectUnsafeCSS();
      this.mouseEventManager.setup(this.pre);
      if ((this.options.overflow ?? "scroll") === "scroll") {
        this.resizeManager.setup(this.pre);
        this.scrollSyncManager.setup(this.pre);
      }
    }
  }
  async rerender() {
    await this.render({
      oldFile: this.oldFile,
      newFile: this.newFile,
      fileDiff: this.fileDiff,
      forceRender: true
    });
  }
  handleExpandHunk = (hunkIndex) => {
    this.hunksRenderer.expandHunk(hunkIndex);
    this.rerender();
  };
  async render({ oldFile, newFile, fileDiff, fileContainer, forceRender = false, lineAnnotations, containerWrapper }) {
    const annotationsChanged = lineAnnotations != null && !(0, import_fast_deep_equal2.default)(lineAnnotations, this.lineAnnotations);
    if (!forceRender && oldFile != null && newFile != null && !annotationsChanged && (0, import_fast_deep_equal2.default)(oldFile, this.oldFile) && (0, import_fast_deep_equal2.default)(newFile, this.newFile)) return;
    if (!forceRender && fileDiff != null && fileDiff === this.fileDiff && !annotationsChanged) return;
    this.oldFile = oldFile;
    this.newFile = newFile;
    if (fileDiff != null) this.fileDiff = fileDiff;
    else if (oldFile != null && newFile != null) this.fileDiff = parseDiffFromFile(oldFile, newFile);
    if (lineAnnotations != null) this.setLineAnnotations(lineAnnotations);
    if (this.fileDiff == null) return;
    this.hunksRenderer.setOptions({
      ...this.options,
      hunkSeparators: typeof this.options.hunkSeparators === "function" ? "custom" : this.options.hunkSeparators
    });
    this.hunksRenderer.setLineAnnotations(this.lineAnnotations);
    const { disableFileHeader = false } = this.options;
    if (disableFileHeader) {
      this.headerRenderer.cleanUp();
      if (this.headerElement != null) {
        this.headerElement.parentNode?.removeChild(this.headerElement);
        this.headerElement = void 0;
      }
    } else {
      const { theme, themeType } = this.options;
      this.headerRenderer.setOptions({
        theme,
        themeType
      });
    }
    const [highlighter2, headerResult, hunksResult] = await Promise.all([
      getSharedHighlighter({
        themes: getThemes(this.options.theme),
        langs: []
      }),
      !disableFileHeader ? this.headerRenderer.render(this.fileDiff) : void 0,
      this.hunksRenderer.render(this.fileDiff)
    ]);
    if (headerResult == null && hunksResult == null) return;
    fileContainer = this.getOrCreateFileContainer(fileContainer);
    if (headerResult != null) this.applyHeaderToDOM(headerResult, fileContainer);
    if (hunksResult != null) {
      if (containerWrapper != null) containerWrapper.appendChild(fileContainer);
      const pre = this.getOrCreatePre(fileContainer);
      this.applyHunksToDOM(hunksResult, pre, highlighter2);
      this.renderSeparators(hunksResult.hunkData);
      this.renderAnnotations();
    }
  }
  renderSeparators(hunkData) {
    const { hunkSeparators } = this.options;
    if (this.isContainerManaged || this.fileContainer == null || typeof hunkSeparators !== "function") return;
    for (const element of this.customHunkElements) element.parentNode?.removeChild(element);
    this.customHunkElements.length = 0;
    for (const hunk of hunkData) {
      const element = document.createElement("div");
      element.style.display = "contents";
      element.slot = hunk.slotName;
      element.appendChild(hunkSeparators(hunk));
      this.fileContainer.appendChild(element);
      this.customHunkElements.push(element);
    }
  }
  renderAnnotations() {
    if (this.isContainerManaged || this.fileContainer == null) return;
    for (const element of this.annotationElements) element.parentNode?.removeChild(element);
    this.annotationElements.length = 0;
    const { renderAnnotation } = this.options;
    if (renderAnnotation != null && this.lineAnnotations.length > 0) for (const annotation of this.lineAnnotations) {
      const content = renderAnnotation(annotation);
      if (content == null) continue;
      const el = document.createElement("div");
      el.dataset.annotationSlot = "";
      el.slot = getLineAnnotationName(annotation);
      el.appendChild(content);
      this.annotationElements.push(el);
      this.fileContainer.appendChild(el);
    }
  }
  getOrCreateFileContainer(fileContainer) {
    this.fileContainer = fileContainer ?? this.fileContainer ?? document.createElement("file-diff");
    if (this.spriteSVG == null) {
      const fragment = document.createElement("div");
      fragment.innerHTML = SVGSpriteSheet;
      const firstChild = fragment.firstChild;
      if (firstChild instanceof SVGElement) {
        this.spriteSVG = firstChild;
        this.fileContainer.shadowRoot?.appendChild(this.spriteSVG);
      }
    }
    return this.fileContainer;
  }
  getFileContainer() {
    return this.fileContainer;
  }
  getOrCreatePre(container) {
    if (this.pre == null) {
      this.pre = document.createElement("pre");
      container.shadowRoot?.appendChild(this.pre);
    } else if (this.pre.parentNode !== container) container.shadowRoot?.appendChild(this.pre);
    return this.pre;
  }
  applyHeaderToDOM(headerAST, container) {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = this.headerRenderer.renderResultToHTML(headerAST);
    const newHeader = tempDiv.firstElementChild;
    if (!(newHeader instanceof HTMLElement)) return;
    if (this.headerElement != null) container.shadowRoot?.replaceChild(newHeader, this.headerElement);
    else container.shadowRoot?.prepend(newHeader);
    this.headerElement = newHeader;
    if (this.isContainerManaged) return;
    const { renderHeaderMetadata } = this.options;
    if (this.headerMetadata != null) this.headerMetadata.parentNode?.removeChild(this.headerMetadata);
    const content = renderHeaderMetadata?.({
      oldFile: this.oldFile,
      newFile: this.newFile,
      fileDiff: this.fileDiff
    }) ?? void 0;
    if (content != null) {
      this.headerMetadata = document.createElement("div");
      this.headerMetadata.slot = HEADER_METADATA_SLOT_ID;
      if (content instanceof Element) this.headerMetadata.appendChild(content);
      else this.headerMetadata.innerText = `${content}`;
      container.appendChild(this.headerMetadata);
    }
  }
  setPreAttributes(pre, highlighter2, result) {
    const { diffStyle = "split", overflow = "scroll", theme, themeType = "system", diffIndicators = "bars", disableBackground = false } = this.options;
    setWrapperProps({
      pre,
      theme,
      highlighter: highlighter2,
      split: diffStyle === "unified" ? false : result.additionsAST != null && result.deletionsAST != null,
      wrap: overflow === "wrap",
      themeType,
      diffIndicators,
      disableBackground,
      totalLines: result.totalLines
    });
  }
  injectUnsafeCSS() {
    if (this.fileContainer?.shadowRoot == null) return;
    const { unsafeCSS } = this.options;
    if (unsafeCSS == null || unsafeCSS === "") return;
    if (this.unsafeCSSStyle == null) {
      this.unsafeCSSStyle = document.createElement("style");
      this.fileContainer.shadowRoot.appendChild(this.unsafeCSSStyle);
    }
    this.unsafeCSSStyle.insertAdjacentText("beforeend", `@layer unsafe {
${unsafeCSS}
}`);
  }
  applyHunksToDOM(result, pre, highlighter2) {
    this.setPreAttributes(pre, highlighter2, result);
    pre.innerHTML = "";
    let codeDeletions;
    let codeAdditions;
    if (result.unifiedAST != null) {
      const codeUnified = createCodeNode({ columnType: "unified" });
      codeUnified.innerHTML = this.hunksRenderer.renderPartialHTML(result.unifiedAST);
      pre.appendChild(codeUnified);
    } else {
      if (result.deletionsAST != null) {
        codeDeletions = createCodeNode({ columnType: "deletions" });
        codeDeletions.innerHTML = this.hunksRenderer.renderPartialHTML(result.deletionsAST);
        pre.appendChild(codeDeletions);
      }
      if (result.additionsAST != null) {
        codeAdditions = createCodeNode({ columnType: "additions" });
        codeAdditions.innerHTML = this.hunksRenderer.renderPartialHTML(result.additionsAST);
        pre.appendChild(codeAdditions);
      }
    }
    this.injectUnsafeCSS();
    this.mouseEventManager.setup(pre);
    if ((this.options.overflow ?? "scroll") === "scroll") {
      this.resizeManager.setup(pre);
      this.scrollSyncManager.setup(pre, codeDeletions, codeAdditions);
    } else {
      this.resizeManager.cleanUp();
      this.scrollSyncManager.cleanUp();
    }
  }
};

// node_modules/@pierre/precision-diffs/dist/UniversalRenderer.js
var queuedCallbacks = /* @__PURE__ */ new Set();
var callbacks = /* @__PURE__ */ new Set();
var frameId = null;
var isRendering = false;
function queueRender(callback) {
  if (isRendering) {
    queuedCallbacks.add(callback);
    return;
  }
  callbacks.add(callback);
  frameId ??= requestAnimationFrame(render);
}
function render(time) {
  isRendering = true;
  for (const callback of callbacks) try {
    callback(time);
  } catch (error) {
    console.error(error);
  }
  callbacks.clear();
  if (queuedCallbacks.size > 0) {
    callbacks = new Set(queuedCallbacks);
    queuedCallbacks.clear();
    frameId = requestAnimationFrame(render);
  } else frameId = null;
  isRendering = false;
}

// node_modules/@pierre/precision-diffs/dist/shiki-stream/tokenizer.js
var ShikiStreamTokenizer = class ShikiStreamTokenizer2 {
  options;
  tokensStable = [];
  tokensUnstable = [];
  lastUnstableCodeChunk = "";
  lastStableGrammarState;
  constructor(options) {
    this.options = options;
  }
  /**
  * Enqueue a chunk of code to the buffer.
  */
  async enqueue(chunk) {
    const chunkLines = (this.lastUnstableCodeChunk + chunk).split("\n");
    const stable = [];
    let unstable = [];
    const recall = this.tokensUnstable.length;
    chunkLines.forEach((line, i) => {
      const isLastLine = i === chunkLines.length - 1;
      const result = this.options.highlighter.codeToTokens(line, {
        ...this.options,
        grammarState: this.lastStableGrammarState
      });
      const tokens = result.tokens[0];
      if (!isLastLine) tokens.push({
        content: "\n",
        offset: 0
      });
      if (!isLastLine) {
        this.lastStableGrammarState = result.grammarState;
        stable.push(...tokens);
      } else {
        unstable = tokens;
        this.lastUnstableCodeChunk = line;
      }
    });
    this.tokensStable.push(...stable);
    this.tokensUnstable = unstable;
    return {
      recall,
      stable,
      unstable
    };
  }
  close() {
    const stable = this.tokensUnstable;
    this.tokensUnstable = [];
    this.lastUnstableCodeChunk = "";
    this.lastStableGrammarState = void 0;
    return { stable };
  }
  clear() {
    this.tokensStable = [];
    this.tokensUnstable = [];
    this.lastUnstableCodeChunk = "";
    this.lastStableGrammarState = void 0;
  }
  clone() {
    const clone = new ShikiStreamTokenizer2(this.options);
    clone.lastUnstableCodeChunk = this.lastUnstableCodeChunk;
    clone.tokensUnstable = this.tokensUnstable;
    clone.tokensStable = this.tokensStable;
    clone.lastStableGrammarState = this.lastStableGrammarState;
    return clone;
  }
};

// node_modules/@pierre/precision-diffs/dist/shiki-stream/stream.js
var CodeToTokenTransformStream = class extends TransformStream {
  tokenizer;
  options;
  constructor(options) {
    const tokenizer = new ShikiStreamTokenizer(options);
    const { allowRecalls = false } = options;
    super({
      async transform(chunk, controller) {
        const { stable, unstable: buffer, recall } = await tokenizer.enqueue(chunk);
        if (allowRecalls && recall > 0) controller.enqueue({ recall });
        for (const token of stable) controller.enqueue(token);
        if (allowRecalls) for (const token of buffer) controller.enqueue(token);
      },
      async flush(controller) {
        const { stable } = tokenizer.close();
        if (!allowRecalls) for (const token of stable) controller.enqueue(token);
      }
    });
    this.tokenizer = tokenizer;
    this.options = options;
  }
};

// node_modules/@pierre/precision-diffs/dist/FileStream.js
var FileStream = class {
  highlighter;
  stream;
  fileContainer;
  pre;
  code;
  constructor(options = { theme: DEFAULT_THEMES }) {
    this.options = options;
    this.currentLineIndex = this.options.startingLineIndex ?? 1;
  }
  cleanUp() {
    this.stream?.cancel();
  }
  setThemeType(themeType) {
    if ((this.options.themeType ?? "system") === themeType) return;
    this.options = {
      ...this.options,
      themeType
    };
    if (this.pre != null) switch (themeType) {
      case "system":
        delete this.pre.dataset.themeType;
        break;
      case "light":
      case "dark":
        this.pre.dataset.themeType = themeType;
        break;
    }
  }
  async initializeHighlighter() {
    this.highlighter = await getSharedHighlighter(getHighlighterOptions(this.options.lang, this.options));
    return this.highlighter;
  }
  queuedSetupArgs;
  async setup(_source, _wrapper) {
    const isSettingUp = this.queuedSetupArgs != null;
    this.queuedSetupArgs = [_source, _wrapper];
    if (isSettingUp) return;
    this.highlighter ??= await this.initializeHighlighter();
    const [source, wrapper] = this.queuedSetupArgs;
    this.queuedSetupArgs = void 0;
    const stream = source;
    this.setupStream(stream, wrapper, this.highlighter);
  }
  setupStream(stream, wrapper, highlighter2) {
    const { theme = DEFAULT_THEMES, overflow = "scroll", themeType = "system" } = this.options;
    const fileContainer = this.getOrCreateFileContainer();
    if (fileContainer.parentElement == null) wrapper.appendChild(fileContainer);
    this.pre ??= document.createElement("pre");
    if (this.pre.parentElement == null) fileContainer.shadowRoot?.appendChild(this.pre);
    const pre = setWrapperProps({
      pre: this.pre,
      split: false,
      theme,
      highlighter: highlighter2,
      wrap: overflow === "wrap",
      themeType,
      diffIndicators: "none",
      disableBackground: true,
      totalLines: 0
    });
    pre.innerHTML = "";
    this.pre = pre;
    this.code = createCodeNode({ pre });
    if (this.stream != null) this.stream.cancel();
    const { onStreamStart, onStreamClose, onStreamAbort } = this.options;
    this.stream = stream;
    this.stream.pipeThrough(typeof theme === "string" ? new CodeToTokenTransformStream({
      ...this.options,
      theme,
      highlighter: highlighter2,
      allowRecalls: true,
      defaultColor: false,
      cssVariablePrefix: formatCSSVariablePrefix()
    }) : new CodeToTokenTransformStream({
      ...this.options,
      themes: theme,
      highlighter: highlighter2,
      allowRecalls: true,
      defaultColor: false,
      cssVariablePrefix: formatCSSVariablePrefix()
    })).pipeTo(new WritableStream({
      start(controller) {
        onStreamStart?.(controller);
      },
      close() {
        onStreamClose?.();
      },
      abort(reason) {
        onStreamAbort?.(reason);
      },
      write: this.handleWrite
    }));
  }
  queuedTokens = [];
  handleWrite = (token) => {
    if ("recall" in token && this.queuedTokens.length >= token.recall) this.queuedTokens.length = this.queuedTokens.length - token.recall;
    else this.queuedTokens.push(token);
    queueRender(this.render);
    this.options.onStreamWrite?.(token);
  };
  currentLineIndex;
  currentLineElement;
  render = () => {
    this.options.onPreRender?.(this);
    const linesToAppend = [];
    for (const token of this.queuedTokens) if ("recall" in token) {
      if (this.currentLineElement == null) throw new Error("FileStream.render: no current line element, shouldnt be possible to get here");
      if (token.recall > this.currentLineElement.childNodes.length) throw new Error(`FileStream.render: Token recall exceed the current line, there's probably a bug...`);
      for (let i = 0; i < token.recall; i++) this.currentLineElement.lastChild?.remove();
    } else {
      const span = createSpanFromToken(token);
      if (this.currentLineElement == null) linesToAppend.push(this.createLine());
      this.currentLineElement?.appendChild(span);
      if (token.content === "\n") {
        this.currentLineIndex++;
        linesToAppend.push(this.createLine());
      }
    }
    for (const line of linesToAppend) this.code?.appendChild(line);
    this.queuedTokens.length = 0;
    this.options.onPostRender?.(this);
  };
  createLine() {
    const { row, content } = createRow(this.currentLineIndex);
    this.currentLineElement = content;
    return row;
  }
  getOrCreateFileContainer(fileContainer) {
    if (fileContainer != null && fileContainer === this.fileContainer || fileContainer == null && this.fileContainer != null) return this.fileContainer;
    this.fileContainer = fileContainer ?? document.createElement("file-diff");
    return this.fileContainer;
  }
};
export {
  ALTERNATE_FILE_NAMES_GIT,
  COMMIT_METADATA_SPLIT,
  CodeToTokenTransformStream,
  DEFAULT_THEMES,
  DiffHunksRenderer,
  EXTENSION_TO_FILE_FORMAT,
  FILENAME_HEADER_REGEX,
  FILENAME_HEADER_REGEX_GIT,
  FILE_CONTEXT_BLOB,
  FILE_MODE_FROM_INDEX,
  File,
  FileDiff,
  FileHeaderRenderer,
  FileStream,
  GIT_DIFF_FILE_BREAK_REGEX,
  HEADER_METADATA_SLOT_ID,
  HUNK_HEADER,
  MouseEventManager,
  ResizeManager,
  SPLIT_WITH_NEWLINES,
  ScrollSyncManager,
  ShikiStreamTokenizer,
  UNIFIED_DIFF_FILE_BREAK_REGEX,
  codeToHtml2 as codeToHtml,
  createCodeNode,
  createRow,
  createSpanFromToken,
  disposeHighlighter,
  extendFileFormatMap,
  getFiletypeFromFileName,
  getLineAnnotationName,
  getMouseEventOptions,
  getSharedHighlighter,
  hasLoadedLanguage,
  hasLoadedThemes,
  isHighlighterLoaded,
  isHighlighterLoading,
  isHighlighterNull,
  parseDiffFromFile,
  parseLineType,
  parsePatchFiles,
  preloadHighlighter,
  queueRender,
  registerCustomTheme,
  setWrapperProps
};
//# sourceMappingURL=@pierre_precision-diffs.js.map
